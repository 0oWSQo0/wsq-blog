


## 算术运算符

| 运算符 | 说明  | 实例        | 结果       |
|-----|-----|-----------|----------|
| +   | 加   | 12.45+15  | 27.45    |
| -   | 减   | 4.56-0.26 | 4.3      |
| *   | 乘   | 5*3.6     | 18.0     |
| /   | 除   | 7/2       | 3.5      |
| //  | 整除  | 7//2      | 3        |
| %   | 取余  | 7%2       | 1        |
| **  | 幂运算 | 2**4      | 16即$2^4$ |

当`+`用于数字时表示加法，但是当`+`用于字符串时，它还有拼接字符串（将两个字符串连接为一个）的作用。

`*`除了可以用作乘法运算，还可以用来重复字符串，也即将`n`个同样的字符串连接起来。
## 赋值运算符
### 基本赋值运算符
```python
#将一个变量的值赋给另一个变量
n2 = n1
f2 = f1
#将某些运算的值赋给变量
sum1 = 25 + 46 
sum2 = n1 % 6
s2 = str(1234)  #将数字转换成字符串
s3 = str(100) + "abc"
```
### 连续赋值
```python
a = b = c = 100
```
`=`具有右结合性，我们从右到左分析这个表达式：
* `c = 100`表示将 100 赋值给`c`，所以`c`的值是 100；同时，`c = 100`这个子表达式的值也是 100。
* `b = c = 100`表示将`c = 100`的值赋给`b`，因此`b`的值也是 100。
* 以此类推，`a`的值也是 100。

最终结果就是，`a、b、c`三个变量的值都是 100。
### 扩展后的赋值运算符

| 运算符   | 说明      | 举例        | 等价形式                    |
|-------|---------|-----------|:------------------------|
| =     | 赋值运算符   | x = y     | x = y                   |
| +=    | 加赋值     | x += y    | 	x = x + y              |
| -=    | 减赋值     | x -= y    | x = x - y               |
| *=    | 乘赋值     | x *= y    | x = x * y               |
| /=    | 	除赋值    | x /= y    | x = x / y               |
| %=    | 取余数赋值   | x %= y	   | x = x % y               |
| **=   | 幂赋值     | x **= y	  | x = x ** y              |
| //=   | 取整数赋值   | x //= y	  | x = x // y              |
| &=    | 按位与赋值   | x &= y	   | x = x & y               |
| \|=   | 按位或赋值   | x \|= y   | x = x \| y              |
| ^=    | 按位异或赋值  | x ^= y    | x = x ^ y               |
| <<=   | 左移赋值    | x <<= y	x | x = x << y,  y 指的是左移的位数 |
| >>=   | 右移赋值    | x >>= y   | x = x >> y, y 指的是右移的位数  |

## 位运算符
Python 位运算按照数据在内存中的二进制位进行操作，它一般用于底层开发（算法设计、驱动、图像处理、单片机等），在应用层开发（Web 开发、Linux 运维等）中并不常见。

| 位运算符 | 说明  | 使用形式	  | 举 例    |
|------|---|--------|--------|
| &    | 按位与  | a & b  | 4 & 5  |
| \|   | 按位或  | a \| b | 4 \| 5 |
| ^    | 按位异或  |  a ^ b      |   4 ^ 5     |
|  ~    | 	按位取反  | ~a       |  ~4      |
|   <<   | 	按位左移  | a << b       | 4 << 2，表示整数 4 按位左移 2 位       |
| >>     | 	按位右移  |  a >> b      |  4 >> 2，表示整数 4 按位右移 2 位      |

### & 按位与运算符
按位与运算符&的运算规则是：只有参与&运算的两个位都为 1 时，结果才为 1，否则为 0。例如1&1为 1，0&0为 0，1&0也为 0，这和逻辑运算符&&非常类似。

| 第一个Bit位 | 第二个Bit位	 | 结果 |
|---------|----------|----|
| 0       | 0        | 0  |
| 0       | 1        | 0  |
| 1       | 0        | 0  |
| 1       | 1        | 1  |

例如，`9&5`可以转换成如下的运算：
```
0000 0000 -- 0000 0000 -- 0000 0000 -- 0000 1001  （9 在内存中的存储）
& 0000 0000 -- 0000 0000 -- 0000 0000 -- 0000 0101  （5 在内存中的存储）
-----------------------------------------------------------------------
0000 0000 -- 0000 0000 -- 0000 0000 -- 0000 0001  （1 在内存中的存储）
```
&运算符会对参与运算的两个整数的所有二进制位进行&运算，`9&5`的结果为 1。

又如，`-9&5`可以转换成如下的运算：
```
1111 1111 -- 1111 1111 -- 1111 1111 -- 1111 0111  （-9 在内存中的存储）
& 0000 0000 -- 0000 0000 -- 0000 0000 -- 0000 0101  （5 在内存中的存储）
-----------------------------------------------------------------------
0000 0000 -- 0000 0000 -- 0000 0000 -- 0000 0101  （5 在内存中的存储）
```
-9&5的结果是 5。

再强调一遍，&运算符操作的是数据在内存中存储的原始二进制位，而不是数据本身的二进制形式；其他位运算符也一样。以-9&5为例，-9 的在内存中的存储和 -9 的二进制形式截然不同：
```
1111 1111 -- 1111 1111 -- 1111 1111 -- 1111 0111  （-9 在内存中的存储）
-0000 0000 -- 0000 0000 -- 0000 0000 -- 0000 1001  （-9 的二进制形式，前面多余的0可以抹掉）
```
按位与运算通常用来对某些位清 0，或者保留某些位。例如要把 n 的高 16 位清 0 ，保留低 16 位，可以进行n & 0XFFFF运算（0XFFFF 在内存中的存储形式为 0000 0000 -- 0000 0000 -- 1111 1111 -- 1111 1111）。

使用 Python 代码对上面的分析进行验证：
```python
n = 0X8FA6002D
print("%X" % (9&5) )  # 1
print("%X" % (-9&5) ) # 5
print("%X" % (n&0XFFFF) ) # 2D
```
### | 按位或运算符
按位或运算符|的运算规则是：两个二进制位有一个为 1 时，结果就为 1，两个都为 0 时结果才为 0。例如1|1为 1，0|0为0，1|0 为1，这和逻辑运算中的||非常类似。

| 第一个Bit位 | 第二个Bit位	 | 结果 |
|---------|----------|----|
| 0       | 0        | 0  |
| 0       | 1        | 1  |
| 1       | 0        | 1  |
| 1       | 1        | 1  |

例如，9 | 5可以转换成如下的运算：
```
0000 0000 -- 0000 0000 -- 0000 0000 -- 0000 1001  （9 在内存中的存储）
| 0000 0000 -- 0000 0000 -- 0000 0000 -- 0000 0101  （5 在内存中的存储）
----------------------------------------------------------------------
0000 0000 -- 0000 0000 -- 0000 0000 -- 0000 1101  （13 在内存中的存储）
```
9 | 5的结果为 13。

又如，-9 | 5可以转换成如下的运算：
```
1111 1111 -- 1111 1111 -- 1111 1111 -- 1111 0111  （-9 在内存中的存储）
| 0000 0000 -- 0000 0000 -- 0000 0000 -- 0000 0101  （5 在内存中的存储）
----------------------------------------------------------------------
1111 1111 -- 1111 1111 -- 1111 1111 -- 1111 0111  （-9 在内存中的存储）
```
-9 | 5的结果是 -9。

按位或运算可以用来将某些位置 1，或者保留某些位。例如要把 n 的高 16 位置 1，保留低 16 位，可以进行n | 0XFFFF0000运算（0XFFFF0000 在内存中的存储形式为 1111 1111 -- 1111 1111 -- 0000 0000 -- 0000 0000）。

使用 Python 代码对上面的分析进行验证：
```python
n = 0X2D
print("%X" % (9|5) )   # D
print("%X" % (-9|5) )  # -9
print("%X" % (n|0XFFFF0000) ) # F5F8002D
```

### ^按位异或运算符
按位异或运算^的运算规则是：参与运算的两个二进制位不同时，结果为 1，相同时结果为 0。例如0^1为 1，0^0为 0，1^1为 0。

| 第一个Bit位 | 第二个Bit位	 | 结果 |
|---------|----------|----|
| 0       | 0        | 0  |
| 0       | 1        | 1  |
| 1       | 0        | 1  |
| 1       | 1        | 0  |

例如，`9 ^ 5`可以转换成如下的运算：
```
0000 0000 -- 0000 0000 -- 0000 0000 -- 0000 1001  （9 在内存中的存储）
0000 0000 -- 0000 0000 -- 0000 0000 -- 0000 0101  （5 在内存中的存储）
---------------------------------------------------------------------
0000 0000 -- 0000 0000 -- 0000 0000 -- 0000 1100  （12 在内存中的存储）
```
`9 ^ 5`的结果为 12。

又如，`-9 ^ 5`可以转换成如下的运算：
```
1111 1111 -- 1111 1111 -- 1111 1111 -- 1111 0111  （-9 在内存中的存储）
0000 0000 -- 0000 0000 -- 0000 0000 -- 0000 0101  （5 在内存中的存储）
----------------------------------------------------------------------
1111 1111 -- 1111 1111 -- 1111 1111 -- 1111 0010  （-14 在内存中的存储）
```
`-9 ^ 5`的结果是 -14。

按位异或运算可以用来将某些二进制位反转。例如要把 n 的高 16 位反转，保留低 16 位，可以进行`n ^ 0XFFFF0000`运算（0XFFFF0000 在内存中的存储形式为 1111 1111 -- 1111 1111 -- 0000 0000 -- 0000 0000）。

使用 Python 代码对上面的分析进行验证：
```python
n = 0X0A07002D
print("%X" % (9^5) )  # C
print("%X" % (-9^5) ) # -E
print("%X" % (n^0XFFFF0000) ) # F5F8002D
```
### ~按位取反运算符
按位取反运算符`~`为单目运算符（只有一个操作数），右结合性，作用是对参与运算的二进制位取反。例如~1为0，~0为1，这和逻辑运算中的!非常类似。

例如，`~9`可以转换为如下的运算：
```
0000 0000 -- 0000 0000 -- 0000 0000 -- 0000 1001  （9 在内存中的存储）
-----------------------------------------------------------------------
1111 1111 -- 1111 1111 -- 1111 1111 -- 1111 0110  （-10 在内存中的存储）
```
所以`~9`的结果为 -10。

例如，`~-9`可以转换为如下的运算：
```
~ 1111 1111 -- 1111 1111 -- 1111 1111 -- 1111 0111  （-9 在内存中的存储）
------------------------------------------------------------------------
0000 0000 -- 0000 0000 -- 0000 0000 -- 0000 1000  （8 在内存中的存储）
```
所以`~-9`的结果为 8。

使用 Python 代码对上面的分析进行验证：
```python
print("%X" % (~9) ) # -A
print("%X" % (~-9) ) # 8
```
### <<左移运算符
Python 左移运算符`<<`用来把操作数的各个二进制位全部左移若干位，高位丢弃，低位补 0。

例如，`9<<3`可以转换为如下的运算：
```
0000 0000 -- 0000 0000 -- 0000 0000 -- 0000 1001  （9 在内存中的存储）
-----------------------------------------------------------------------
0000 0000 -- 0000 0000 -- 0000 0000 -- 0100 1000  （72 在内存中的存储）
```
所以`9<<3`的结果为 72。

又如，`(-9)<<3`可以转换为如下的运算：
```
1111 1111 -- 1111 1111 -- 1111 1111 -- 1111 0111  （-9 在内存中的存储）
------------------------------------------------------------------------
1111 1111 -- 1111 1111 -- 1111 1111 -- 1011 1000  （-72 在内存中的存储）
```
所以`(-9)<<3`的结果为 -72。

如果数据较小，被丢弃的高位不包含 1，那么左移 n 位相当于乘以 2 的 n 次方。

使用 Python 代码对上面的分析进行验证：
```python
print("%X" % (9<<3) ) # 48
print("%X" % ((-9)<<3) ) # -48
```
### >>右移运算符
Python 右移运算符`>>`用来把操作数的各个二进制位全部右移若干位，低位丢弃，高位补 0 或 1。如果数据的最高位是 0，那么就补 0；如果最高位是 1，那么就补 1。

例如，`9>>3`可以转换为如下的运算：
```
0000 0000 -- 0000 0000 -- 0000 0000 -- 0000 1001  （9 在内存中的存储）
----------------------------------------------------------------------
0000 0000 -- 0000 0000 -- 0000 0000 -- 0000 0001  （1 在内存中的存储）
```
所以`9>>3`的结果为 1。

又如，`(-9)>>3`可以转换为如下的运算：
```
1111 1111 -- 1111 1111 -- 1111 1111 -- 1111 0111  （-9 在内存中的存储）
-----------------------------------------------------------------------
1111 1111 -- 1111 1111 -- 1111 1111 -- 1111 1110  （-2 在内存中的存储）
```
所以`(-9)>>3`的结果为 -2。

如果被丢弃的低位不包含 1，那么右移 n 位相当于除以 2 的 n 次方（但被移除的位中经常会包含 1）。

使用 Python 代码对上面的分析进行验证：
```python
print("%X" % (9>>3) )  # 1
print("%X" % ((-9)>>3) ) # -2
```
## 比较运算符

| 运算符	   | 说明  |
|--------|---|
| >      | 大于，如果>前面的值大于后面的值，则返回 True，否则返回 False |
| <      | 小于，如果<前面的值小于后面的值，则返回 True，否则返回 False |
| ==     | 等于，如果==两边的值相等，则返回 True，否则返回 False  |
| >=     | 大于等于（等价于数学中的 ≥），如果>=前面的值大于或者等于后面的值，则返回 True，否则返回 False |
| <=     | 小于等于（等价于数学中的 ≤），如果<=前面的值小于或者等于后面的值，则返回 True，否则返回 False |
| !=     | 不等于（等价于数学中的 ≠），如果!=两边的值不相等，则返回 True，否则返回 False |
| is     | 判断两个变量所引用的对象是否相同，如果相同则返回 True，否则返回 False  |
| is not | 判断两个变量所引用的对象是否不相同，如果不相同则返回 True，否则返回 False  |

```python
print("89是否大于100：", 89 > 100)
print("24*5是否大于等于76：", 24*5 >= 76)
print("86.5是否等于86.5：", 86.5 == 86.5)
print("34是否等于34.0：", 34 == 34.0)
print("False是否小于True：", False < True)
print("True是否等于True：", True < True)
```
```
89是否大于100： False
24*5是否大于等于76： True
86.5是否等于86.5： True
34是否等于34.0： True
False是否小于True： True
True是否等于True： False
```
### == 和 is 的区别
== 用来比较两个变量的值是否相等，而 is 则用来比对两个变量引用的是否是同一个对象：
```python
import time  #引入time模块
t1 = time.gmtime() # gmtime()用来获取当前时间
t2 =  time.gmtime()
print(t1 == t2) #输出True
print(t1 is t2) #输出False
```
运行结果：
```
True
False
```
`time`模块的`gmtime()`方法用来获取当前的系统时间，精确到秒级，因为程序运行非常快，所以`t1`和`t2`得到的时间是一样的。`==`用来判断`t1`和`t2`的值是否相等，所以返回`True`。

虽然`t1`和`t2`的值相等，但它们是两个不同的对象（每次调用`gmtime()`都返回不同的对象），所以`t1 is t2`返回`False`。
## 逻辑运算符

| 逻辑运算符 | 含义                 | 基本格式     |
|-----|--------------------|----------|
| and | 逻辑与运算，等价于数学中的“且”   | a and b  |
| or  | 逻辑或运算，等价于数学中的“或”   | a or b   |
| not | 逻辑非运算，等价于数学中的“非”   | not a    |

```python
age = int(input("请输入年龄："))
height = int(input("请输入身高："))
if age>=18 and age<=30 and height >=170 and height <= 185 :
    print("恭喜，你符合报考飞行员的条件")
else:
    print("抱歉，你不符合报考飞行员的条件")
```
Python 逻辑运算符可以用来操作任何类型的表达式，不管表达式是不是`bool`类型；同时，逻辑运算的结果也不一定是`bool`类型，它也可以是任意类型。
### 逻辑运算符的本质
在 Python 中，`and`和`or`不一定会计算右边表达式的值，有时候只计算左边表达式的值就能得到最终结果。

另外，`and`和`or`运算符会将其中一个表达式的值作为最终结果，而不是将`True`或者`False`作为最终结果。

对于`and`运算符，两边的值都为真时最终结果才为真，但是只要其中有一个值为假，那么最终结果就是假，所以 Python 按照下面的规则执行`and`运算：
* 如果左边表达式的值为假，那么就不用计算右边表达式的值了，因为不管右边表达式的值是什么，都不会影响最终结果，最终结果都是假，此时`and`会把左边表达式的值作为最终结果。
* 如果左边表达式的值为真，那么最终值是不能确定的，`and`会继续计算右边表达式的值，并将右边表达式的值作为最终结果。

对于`or`运算符，情况是类似的，两边的值都为假时最终结果才为假，只要其中有一个值为真，那么最终结果就是真，所以 Python 按照下面的规则执行`or`运算：
* 如果左边表达式的值为真，那么就不用计算右边表达式的值了，因为不管右边表达式的值是什么，都不会影响最终结果，最终结果都是真，此时`or`会把左边表达式的值作为最终结果。
* 如果左边表达式的值为假，那么最终值是不能确定的，`or`会继续计算右边表达式的值，并将右边表达式的值作为最终结果。


## 三目运算符
这是一种类似于其它编程语言中三目运算符`?:`的写法。Python 是一种极简主义的编程语言，它没有引入`?:`这个新的运算符，而是使用已有的`if else`关键字来实现相同的功能。
```python
exp1 if contion else exp2
```
`condition`是判断条件，`exp1`和`exp2`是两个表达式。如果`condition`成立（结果为真），就执行`exp1`，并把`exp1`的结果作为整个表达式的结果；如果`condition`不成立（结果为假），就执行`exp2`，并把`exp2`的结果作为整个表达式的结果。
### 三目运算符的嵌套
Python 三目运算符支持嵌套，如此可以构成更加复杂的表达式。在嵌套时需要注意`if`和`else`的配对：
```python
a if a>b else c if c>d else d
```
应该理解为：
```python
a if a>b else ( c if c>d else d )
```
```python
a = int( input("Input a: ") )
b = int( input("Input b: ") )
print("a大于b") if a>b else ( print("a小于b") if a<b else print("a等于b") )
```
可能的运行结果：
```python
Input a: 45↙
Input b: 100↙
a小于b
```
该程序是一个嵌套的三目运算符。程序先对`a>b`求值，如果该表达式为`True`，程序就返回执行第一个表达式`print("a大于b")`，否则将继续执行`else`后面的内容，也就是：
```python
( print("a小于b") if a<b else print("a等于b") )
```
## 运算符优先级
