---
title: Linux入门
date: 2024-02-05
tags: linux基础
categories: linux
order: 1
---


## 文件系统的层次结构
在 Linux 操作系统中，所有的文件和目录都被组织成以一个根节点“/”开始的倒置的树状结构。

![Linux 系统文件和目录组织示意图](Linux入门/1.gif)

文件系统的最顶层是由根目录开始的，系统使用“/”来表示根目录，在根目录之下的既可以是目录，也可以是文件，而每一个目录中又可以包含（子）目录或文件。如此反复就可以构成一个庞大的文件系统。
## Linux文件目录结构
`FHS（Filesystem Hierarchy Standard）`，文件系统层次化标准，该标准规定了 Linux 系统中所有一级目录以及部分二级目录（`/usr`和`/var`）的用途。发布此标准的主要目的就是为了让用户清楚地了解每个目录应该存放什么类型的文件。

### 根目录（/）

一级目录    | 功能（作用）|
| :--: | :-- |
| `/bin/`   | 存放系统命令，普通用户和 root 都可以执行。放在`/bin`下的命令在单用户模式下也可以执行|
| `/boot/`  | 系统启动目录，保存与系统启动相关的文件，如内核文件和启动引导程序（`grub`）文件等|
| `/dev/`   | 设备文件保存位置|
| `/etc/`   | 配置文件保存位置。系统内所有采用默认安装方式（`rpm`安装）的服务配置文件全部保存在此目录中，如用户信息、服务的启动脚本、常用服务的配置文件等|
| `/home/`  | 普通用户的主目录（也称为家目录）。在创建用户时，每个用户要有一个默认登录和保存自己数据的位置，就是用户的主目录，所有普通用户的主目录是在`/home/`下建立一个和用户名相同的目录。如用户`liming`的主目录就是`/home/liming`|
| `/lib/`   | 系统调用的函数库保存位置|
| `/media/` | 挂载目录。系统建议用来挂载媒体设备，如软盘和光盘|
| `/mnt/`   | 挂载目录。早期 Linux 中只有这一个挂载目录，并没有细分。系统建议这个目录用来挂载额外的设备，如 U 盘、移动硬盘和其他操作系统的分区|
| `/misc/`  | 挂载目录。系统建议用来挂载 NFS 服务的共享目录。虽然系统准备了三个默认挂载目录`/media/、/mnt/、/misc/`，但是到底在哪个目录中挂载什么设备可以由管理员自己决定。如`/mnt/cdrom/`挂载光盘、`/mnt/usb/`挂载 U 盘，都是可以的|
| `/opt/`     | 第三方安装的软件保存位置。这个目录是放置和安装其他软件的位置，手工安装的源码包软件都可以安装到这个目录中。不过还是习惯把软件放到`/usr/local/`目录中，也就是说，`/usr/local/`目录也可以用来安装软件|
| `/root/`    | `root`的主目录。普通用户主目录在`/home/`下，`root`主目录直接在“/”下|
| `/sbin/`    | 保存与系统环境设置相关的命令，只有`root`可以使用这些命令进行系统环境设置，但也有些命令可以允许普通用户查看| 
| `/srv/`     | 服务数据目录。一些系统服务启动之后，可以在这个目录中保存所需要的数据| 
| `/tmp/`     | 临时目录。系统存放临时文件的目录，在该目录下，所有用户都可以访问和写入。建议此目录中不能保存重要数据，最好每次开机都把该目录清空| 
| `/lost+found/` | 当系统意外崩溃或意外关机时，产生的一些文件碎片会存放在这里。在系统启动的过程中，`fsck`工具会检查这里，并修复已经损坏的文件系统。这个目录只在每个分区中出现，例如，`/lost+found`就是根分区的备份恢复目录，`/boot/lost+found`就是`/boot`分区的备份恢复目录 |
| `/proc/`    | 虚拟文件系统。该目录中的数据并不保存在硬盘上，而是保存到内存中。主要保存系统的内核、进程、外部设备状态和网络状态等。如`/proc/cpuinfo`是保存 CPU 信息的，`/proc/devices`是保存设备驱动的列表的，`/proc/filesystems`是保存文件系统列表的，`/proc/net`是保存网络协议信息的...... |
| `/sys/`     | 虚拟文件系统。和`/proc/`目录相似，该目录中的数据都保存在内存中，主要保存与内核相关的信息 |

### /usr目录
`usr`，全称为`Unix Software Resource`，此目录用于存储系统软件资源。

Linux 系统中，所有系统默认的软件都存储在`/usr`目录下。

| 子目录	        | 功能（作用） |
| :--: | :-- |
| `/usr/bin/`	| 存放系统命令，普通用户和超级用户都可以执行。这些命令和系统启动无关，在单用户模式下不能执行 |
| `/usr/sbin/` 	| 存放根文件系统不必要的系统管理命令，如多数服务程序，只有 root 可以使用。 |
| `/usr/lib/`	| 应用程序调用的函数库保存位置 |
| `/usr/XllR6/`	| 图形界面系统保存位置 |
| `/usr/local/`	| 手工安装的软件保存位置。我们一般建议源码包软件安装在这个位置 |
| `/usr/share/`	| 应用程序的资源文件保存位置，如帮助文档、说明文档和字体目录 |
| `/usr/src/`	| 源码包保存位置。我们手工下载的源码包和内核源码包都可以保存到这里。 |
| `/usr/include`| C/C++ 等编程语言头文件的放置目录 |

### /var 目录
`/var`目录用于存储动态数据，例如缓存、日志文件、软件运行过程中产生的文件等。

| `/var`子目录	  | 功能（作用） |
| :--: | :-- |
| `/var/lib/`	  | 程序运行中需要调用或改变的数据保存位置。如 MySQL 的数据库保存在`/var/lib/mysql/`目录中 |
| `/var/log/`	  | 登陆文件放置的目录，其中所包含比较重要的文件如`/var/log/messages, /var/log/wtmp`等。 |
| `/var/run/`	  | 一些服务和程序运行后，它们的 PID（进程 ID）保存位置 |
| `/var/spool/`	  | 里面主要都是一些临时存放，随时会被用户所调用的数据，例如`/var/spool/mail/`存放新收到的邮件，`/var/spool/cron/`存放系统定时任务。 |
| `/var/www/`	  | RPM 包安装的 Apache 的网页主目录 |
| `/var/nis和/var/yp` | NIS 服务机制所使用的目录，`nis`主要记录所有网络中每一个`client`的连接信息；`yp`是 linux 的`nis`服务的日志文件存放的目录 |
| `/var/tmp`	  | 一些应用程序在安装或执行时，需要在重启后使用的某些文件，此目录能将该类文件暂时存放起来，完成后再行删除 |

## Linux中一切皆文件
Linux 中所有内容都是以文件的形式保存和管理的，即一切皆文件，普通文件是文件，目录是文件，硬件设备（键盘、监视器、硬盘、打印机）是文件，就连套接字（`socket`）、网络通信等资源也都是文件。

Linux系统中，文件可分为以下几种类型：
1. 普通文件（`-`），类似 mp4、pdf、html 这样，可直接拿来使用的文件都属于普通文件，用户根据访问权限的不同可以对这些文件进行查看、删除以及更改操作。
2. 目录文件（`d`），Linux 系统中，目录文件包含了此目录中各个文件的文件名以及指向这些文件的指针，打开目录等同于打开目录文件，只要你有权限，可以随意访问目录中的任何文件。
3. 字符设备文件（`c`）和块设备文件（`b`），这些文件通常隐藏在`/dev/`目录下，当进行设备读取或外设交互时才会被使用。例如，磁盘光驱属于块设备文件，串口设备则属于字符设备文件。Linux 系统中的所有设备，要么是块设备文件，要么是字符设备文件。
4. 套接字文件（`s`），套接字文件一般隐藏在`/var/run/`目录下，用于进程间的网络通信。
5. 符号链接文件（`l`），类似 Windows 中的快捷方式，是指向另一文件的指针（也就是软链接）。
6. 管道文件（`p`），主要用于进程间通信。例如，使用`mkfifo`命令创建一个 FIFO 文件，与此同时，启用进程 A 从 FIFO 文件读数据，启用进程 B 从 FIFO文件中写数据，随写随读。

## 命令基本格式
### 命令提示符
登录系统后，第一眼看到的内容是：
```
[root@localhost ~]#
```
这就是 Linux 系统的命令提示符。
* `[]`：这是提示符的分隔符号，没有特殊含义。
* `root`：显示的是当前的登录用户。
* `@`：分隔符号，没有特殊含义。
* `localhost`：当前系统的简写主机名（完整主机名是`localhost.localdomain`）。
* `~`：代表用户当前所在的目录，此例中用户当前所在的目录是家目录。
* `#`：命令提示符，Linux 用这个符号标识登录的用户权限等级。如果是超级用户，提示符就是`#`；如果是普通用户，提示符就是`$`。

Linux 系统是纯字符界面，用户登录后，要有一个初始登录的位置，这个初始登录位置就称为用户的主目录：
* 超级用户的主目录：`/root`。
* 普通用户的主目录：`/home/用户名`。

```
[root@localhost ~]# cd /usr/local
[root@localhost local]#
```
如果切换用户所在目录，那么命令提示符中的会变成用户当前所在目录的最后一个目录（不显示完整的所在目录`/usr/ local`，只显示最后一个目录`local`）。
### 命令的基本格式
```
[root@localhost ~]# 命令 [选项] [参数]
```
命令格式中的`[]`代表可选项，也就是有些命令可以不写选项或参数，也能执行。
#### 1.选项的作用
Linux 的选项又分为短格式选项（`-l`）和长格式选项（`--all`）。短格式选项是英文的简写，用一个减号调用。
```bash
[root@localhost ~]# ls -l
```
而长格式选项是英文完整单词，一般用两个减号调用。
```bash
[root@localhost ~]# ls --all
```
一般情况下，短格式选项是长格式选项的缩写，也就是一个短格式选项会有对应的长格式选项。当然也有例外，比如`ls`命令的短格式选项`-l`就没有对应的长格式选项。
#### 2.参数的作用
参数是命令的操作对象，一般文件、目录、用户和进程等可以作为参数被命令操作。
```bash
[root@localhost ~]# ls -l anaconda-ks.cfg
-rw-------.1 root root 1207 1 月 14 18:18 anaconda-ks.cfg
```
命令一般都需要加入参数，用于指定命令操作的对象是谁。如果可以省略参数，则一般都有默认参数。
```bash
[root@localhost ~]# ls
anaconda-ks.cfg install.log install.log.syslog
```
这个`ls`命令后面没有指定参数，默认参数是当前所在位置，所以会显示当前目录下的文件名。

总结一下：命令的选项用于调整命令功能，而命令的参数是这个命令的操作对象。

## Linux命令的执行过程
Linux 命令的执行过程分为如下 4 个步骤：
### 1. 判断路径
判断用户是否以绝对路径或相对路径的方式输入命令（如`/bin/ls`），如果是的话直接执行。
### 2. 检查别名
Linux 系统会检查用户输入的命令是否为“别名命令”。要知道，通过`alias`命令是可以给现有命令自定义别名的，即用一个自定义的命令名称来替换原本的命令名称。

例如，我们经常使用的`rm`命令，其实就是`rm -i`这个整体的别名：
```bash
[root@localhost ~]# alias rm
alias rm='rm -i'
```
这使得当使用`rm`命令删除指定文件时，Linux 系统会要求我们再次确认是否执行删除操作。
```bash
[root@localhost ~]# rm a.txt <-- 假定当前目录中已经存在 a.txt 文件
rm: remove regular file 'a.txt'? y <-- 手动输入 y，即确定删除
[root@localhost ~]#
```
这里可以使用`unalias`命令，将 Linux 系统设置的`rm`别名删除掉：
```bash
[root@localhost ~]# alias rm
alias rm='rm -i'
[root@localhost ~]# unalias rm
[root@localhost ~]# rm a.txt
[root@localhost ~]# <--直接删除，不再询问
```
### 3. 判断是内部命令还是外部命令
Linux命令行解释器（又称为 shell）会判断用户输入的命令是内部命令还是外部命令。其中，内部命令指的是解释器内部的命令，会被直接执行；而用户通常输入的命令都是外部命令，这些命令交给步骤四继续处理。

内部命令由 Shell 自带，会随着系统启动，可以直接从内存中读取；而外部命令仅是在系统中有对应的可执行文件，执行时需要读取该文件。

判断一个命令属于内部命令还是外部命令，可以使用`type`命令实现。
```bash
[root@localhost ~]# type pwd
pwd is a shell builtin <-- pwd是内部命令
[root@localhost ~]# type top
top is /usr/bin/top <-- top是外部命令
```
### 4. 查找外部命令对应的可执行文件
当用户执行的是外部命令时，系统会在指定的多个路径中查找该命令的可执行文件，而定义这些路径的变量，就称为`PATH`环境变量，其作用就是告诉 Shell 待执行命令的可执行文件可能存放的位置，也就是说，Shell 会在`PATH`变量包含的多个路径中逐个查找，直到找到为止（如果找不到，Shell 会提供用户“找不到此命令”）。
## Linux环境变量
在 Linux 系统中，环境变量是用来定义系统运行环境的一些参数，比如每个用户不同的家目录、邮件存放位置等。

值得一提的是，Linux 系统中环境变量的名称一般都是大写的，这是一种约定俗成的规范。

我们可以使用`env`命令来查看到 Linux 系统中所有的环境变量：
```bash
[root@localhost ~]# env
ORBIT_SOCKETDIR=/tmp/orbit-root
HOSTNAME=livecd.centos
GIO_LAUNCHED_DESKTOP_FILE_PID=2065
TERM=xterm
shell =/bin/bash
......
```
非常重要的环境变量：

| 环境变量名称   | 作用 |
| :--: | :--: |
| HOME           | 用户的主目录（也称家目录） |
| SHELL          | 用户使用的 Shell 解释器名称 |
| PATH           | 定义命令行解释器搜索用户执行命令的路径 |
| EDITOR         | 用户默认的文本解释器 |
| RANDOM         | 生成一个随机数字 |
| LANG           | 系统语言、语系名称 |
| HISTSIZE       | 输出的历史命令记录条数 |
| HISTFILESIZE   | 保存的历史命令记录条数 |
| PS1            | ash解释器的提示符 |
| MAIL           | 邮件保存路径 |

Linux 作为一个多用户多任务的操作系统，能够为每个用户提供独立的、合适的工作运行环境，因此，一个相同的环境变量会因为用户身份的不同而具有不同的值。

例如，使用下述命令来查看`HOME`变量在不同用户身份下都有哪些值：
```bash
[root@localhost ~]# echo $HOME
/root
[root@localhost ~]# su - user1 <--切换到 user1 用户身份
[user1@localhost ~]$ echo $HOME
/home/user1
```
其实，环境变量是由固定的变量名与用户或系统设置的变量值两部分组成的，我们完全可以自行创建环境变量来满足工作需求。例如，设置一个名称为`WORKDIR`的环境变量，方便用户更轻松地进入一个层次较深的目录，执行命令如下：
```bash
[root@localhost ~]# mkdir /home/work1
[root@localhost ~]# WORKDIR=/home/work1
[root@localhost ~]# cd $WORKDIR
[root@localhost work1]# pwd
/home/work1
```
但是，这样的环境变量不具有全局性，作用范围也有限，默认情况下不能被其他用户使用。如果工作需要，可以使用`export`命令将其提升为全局环境变量，这样其他用户就可以使用它了：
```bash
[root@localhost work1]# su user1 <-- 切换到 user1，发现无法使用 WORKDIR 自定义变量
[user1@localhost ~]$ cd $WORKDIR
[user1@localhost ~]$ echo $WORKDIR

[user1@localhost ~]$ exit <--退出user1身份
[root@localhost work1]# export WORKDIR
[root@localhost work1]# su user1
[user1@localhost ~]$ cd $WORKDIR
[user1@localhost work1]$ pwd
/home/work1
```
### PATH 环境变量及作用
`which`命令，它用于查找某个命令所在的绝对路径。
```bash
[root@localhost ~]# which rm
/bin/rm
[root@localhost ~]# which rmdir
/bin/rmdir
[root@localhost ~]# which ls
alias ls='ls --color=auto'
        /bin/ls
```
注意，`ls`是一个相对特殊的命令，它使用`alias`命令做了别名，也就是说，我们常用的`ls`实际上执行的是`ls --color=auto`。

通过使用`which`命令，可以查找各个外部命令（和 shell 内置命令相对）所在的绝对路径。为什么前面在使用`rm、rmdir、ls`等命令时，无论当前位于哪个目录，都可以直接使用，而无需指明命令的执行文件所在的位置（绝对路径）呢？其实，这是`PATH`环境变量在起作用。

首先，执行如下命令：
```bash
[root@localhost ~]# echo $PATH
/usr/local/sbin:/usr/sbin:/sbin:/usr/local/bin:/usr/bin:/bin:/root/bin
```
这里的`echo`命令用来输出`PATH`环境变量的值（这里的`$`是`PATH`的前缀符号），`PATH`环境变量的内容是由一堆目录组成的，各目录之间用冒号“:”隔开。当执行某个命令时，Linux 会依照`PATH`中包含的目录依次搜寻该命令的可执行文件，一旦找到，即正常执行；反之，则提示无法找到该命令。

如果在`PATH`包含的目录中，有多个目录都包含某命令的可执行文件，那么会执行先搜索到的可执行文件。

从执行结果中可以看到，`/bin`目录已经包含在`PATH`环境变量中，因此在使用类似`rm、rmdir、ls`等命令时，即便直接使用其命令名，Linux 也可以找到该命令。
