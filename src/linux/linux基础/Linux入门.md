---
title: Linux入门
date: 2024-02-05
tags: linux基础
categories: linux
order: 1
---

## 命令格式
### 命令提示符
登录系统后，第一眼看到的内容是：
```
[root@localhost ~]#
```
这就是 Linux 系统的命令提示符。
* `[]`：这是提示符的分隔符号，没有特殊含义
* `root`：显示的是当前的登录用户
* `@`：分隔符号，没有特殊含义
* `localhost`：当前系统的简写主机名（完整主机名是`localhost.localdomain`）
* `~`：代表用户当前所在的目录，此例中用户当前所在的目录是家目录
* `#`：命令提示符，Linux 用这个符号标识登录的用户权限等级。如果是超级用户，提示符就是`#`；如果是普通用户，提示符就是`$`

用户登录后，要有一个初始登录的位置，这个初始登录位置就称为用户的主目录：
* 超级用户的主目录：`/root`
* 普通用户的主目录：`/home/用户名`

```
[root@localhost ~]# cd /usr/local
[root@localhost local]#
```
如果切换用户所在目录，那么命令提示符中的会变成用户当前所在目录的最后一个目录（不显示完整的所在目录`/usr/ local`，只显示最后一个目录`local`）。
### 环境变量 PS1
命令提示符通常是美元符号`$`，对于根用户则是井号`#`。这个符号是环境变量`PS1`决定的，执行下面的命令，可以看到当前命令提示符的定义。
```shell
$ echo $PS1
```
Bash 允许用户自定义命令提示符，只要改写这个变量即可。改写后的`PS1`，可以放在用户的 Bash 配置文件`.bashrc`里面，以后新建 Bash 对话时，新的提示符就会生效。要在当前窗口看到修改后的提示符，可以执行下面的命令。
```shell
$ source ~/.bashrc
```
命令提示符的定义，可以包含特殊的转义字符，表示特定内容。

| 转义字符 | 说明 |
|------|----|
| \a     | 响铃，计算机发出一记声音   |
| \d     | 以星期、月、日格式表示当前日期，例如“Mon May 26”   |
| \h     | 本机的主机名   |
| \H     | 完整的主机名   |
| \j     | 运行在当前 Shell 会话的工作数   |
| \l     | 当前终端设备名   |
| \n     | 一个换行符   |
| \r     | 一个回车符   |
| \s     | Shell 的名称   |
| \t     | 24小时制的hours:minutes:seconds格式表示当前时间   |
| \T     | 12小时制的当前时间   |
| \@     | 12小时制的AM/PM格式表示当前时间   |
| \A     | 24小时制的hours:minutes表示当前时间   |
| \u     | 当前用户名   |
| \v     | Shell 的版本号   |
| \V     | Shell 的版本号和发布号   |
| \w     | 当前的工作路径   |
| \W     | 当前目录名   |
| \!     | 当前命令在命令历史中的编号   |
| \#     | 当前 shell 会话中的命令数   |
| \$     | 普通用户显示为$字符，根用户显示为#字符   |
| \[     | 非打印字符序列的开始标志   |
| \]     | 非打印字符序列的结束标志   |

举例来说，`[\u@\h \W]\$`这个提示符定义，显示出来就是`[user@host ~]$`（具体的显示内容取决于你的系统）。
```shell
[user@host ~]$ echo $PS1
[\u@\h \W]\$
```
改写`PS1`变量，就可以改变这个命令提示符。
```shell
$ PS1="\A \h \$ "
17:33 host $
```
注意，`$`后面最好跟一个空格，这样的话，用户的输入与提示符就不会连在一起。
### 命令的基本格式
```
[root@localhost ~]# 命令 [选项] [参数]
```
命令格式中的`[]`代表可选项，也就是有些命令可以不写选项或参数，也能执行。
#### 选项的作用
Linux 的选项又分为短格式选项（`-l`）和长格式选项（`--all`）。短格式选项是英文的简写，用一个减号调用。
```bash
[root@localhost ~]# ls -l
```
而长格式选项是英文完整单词，一般用两个减号调用。
```bash
[root@localhost ~]# ls --all
```
一般情况下，短格式选项是长格式选项的缩写，也就是一个短格式选项会有对应的长格式选项。当然也有例外，比如`ls`命令的短格式选项`-l`就没有对应的长格式选项。

单个命令一般都是一行，用户按下回车键，就开始执行。有些命令比较长，写成多行会有利于阅读和编辑，这时可以在每一行的结尾加上反斜杠，Bash 就会将下一行跟当前行放在一起解释。
```shell
[root@localhost ~]# echo foo bar
# 等同于
[root@localhost ~]# echo foo \
bar
```
#### 参数的作用
参数是命令的操作对象，一般文件、目录、用户和进程等可以作为参数被命令操作。
```bash
[root@localhost ~]# ls -l anaconda-ks.cfg
-rw-------.1 root root 1207 1 月 14 18:18 anaconda-ks.cfg
```
命令一般都需要加入参数，用于指定命令操作的对象是谁。如果可以省略参数，则一般都有默认参数。
```bash
[root@localhost ~]# ls
anaconda-ks.cfg install.log install.log.syslog
```
这个`ls`命令后面没有指定参数，默认参数是当前所在位置，所以会显示当前目录下的文件名。
:::tip
命令的选项用于调整命令功能，而命令的参数是这个命令的操作对象。
:::

### 空格
Shell 使用空格（或`Tab`键）区分不同的参数。
```shell
[root@localhost ~]# command foo bar
```
上面命令中，`foo`和`bar`之间有一个空格，所以 Shell 认为它们是两个参数。

如果参数之间有多个空格，Shell 会自动忽略多余的空格。
```shell
[root@localhost ~]# echo this is a     test
this is a test
```
上面命令中，`a`和`test`之间有多个空格，Shell 会忽略多余的空格。
### 分号
分号（`;`）是命令的结束符，使得一行可以放置多个命令，上一个命令执行结束后，再执行第二个命令。
```shell
[root@localhost ~]# clear; ls
```
上面例子中，先执行`clear`命令，执行完成后，再执行`ls`命令。
:::warning
注意，使用分号时，第二个命令总是接着第一个命令执行，不管第一个命令执行成功或失败。
:::
### 命令的组合符&&和||
除了分号，Shell 还提供两个命令组合符`&&`和`||`，允许更好地控制多个命令之间的继发关系。
```shell
Command1 && Command2
```
上面命令的意思是，如果`Command1`命令运行成功，则继续运行`Command2`命令。
```shell
Command1 || Command2
```
上面命令的意思是，如果`Command1`命令运行失败，则继续运行`Command2`命令。
```shell
[root@localhost ~]# cat filelist.txt; ls -l filelist.txt
```
上面例子中，只要`cat`命令执行结束，不管成功或失败，都会继续执行`ls`命令。
```shell
[root@localhost ~]# cat filelist.txt && ls -l filelist.txt
```
上面例子中，只有`cat`命令执行成功，才会继续执行`ls`命令。如果`cat`执行失败（比如不存在文件`flielist.txt`），那么`ls`命令就不会执行。
```shell
[root@localhost ~]# mkdir foo || mkdir bar
```
上面例子中，只有`mkdir foo`命令执行失败（比如`foo`目录已经存在），才会继续执行`mkdir bar`命令。如果`mkdir foo`命令执行成功，就不会创建`bar`目录了。
### 颜色
默认情况下，命令提示符是显示终端预定义的颜色。Bash 允许自定义提示符颜色。

使用下面的代码，可以设定其后文本的颜色。

| 代码 | 颜色 |
|----|----|
| \033[0;30m   | 黑色   |
| \033[1;30m   | 深灰色   |
| \033[0;31m   | 红色   |
| \033[1;31m   | 浅红色   |
| \033[0;32m   | 绿色   |
| \033[1;32m   | 浅绿色   |
| \033[0;33m   | 棕色   |
| \033[1;33m   | 黄色   |
| \033[0;34m   | 蓝色   |
| \033[1;34m   | 浅蓝色   |
| \033[0;35m   | 粉红   |
| \033[1;35m   | 浅粉色   |
| \033[0;36m   | 青色   |
| \033[1;36m   | 浅青色   |
| \033[0;37m   | 浅灰色   |
| \033[1;37m   | 白色   |

举例来说，如果要将提示符设为红色，可以将·设成下面的代码。
```shell
PS1='\[\033[0;31m\]<\u@\h \W>\$'
```
但是，上面这样设置以后，用户在提示符后面输入的文本也是红色的。为了解决这个问题， 可以在结尾添加另一个特殊代码`\[\033[00m\]`，表示将其后的文本恢复到默认颜色。
```shell
PS1='\[\033[0;31m\]<\u@\h \W>\$\[\033[00m\]'
```
除了设置前景颜色，Bash 还允许设置背景颜色。

| 代码         | 颜色  |
|------------|-----|
| \033[0;40m | 蓝色  |
| \033[1;44m | 黑色  |
| \033[0;41m | 红色  |
| \033[1;45m | 粉红  |
| \033[0;42m | 绿色  |
| \033[1;46m | 青色  |
| \033[0;43m | 棕色  |
| \033[1;47m | 浅灰色 |

下面是一个带有红色背景的提示符。
```shell
PS1='\[\033[0;41m\]<\u@\h \W>\$\[\033[0m\] '
```
### 环境变量 PS2，PS3，PS4
除了`PS1`，Bash 还提供了提示符相关的另外三个环境变量。

环境变量`PS2`是命令行折行输入时系统的提示符，默认为`>`。
```shell
$ echo "hello
> world"
```
上面命令中，输入`hello`以后按下回车键，系统会提示继续输入。这时，第二行显示的提示符就是`PS2`定义的`>`。

环境变量`PS3`是使用`select`命令时，系统输入菜单的提示符。

环境变量`PS4`默认为`+`。它是使用 Bash 的`-x`参数执行脚本时，每一行命令在执行前都会先打印出来，并且在行首出现的那个提示符。

比如下面是脚本`test.sh`。
```shell
#!/bin/bash

echo "hello world"
```

使用`-x`参数执行这个脚本。
```shell
$ bash -x test.sh
+ echo 'hello world'
	hello world
```
上面例子中，输出的第一行前面有一个`+`，这就是变量`PS4`定义的。
## Linux命令的执行过程
Linux 命令的执行过程分为如下 4 个步骤：
### 1. 判断路径
判断用户是否以绝对路径或相对路径的方式输入命令（如`/bin/ls`），如果是的话直接执行。
### 2. 检查别名
Linux 系统会检查用户输入的命令是否为“别名命令”。要知道，通过`alias`命令是可以给现有命令自定义别名的，即用一个自定义的命令名称来替换原本的命令名称。

例如，我们经常使用的`rm`命令，其实就是`rm -i`这个整体的别名：
```bash
[root@localhost ~]# alias rm
alias rm='rm -i'
```
这使得当使用`rm`命令删除指定文件时，Linux 系统会要求我们再次确认是否执行删除操作。
```bash
[root@localhost ~]# rm a.txt <-- 假定当前目录中已经存在 a.txt 文件
rm: remove regular file 'a.txt'? y <-- 手动输入 y，即确定删除
[root@localhost ~]#
```
这里可以使用`unalias`命令，将 Linux 系统设置的`rm`别名删除掉：
```bash
[root@localhost ~]# alias rm
alias rm='rm -i'
[root@localhost ~]# unalias rm
[root@localhost ~]# rm a.txt
[root@localhost ~]# <--直接删除，不再询问
```
### 3. 判断是内部命令还是外部命令
shell 会判断用户输入的命令是内部命令还是外部命令。内部命令会被直接执行；而外部命令交给步骤四继续处理。

内部命令由 Shell 自带，会随着系统启动，可以直接从内存中读取；而外部命令仅是在系统中有对应的可执行文件，执行时需要读取该文件。

判断一个命令属于内部命令还是外部命令，可以使用`type`命令实现。
```bash
[root@localhost ~]# type pwd
pwd is a shell builtin <-- pwd是内部命令
[root@localhost ~]# type top
top is /usr/bin/top <-- top是外部命令
[root@localhost ~]# type type
type is a shell builtin <-- type本身也是内置命令
```
如果要查看一个命令的所有定义，可以使用`type -a`。
```shell
[root@localhost ~]# type -a echo
echo is shell builtin
echo is /usr/bin/echo
```
上面代码表示，`echo`命令既是内置命令，也有对应的外部程序。

`type -t`可以返回一个命令的类型：别名（`alias`），关键词（`keyword`），函数（`function`），内置命令（`builtin`）和文件（`file`）。
```shell
[root@localhost ~]# type -t bash
file
[root@localhost ~]# type -t if
keyword
```
上面例子中，`bash`是文件，`if`是关键词。
### 4. 查找外部命令对应的可执行文件
当用户执行的是外部命令时，系统会在指定的多个路径中查找该命令的可执行文件，而定义这些路径的变量，就称为`PATH`环境变量，其作用就是告诉 Shell 待执行命令的可执行文件可能存放的位置，也就是说，Shell 会在`PATH`变量包含的多个路径中逐个查找，直到找到为止（如果找不到，Shell 会提供用户“找不到此命令”）。

## 行操作
Bash 内置了 Readline 库，具有这个库提供的很多“行操作”功能，比如命令的自动补全，可以大大加快操作速度。

这个库默认采用 Emacs 快捷键，也可以改成 Vi 快捷键。
```bash
$ set -o vi
```
下面的命令可以改回 Emacs 快捷键。
```bash
$ set -o emacs
```
如果想永久性更改编辑模式（Emacs/Vi），可以将命令写在`~/.inputrc`文件，这个文件是 Readline 的配置文件。
```bash
set editing-mode vi
```
Bash 默认开启这个库，但是允许关闭。
```bash
$ bash --noediting
```
上面命令中，`--noediting`参数关闭了 Readline 库，启动的 Bash 就不带有行操作功能。
### 常用快捷键
Readline 提供的快捷键：

| 快捷键                | 说明                                |
|--------------------|-----------------------------------|
| `Ctrl + a`         | 移到行首                              |
| `Ctrl + b`         | 向行首移动一个字符，与左箭头作用相同                |
| `Ctrl + e`         | 移到行尾                              |
| `Ctrl + f`         | 向行尾移动一个字符，与右箭头作用相同                |
| `Alt + f`          | 移动到当前单词的词尾                        |
| `Alt + b`          | 移动到当前单词的词首                        |
| `Ctrl + l`         | 清除屏幕，即将当前行移到屏幕的第一行，与`clear`命令作用相同 |
| `Ctrl + d`         | 删除光标位置的字符（`delete`）               |
| `Ctrl + w`         | 删除光标前一个单词                         |
| `Ctrl + t`         | 光标位置的字符与它前面一位的字符交换位置（`transpose`） |
| `Alt + t`          | 光标位置的词与它前面一位的词交换位置（`transpose`）   |
| `Alt + l`          | 将光标位置至词尾转为小写（`lowercase`）         |
| `Alt + u`          | 将光标位置至词尾转为大写（`uppercase`）         |
| `Ctrl + k`         | 剪切光标位置到行尾的文本                      |
| `Ctrl + u`         | 剪切光标位置到行首的文本                      |
| `Alt + d`          | 剪切光标位置到词尾的文本                      |
| `Alt + Backspace`  | 剪切光标位置到词首的文本                      |
| `Ctrl + y`         | 在光标位置粘贴文本                         |
| `Ctrl + c`         | 终止当前正在执行的命令                       |
| `Shift + PageUp`   | 向上滚动                              |
| `Shift + PageDown` | 向下滚动                              |


使用`Ctrl + d`的时候，如果当前行没有任何字符，会导致退出当前 Shell，所以要小心。

`Alt`键可以用`Esc`键代替。
### 自动补全
命令输入到一半的时候，可以按一下`Tab`键，Readline 会自动补全命令或路径。比如，输入`cle`，再按下`Tab`键，Bash 会自动将这个命令补全为`clear`。

如果符合条件的命令或路径有多个，就需要连续按两次`Tab`键，Bash 会提示所有符合条件的命令或路径。

除了命令或路径，`Tab`还可以补全其他值。如果一个值以`$`开头，则按下`Tab`键会补全变量；如果以`~`开头，则补全用户名；如果以`@`开头，则补全主机名（`hostname`），主机名以列在`/etc/hosts`文件里面的主机为准。

自动补全相关的快捷键。

| 快捷键           | 说明                                         |
|---------------|--------------------------------------------|
| `Tab`         | 完成自动补全。                                    |
| `Alt + ?`     | 列出可能的补全，与连按两次 Tab 键作用相同。                   |
| `Alt + /`     | 尝试文件路径补全。                                  |
| `Ctrl + x /`  | 先按`Ctrl + x`，再按/，等同于`Alt + ?`，列出可能的文件路径补全。 |
| `Alt + !`     | 命令补全。                                      |
| `Ctrl + x !`  | 先按`Ctrl + x`，再按!，等同于`Alt + !`，命令补全。        |
| `Alt + ~`     | 用户名补全。                                     |
| `Ctrl + x ~`  | 先按`Ctrl + x`，再按~，等同于`Alt + ~`，用户名补全。       |
| `Alt + $`     | 变量名补全。                                     |
| `Ctrl + x $`  | 先按`Ctrl + x`，再按$，等同于`Alt + $`，变量名补全。       |
| `Alt + @`     | 主机名补全。                                     |
| `Ctrl + x @`  | 先按`Ctrl + x`，再按@，等同于`Alt + @`，主机名补全。       |
| `Alt + *`     | 在命令行一次性插入所有可能的补全。                          |
| `Alt + Tab`   | 尝试用`.bash_history`里面以前执行命令，进行补全。           |

上面的`Alt`键也可以用`ESC`键代替。
