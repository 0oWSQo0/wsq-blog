import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as l,d as o,o as n}from"./app-CRBxQhNH.js";const e={};function p(c,s){return n(),l("div",null,s[0]||(s[0]=[o(`<h2 id="字符串的长度" tabindex="-1"><a class="header-anchor" href="#字符串的长度"><span>字符串的长度</span></a></h2><p>获取字符串长度的语法如下。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">\${</span><span style="color:#FF9492;">#</span><span style="color:#F0F3F6;">varname}</span></span></code></pre></div><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# myPath</span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;">/home/cam/book/long.file.name</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# echo \${</span><span style="color:#FF9492;">#</span><span style="color:#F0F3F6;">myPath}</span></span>
<span class="line"><span style="color:#FFB757;">29</span></span></code></pre></div><p>大括号<code>{}</code>是必需的，否则 Bash 会将<code>$#</code>理解成脚本的参数个数，将变量名理解成文本。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# echo $#myvar</span></span>
<span class="line"><span style="color:#FFB757;">0myvar</span></span></code></pre></div><p>上面例子中，Bash 将<code>$#</code>和<code>myvar</code>分开解释了。</p><h2 id="子字符串" tabindex="-1"><a class="header-anchor" href="#子字符串"><span>子字符串</span></a></h2><p>字符串提取子串的语法如下。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">\${varname</span><span style="color:#FF9492;">:</span><span style="color:#F0F3F6;">offset</span><span style="color:#FF9492;">:</span><span style="color:#F0F3F6;">length}</span></span></code></pre></div><p>上面语法的含义是返回变量<code>$varname</code>的子字符串，从位置<code>offset</code>开始（从 0 开始计算），长度为<code>length</code>。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# count</span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;">frogfootman</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# echo \${count</span><span style="color:#FF9492;">:</span><span style="color:#F0F3F6;">4</span><span style="color:#FF9492;">:</span><span style="color:#F0F3F6;">4}</span></span>
<span class="line"><span style="color:#FFB757;">foot</span></span></code></pre></div><p>上面例子返回字符串<code>frogfootman</code>从 4 号位置开始的长度为 4 的子字符串<code>foot</code>。</p><p>这种语法不能直接操作字符串，只能通过变量来读取字符串，并且不会改变原始字符串。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;"># 报错</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# echo \${</span><span style="color:#ADDCFF;">&quot;hello&quot;</span><span style="color:#FF9492;">:</span><span style="color:#F0F3F6;">2</span><span style="color:#FF9492;">:</span><span style="color:#F0F3F6;">3}</span></span></code></pre></div><p>上面例子中，<code>&quot;hello&quot;</code>不是变量名，导致 Bash 报错。</p><p>如果省略<code>length</code>，则从位置<code>offset</code>开始，一直返回到字符串的结尾。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# count</span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;">frogfootman</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# echo \${count</span><span style="color:#FF9492;">:</span><span style="color:#F0F3F6;">4}</span></span>
<span class="line"><span style="color:#FFB757;">footman</span></span></code></pre></div><p>如果<code>offset</code>为负值，表示从字符串的末尾开始算起。注意，负数前面必须有一个空格， 以防止与<code>\${variable:-word}</code>的变量的设置默认值语法混淆。这时还可以指定<code>length</code>，<code>length</code>可以是正值，也可以是负值（负值不能超过<code>offset</code>的长度）。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# foo</span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;">&quot;This string is long.&quot;</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# echo \${foo</span><span style="color:#FF9492;">:</span><span style="color:#F0F3F6;"> -5}</span></span>
<span class="line"><span style="color:#FFB757;">long.</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# echo \${foo</span><span style="color:#FF9492;">:</span><span style="color:#F0F3F6;"> -5</span><span style="color:#FF9492;">:</span><span style="color:#F0F3F6;">2}</span></span>
<span class="line"><span style="color:#FFB757;">lo</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# echo \${foo</span><span style="color:#FF9492;">:</span><span style="color:#F0F3F6;"> -5</span><span style="color:#FF9492;">:-</span><span style="color:#F0F3F6;">2}</span></span>
<span class="line"><span style="color:#FFB757;">lon</span></span></code></pre></div><p>上面例子中，<code>offset</code>为 -5，表示从倒数第 5 个字符开始截取，所以返回<code>long.</code>。如果指定长度<code>length</code>为 2，则返回<code>lo</code>；如果<code>length</code>为 -2，表示要排除从字符串末尾开始的 2 个字符，所以返回<code>lon</code>。</p><h2 id="搜索和替换" tabindex="-1"><a class="header-anchor" href="#搜索和替换"><span>搜索和替换</span></a></h2><p>Bash 提供字符串搜索和替换的多种方法。</p><h3 id="字符串头部的模式匹配" tabindex="-1"><a class="header-anchor" href="#字符串头部的模式匹配"><span>字符串头部的模式匹配</span></a></h3><p>以下两种语法可以检查字符串开头，是否匹配给定的模式。如果匹配成功，就删除匹配的部分，返回剩下的部分。原始变量不会发生变化。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;"># 如果 pattern 匹配变量 variable 的开头，</span></span>
<span class="line"><span style="color:#BDC4CC;"># 删除最短匹配（非贪婪匹配）的部分，返回剩余部分</span></span>
<span class="line"><span style="color:#F0F3F6;">\${variable</span><span style="color:#FF9492;">#</span><span style="color:#F0F3F6;">pattern}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;"># 如果 pattern 匹配变量 variable 的开头，</span></span>
<span class="line"><span style="color:#BDC4CC;"># 删除最长匹配（贪婪匹配）的部分，返回剩余部分</span></span>
<span class="line"><span style="color:#F0F3F6;">\${variable</span><span style="color:#FF9492;">##</span><span style="color:#F0F3F6;">pattern}</span></span></code></pre></div><p>上面两种语法会删除变量字符串开头的匹配部分（将其替换为空），返回剩下的部分。区别是一个是最短匹配（又称非贪婪匹配），另一个是最长匹配（又称贪婪匹配）。</p><p>匹配模式<code>pattern</code>可以使用<code>*、?、[]</code>等通配符。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# myPath</span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;">/home/cam/book/long.file.name</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# echo \${myPath</span><span style="color:#FF9492;">#/*/</span><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#FFB757;">cam/book/long.file.name</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# echo \${myPath</span><span style="color:#FF9492;">##/*/</span><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#FFB757;">long.file.name</span></span></code></pre></div><p>上面例子中，匹配的模式是<code>/*/</code>，其中<code>*</code>可以匹配任意数量的字符，所以最短匹配是<code>/home/</code>，最长匹配是<code>/home/cam/book/</code>。</p><p>下面写法可以删除文件路径的目录部分，只留下文件名。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# path</span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;">/home/cam/book/long.file.name</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# echo \${path</span><span style="color:#FF9492;">##*/</span><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#FFB757;">long.file.name</span></span></code></pre></div><p>上面例子中，模式<code>*/</code>匹配目录部分，所以只返回文件名。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# phone</span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;">&quot;555-456-1414&quot;</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# echo \${phone</span><span style="color:#FF9492;">#*</span><span style="color:#F0F3F6;">-}</span></span>
<span class="line"><span style="color:#FFB757;">456-1414</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# echo \${phone</span><span style="color:#FF9492;">##*</span><span style="color:#F0F3F6;">-}</span></span>
<span class="line"><span style="color:#FFB757;">1414</span></span></code></pre></div><p>如果匹配不成功，则返回原始字符串。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# phone</span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;">&quot;555-456-1414&quot;</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# echo \${phone</span><span style="color:#FF9492;">#</span><span style="color:#F0F3F6;">444}</span></span>
<span class="line"><span style="color:#FFB757;">555-456-1414</span></span></code></pre></div><p>上面例子中，原始字符串里面无法匹配模式 444，所以原样返回。</p><p>如果要将头部匹配的部分，替换成其他内容，采用下面的写法。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;"># 模式必须出现在字符串的开头</span></span>
<span class="line"><span style="color:#F0F3F6;">\${variable</span><span style="color:#FF9492;">/#</span><span style="color:#F0F3F6;">pattern</span><span style="color:#FF9492;">/</span><span style="color:#F0F3F6;">string}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;"># 示例</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# foo</span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;">JPG.JPG</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# echo \${foo</span><span style="color:#FF9492;">/#</span><span style="color:#F0F3F6;">JPG</span><span style="color:#FF9492;">/</span><span style="color:#F0F3F6;">jpg}</span></span>
<span class="line"><span style="color:#FFB757;">jpg.JPG</span></span></code></pre></div><p>上面例子中，被替换的<code>JPG</code>必须出现在字符串头部，所以返回<code>jpg.JPG</code>。</p><h3 id="字符串尾部的模式匹配" tabindex="-1"><a class="header-anchor" href="#字符串尾部的模式匹配"><span>字符串尾部的模式匹配</span></a></h3><p>以下两种语法可以检查字符串结尾，是否匹配给定的模式。如果匹配成功，就删除匹配的部分，返回剩下的部分。原始变量不会发生变化。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;"># 如果 pattern 匹配变量 variable 的结尾，</span></span>
<span class="line"><span style="color:#BDC4CC;"># 删除最短匹配（非贪婪匹配）的部分，返回剩余部分</span></span>
<span class="line"><span style="color:#F0F3F6;">\${variable</span><span style="color:#FF9492;">%</span><span style="color:#F0F3F6;">pattern}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;"># 如果 pattern 匹配变量 variable 的结尾，</span></span>
<span class="line"><span style="color:#BDC4CC;"># 删除最长匹配（贪婪匹配）的部分，返回剩余部分</span></span>
<span class="line"><span style="color:#F0F3F6;">\${variable</span><span style="color:#FF9492;">%%</span><span style="color:#F0F3F6;">pattern}</span></span></code></pre></div><p>上面两种语法会删除变量字符串结尾的匹配部分（将其替换为空），返回剩下的部分。区别是一个是最短匹配（又称非贪婪匹配），另一个是最长匹配（又称贪婪匹配）。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# path</span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;">/home/cam/book/long.file.name</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# echo \${path</span><span style="color:#FF9492;">%</span><span style="color:#F0F3F6;">.</span><span style="color:#FF9492;">*</span><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#FFB757;">/home/cam/book/long.file</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# echo \${path</span><span style="color:#FF9492;">%%</span><span style="color:#F0F3F6;">.</span><span style="color:#FF9492;">*</span><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#FFB757;">/home/cam/book/long</span></span></code></pre></div><p>上面例子中，匹配模式是<code>.*</code>，其中<code>*</code>可以匹配任意数量的字符，所以最短匹配是<code>.name</code>，最长匹配是<code>.file.name</code>。</p><p>下面写法可以删除路径的文件名部分，只留下目录部分。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# path</span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;">/home/cam/book/long.file.name</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# echo \${path</span><span style="color:#FF9492;">%/*</span><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#FFB757;">/home/cam/book</span></span></code></pre></div><p>上面例子中，模式<code>/*</code>匹配文件名部分，所以只返回目录部分。</p><p>下面的写法可以替换文件的后缀名。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# file</span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;">foo.png</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# echo \${file</span><span style="color:#FF9492;">%</span><span style="color:#F0F3F6;">.png}.jpg</span></span>
<span class="line"><span style="color:#FFB757;">foo.jpg</span></span></code></pre></div><p>上面的例子将文件的后缀名，从<code>.png</code>改成了<code>.jpg</code>。</p><p>下面再看一个例子。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# phone</span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;">&quot;555-456-1414&quot;</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# echo \${phone</span><span style="color:#FF9492;">%</span><span style="color:#F0F3F6;">-</span><span style="color:#FF9492;">*</span><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#FFB757;">555-456</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# echo \${phone</span><span style="color:#FF9492;">%%</span><span style="color:#F0F3F6;">-</span><span style="color:#FF9492;">*</span><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#FFB757;">555</span></span></code></pre></div><p>如果匹配不成功，则返回原始字符串。</p><p>如果要将尾部匹配的部分，替换成其他内容，采用下面的写法。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;"># 模式必须出现在字符串的结尾</span></span>
<span class="line"><span style="color:#F0F3F6;">\${variable</span><span style="color:#FF9492;">/%</span><span style="color:#F0F3F6;">pattern</span><span style="color:#FF9492;">/</span><span style="color:#F0F3F6;">string}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;"># 示例</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# foo</span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;">JPG.JPG</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# echo \${foo</span><span style="color:#FF9492;">/%</span><span style="color:#F0F3F6;">JPG</span><span style="color:#FF9492;">/</span><span style="color:#F0F3F6;">jpg}</span></span>
<span class="line"><span style="color:#FFB757;">JPG.jpg</span></span></code></pre></div><p>上面例子中，被替换的<code>JPG</code>必须出现在字符串尾部，所以返回<code>JPG.jpg</code>。</p><h3 id="任意位置的模式匹配" tabindex="-1"><a class="header-anchor" href="#任意位置的模式匹配"><span>任意位置的模式匹配</span></a></h3><p>以下两种语法可以检查字符串内部，是否匹配给定的模式。如果匹配成功，就删除匹配的部分，换成其他的字符串返回。原始变量不会发生变化。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;"># 如果 pattern 匹配变量 variable 的一部分，</span></span>
<span class="line"><span style="color:#BDC4CC;"># 最长匹配（贪婪匹配）的那部分被 string 替换，但仅替换第一个匹配</span></span>
<span class="line"><span style="color:#F0F3F6;">\${variable</span><span style="color:#FF9492;">/</span><span style="color:#F0F3F6;">pattern</span><span style="color:#FF9492;">/</span><span style="color:#F0F3F6;">string}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;"># 如果 pattern 匹配变量 variable 的一部分，</span></span>
<span class="line"><span style="color:#BDC4CC;"># 最长匹配（贪婪匹配）的那部分被 string 替换，所有匹配都替换</span></span>
<span class="line"><span style="color:#F0F3F6;">\${variable</span><span style="color:#FF9492;">//</span><span style="color:#F0F3F6;">pattern</span><span style="color:#FF9492;">/</span><span style="color:#F0F3F6;">string}</span></span></code></pre></div><p>上面两种语法都是最长匹配（贪婪匹配）下的替换，区别是前一个语法仅仅替换第一个匹配，后一个语法替换所有匹配。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# path</span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;">/home/cam/foo/foo.name</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# echo \${path</span><span style="color:#FF9492;">/</span><span style="color:#F0F3F6;">foo</span><span style="color:#FF9492;">/</span><span style="color:#F0F3F6;">bar}</span></span>
<span class="line"><span style="color:#FFB757;">/home/cam/bar/foo.name</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# echo \${path</span><span style="color:#FF9492;">//</span><span style="color:#F0F3F6;">foo</span><span style="color:#FF9492;">/</span><span style="color:#F0F3F6;">bar}</span></span>
<span class="line"><span style="color:#FFB757;">/home/cam/bar/bar.name</span></span></code></pre></div><p>上面例子中，前一个命令只替换了第一个<code>foo</code>，后一个命令将两个<code>foo</code>都替换了。</p><p>下面的例子将分隔符从<code>:</code>换成换行符。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# echo -e \${PATH</span><span style="color:#FF9492;">//:/</span><span style="color:#ADDCFF;">&#39;\\n&#39;</span><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#FFB757;">/usr/local/bin</span></span>
<span class="line"><span style="color:#FFB757;">/usr/bin</span></span>
<span class="line"><span style="color:#FFB757;">/bin</span></span>
<span class="line"><span style="color:#91CBFF;">...</span></span></code></pre></div><p>上面例子中，<code>echo</code>命令的<code>-e</code>参数，表示将替换后的字符串的<code>\\n</code>字符，解释为换行符。</p><p>模式部分可以使用通配符。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# phone</span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;">&quot;555-456-1414&quot;</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# echo \${phone</span><span style="color:#FF9492;">/</span><span style="color:#F0F3F6;">5?4</span><span style="color:#FF9492;">/</span><span style="color:#F0F3F6;">-}</span></span>
<span class="line"><span style="color:#FFB757;">55-56-1414</span></span></code></pre></div><p>上面的例子将<code>5-4</code>替换成<code>-</code>。</p><p>如果省略了<code>string</code>部分，那么就相当于匹配的部分替换成空字符串，即删除匹配的部分。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# path</span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;">/home/cam/foo/foo.name</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# echo \${path</span><span style="color:#FF9492;">/</span><span style="color:#F0F3F6;">.</span><span style="color:#FF9492;">*/</span><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#FFB757;">/home/cam/foo/foo</span></span></code></pre></div><p>上面例子中，第二个斜杠后面的<code>string</code>部分省略了，所以模式<code>.*</code>匹配的部分<code>.name</code>被删除后返回。</p><p>前面提到过，这个语法还有两种扩展形式。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;"># 模式必须出现在字符串的开头</span></span>
<span class="line"><span style="color:#F0F3F6;">\${variable</span><span style="color:#FF9492;">/#</span><span style="color:#F0F3F6;">pattern</span><span style="color:#FF9492;">/</span><span style="color:#F0F3F6;">string}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;"># 模式必须出现在字符串的结尾</span></span>
<span class="line"><span style="color:#F0F3F6;">\${variable</span><span style="color:#FF9492;">/%</span><span style="color:#F0F3F6;">pattern</span><span style="color:#FF9492;">/</span><span style="color:#F0F3F6;">string}</span></span></code></pre></div><h2 id="改变大小写" tabindex="-1"><a class="header-anchor" href="#改变大小写"><span>改变大小写</span></a></h2><p>下面的语法可以改变变量的大小写。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;"># 转为大写</span></span>
<span class="line"><span style="color:#F0F3F6;">\${varname^^}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;"># 转为小写</span></span>
<span class="line"><span style="color:#F0F3F6;">\${varname,,}</span></span></code></pre></div><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# foo</span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;">heLLo</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# echo \${foo^^}</span></span>
<span class="line"><span style="color:#FFB757;">HELLO</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# echo \${foo,,}</span></span>
<span class="line"><span style="color:#FFB757;">hello</span></span></code></pre></div>`,79)]))}const r=a(e,[["render",p],["__file","Bash脚本—字符串操作.html.vue"]]),i=JSON.parse('{"path":"/linux/linux%E5%9F%BA%E7%A1%80/Bash%E8%84%9A%E6%9C%AC%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C.html","title":"Bash脚本——字符串操作","lang":"zh-CN","frontmatter":{"title":"Bash脚本——字符串操作","date":"2024-05-15T00:00:00.000Z","tags":"Bash","categories":"Linux","order":21,"description":"字符串的长度 获取字符串长度的语法如下。 大括号{}是必需的，否则 Bash 会将$#理解成脚本的参数个数，将变量名理解成文本。 上面例子中，Bash 将$#和myvar分开解释了。 子字符串 字符串提取子串的语法如下。 上面语法的含义是返回变量$varname的子字符串，从位置offset开始（从 0 开始计算），长度为length。 上面例子返回字...","head":[["meta",{"property":"og:url","content":"https://0oWSQo0.github.io/wsq-blog/linux/linux%E5%9F%BA%E7%A1%80/Bash%E8%84%9A%E6%9C%AC%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C.html"}],["meta",{"property":"og:title","content":"Bash脚本——字符串操作"}],["meta",{"property":"og:description","content":"字符串的长度 获取字符串长度的语法如下。 大括号{}是必需的，否则 Bash 会将$#理解成脚本的参数个数，将变量名理解成文本。 上面例子中，Bash 将$#和myvar分开解释了。 子字符串 字符串提取子串的语法如下。 上面语法的含义是返回变量$varname的子字符串，从位置offset开始（从 0 开始计算），长度为length。 上面例子返回字..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-04-23T09:49:11.000Z"}],["meta",{"property":"article:published_time","content":"2024-05-15T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-04-23T09:49:11.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Bash脚本——字符串操作\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-05-15T00:00:00.000Z\\",\\"dateModified\\":\\"2025-04-23T09:49:11.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"WSQ\\",\\"url\\":\\"https://0oWSQo0.github.com\\"}]}"]]},"headers":[{"level":2,"title":"字符串的长度","slug":"字符串的长度","link":"#字符串的长度","children":[]},{"level":2,"title":"子字符串","slug":"子字符串","link":"#子字符串","children":[]},{"level":2,"title":"搜索和替换","slug":"搜索和替换","link":"#搜索和替换","children":[{"level":3,"title":"字符串头部的模式匹配","slug":"字符串头部的模式匹配","link":"#字符串头部的模式匹配","children":[]},{"level":3,"title":"字符串尾部的模式匹配","slug":"字符串尾部的模式匹配","link":"#字符串尾部的模式匹配","children":[]},{"level":3,"title":"任意位置的模式匹配","slug":"任意位置的模式匹配","link":"#任意位置的模式匹配","children":[]}]},{"level":2,"title":"改变大小写","slug":"改变大小写","link":"#改变大小写","children":[]}],"git":{"createdTime":1726034220000,"updatedTime":1745401751000,"contributors":[{"name":"WSQ","email":"592786982@qq.com","commits":2}]},"readingTime":{"minutes":6.32,"words":1895},"filePathRelative":"linux/linux基础/Bash脚本—字符串操作.md","localizedDate":"2024年5月15日","autoDesc":true}');export{r as comp,i as data};
