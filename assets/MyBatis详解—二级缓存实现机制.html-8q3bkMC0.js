import{_ as c}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as o,d as a,o as t}from"./app-BAoNGAQX.js";const d="/wsq-blog/assets/mybatis-y-cache-7-DZTF9zNA.png",s="/wsq-blog/assets/mybatis-y-cache-8-BQ4Jcvf4.png",i="/wsq-blog/assets/mybatis-y-cache-9-Cy8IrV8J.png",p="/wsq-blog/assets/mybatis-y-cache-10-zHW6FCFx.png",l="/wsq-blog/assets/mybatis-y-cache-11-DRxG3d_R.png",n="/wsq-blog/assets/mybatis-y-cache-12-iOWaCJ7k.png",r="/wsq-blog/assets/mybatis-y-cache-21-C9ga2QFx.png",h={};function y(g,e){return t(),o("div",null,e[0]||(e[0]=[a('<h2 id="mybatis二级缓存实现" tabindex="-1"><a class="header-anchor" href="#mybatis二级缓存实现"><span>MyBatis二级缓存实现</span></a></h2><p>MyBatis 的二级缓存是<code>Application</code>级别的缓存，它可以提高对数据库查询的效率，以提高应用的性能。</p><h3 id="mybatis的缓存机制整体设计以及二级缓存的工作模式" tabindex="-1"><a class="header-anchor" href="#mybatis的缓存机制整体设计以及二级缓存的工作模式"><span>MyBatis的缓存机制整体设计以及二级缓存的工作模式</span></a></h3><figure><img src="'+d+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>如图所示，当开一个会话时，一个<code>SqlSession</code>对象会使用一个<code>Executor</code>对象来完成会话操作，MyBatis 的二级缓存机制的关键就是对这个<code>Executor</code>对象做文章。如果用户配置了<code>cacheEnabled=true</code>，那么 MyBatis 在为<code>SqlSession</code>对象创建<code>Executor</code>对象时，会对<code>Executor</code>对象加上一个装饰者：<code>CachingExecutor</code>，这时<code>SqlSession</code>使用<code>CachingExecutor</code>对象来完成操作请求。<code>CachingExecutor</code>对于查询请求，会先判断该查询请求在<code>Application</code>级别的二级缓存中是否有缓存结果，如果有查询结果，则直接返回缓存结果；如果缓存中没有，再交给真正的<code>Executor</code>对象来完成查询操作，之后<code>CachingExecutor</code>会将真正<code>Executor</code>返回的查询结果放置到缓存中，然后在返回给用户。</p><figure><img src="'+s+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><code>CachingExecutor</code>是<code>Executor</code>的装饰者，以增强<code>Executor</code>的功能，使其具有缓存查询的功能，这里用到了设计模式中的装饰者模式，<code>CachingExecutor</code>和<code>Executor</code>的接口的关系如下类图所示：</p><figure><img src="'+i+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="mybatis二级缓存的划分" tabindex="-1"><a class="header-anchor" href="#mybatis二级缓存的划分"><span>MyBatis二级缓存的划分</span></a></h3><p>MyBatis 并不是简单地对整个<code>Application</code>就只有一个<code>Cache</code>缓存对象，它将缓存划分的更细，即是<code>Mapper</code>级别的，即每一个<code>Mapper</code>都可以拥有一个<code>Cache</code>对象，具体如下：</p><p><strong>为每一个<code>Mapper</code>分配一个<code>Cache</code>缓存对象（使用<code>&lt;cache&gt;</code>节点配置）</strong></p><p>MyBatis 将<code>Application</code>级别的二级缓存细分到<code>Mapper</code>级别，即对于每一个<code>Mapper.xml</code>，如果在其中使用了<code>&lt;cache&gt;</code>节点，则 MyBatis 会为这个<code>Mapper</code>创建一个<code>Cache</code>缓存对象，如下图所示：</p><figure><img src="'+p+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>注：上述的每一个<code>Cache</code>对象，都会有一个自己所属的<code>namespace</code>命名空间，并且会将<code>Mapper</code>的<code>namespace</code>作为它们的<code>ID</code>；</p><p><strong>多个<code>Mapper</code>共用一个<code>Cache</code>缓存对象（使用<code>&lt;cache-ref&gt;</code>节点配置）</strong></p><p>如果你想让多个<code>Mapper</code>公用一个<code>Cache</code>的话，你可以使用<code>&lt;cache-ref namespace=&quot;&quot;&gt;</code>节点，来指定你的这个<code>Mapper</code>使用到了哪一个<code>Mapper</code>的<code>Cache</code>缓存。</p><figure><img src="'+l+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="使用二级缓存-必须要具备的条件" tabindex="-1"><a class="header-anchor" href="#使用二级缓存-必须要具备的条件"><span>使用二级缓存，必须要具备的条件</span></a></h3><p>MyBatis 对二级缓存的支持粒度很细，它会指定某一条查询语句是否使用二级缓存。</p><p>虽然在<code>Mapper</code>中配置了<code>&lt;cache&gt;</code>,并且为此<code>Mapper</code>分配了<code>Cache</code>对象，这并不表示我们使用<code>Mapper</code>中定义的查询语句查到的结果都会放置到<code>Cache</code>对象之中，我们必须指定<code>Mapper</code>中的某条选择语句是否支持缓存，即如下所示，在<code>&lt;select&gt;</code>节点中配置<code>useCache=&quot;true&quot;</code>，<code>Mapper</code>才会对此<code>Select</code>的查询支持缓存特性，否则，不会对此<code>Select</code>查询，不会经过<code>Cache</code>缓存。如下所示，<code>Select</code>语句配置了<code>useCache=&quot;true&quot;</code>，则表明这条<code>Select</code>语句的查询会使用二级缓存。</p><div class="language-xml" data-highlighter="shiki" data-ext="xml" data-title="xml" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">&lt;</span><span style="color:#72F088;">select</span><span style="color:#91CBFF;"> id</span><span style="color:#F0F3F6;">=</span><span style="color:#ADDCFF;">&quot;selectByMinSalary&quot;</span><span style="color:#91CBFF;"> resultMap</span><span style="color:#F0F3F6;">=</span><span style="color:#ADDCFF;">&quot;BaseResultMap&quot;</span><span style="color:#91CBFF;"> parameterType</span><span style="color:#F0F3F6;">=</span><span style="color:#ADDCFF;">&quot;java.util.Map&quot;</span><span style="color:#91CBFF;"> useCache</span><span style="color:#F0F3F6;">=</span><span style="color:#ADDCFF;">&quot;true&quot;</span><span style="color:#F0F3F6;">&gt;</span></span></code></pre></div><p>总之，要想使某条<code>Select</code>查询支持二级缓存，你需要保证：</p><ul><li>MyBatis 支持二级缓存的总开关：全局配置变量参数<code>cacheEnabled=true</code></li><li>该<code>select</code>语句所在的<code>Mapper</code>，配置了<code>&lt;cache&gt;</code>或<code>&lt;cached-ref&gt;</code>节点，并且有效</li><li>该<code>select</code>语句的参数<code>useCache=true</code></li></ul><h3 id="一级缓存和二级缓存的使用顺序" tabindex="-1"><a class="header-anchor" href="#一级缓存和二级缓存的使用顺序"><span>一级缓存和二级缓存的使用顺序</span></a></h3><p>请注意，如果你的 MyBatis 使用了二级缓存，并且你的<code>Mapper</code>和<code>select</code>语句也配置使用了二级缓存，那么在执行<code>select</code>查询的时候，MyBatis 会先从二级缓存中取输入，其次才是一级缓存，即 MyBatis 查询数据的顺序是：二级缓存 ———&gt; 一级缓存 ——&gt; 数据库。</p><h3 id="二级缓存实现的选择" tabindex="-1"><a class="header-anchor" href="#二级缓存实现的选择"><span>二级缓存实现的选择</span></a></h3><p>MyBatis 对二级缓存的设计非常灵活，它自己内部实现了一系列的<code>Cache</code>缓存实现类，并提供了各种缓存刷新策略如 LRU，FIFO 等等；另外，MyBatis 还允许用户自定义<code>Cache</code>接口实现，用户是需要实现<code>org.apache.ibatis.cache.Cache</code>接口，然后将<code>Cache</code>实现类配置在<code>&lt;cache type=&quot;&quot;&gt;</code>节点的<code>type</code>属性上即可；除此之外，MyBatis 还支持跟第三方内存缓存库如<code>Memecached</code>的集成，总之，使用 MyBatis 的二级缓存有三个选择：</p><ul><li>MyBatis 自身提供的缓存实现；</li><li>用户自定义的<code>Cache</code>接口实现；</li><li>跟第三方内存缓存库的集成；</li></ul><h3 id="mybatis自身提供的二级缓存的实现" tabindex="-1"><a class="header-anchor" href="#mybatis自身提供的二级缓存的实现"><span>MyBatis自身提供的二级缓存的实现</span></a></h3><p>MyBatis 自身提供了丰富的，并且功能强大的二级缓存的实现，它拥有一系列的<code>Cache</code>接口装饰者，可以满足各种对缓存操作和更新的策略。</p><p>MyBatis 定义了大量的<code>Cache</code>的装饰器来增强<code>Cache</code>缓存的功能，如下类图所示。</p><figure><img src="'+n+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>对于每个<code>Cache</code>而言，都有一个容量限制，MyBatis 各供了各种策略来对<code>Cache</code>缓存的容量进行控制，以及对<code>Cache</code>中的数据进行刷新和置换。MyBatis 主要提供了以下几个刷新和置换策略：</p><ul><li><code>LRU(Least Recently Used)</code>：最近最少使用算法，即如果缓存中容量已经满了，会将缓存中最近最少被使用的缓存记录清除掉，然后添加新的记录；</li><li><code>FIFO(First in first out)</code>：先进先出算法，如果缓存中的容量已经满了，那么会将最先进入缓存中的数据清除掉；</li><li><code>Scheduled</code>：指定时间间隔清空算法，该算法会以指定的某一个时间间隔将<code>Cache</code>缓存中的数据清空；</li></ul><h2 id="如何细粒度地控制你的mybatis二级缓存" tabindex="-1"><a class="header-anchor" href="#如何细粒度地控制你的mybatis二级缓存"><span>如何细粒度地控制你的MyBatis二级缓存</span></a></h2><h3 id="一个关于mybatis的二级缓存的实际问题" tabindex="-1"><a class="header-anchor" href="#一个关于mybatis的二级缓存的实际问题"><span>一个关于MyBatis的二级缓存的实际问题</span></a></h3><p>现有<code>AMapper.xml</code>中定义了对数据库表<code>ATable</code>的 CRUD 操作，<code>BMapper</code>定义了对数据库表<code>BTable</code>的 CRUD 操作；</p><p>假设 MyBatis 的二级缓存开启，并且<code>AMapper</code>中使用了二级缓存，<code>AMapper</code>对应的二级缓存为<code>ACache</code>；</p><p>除此之外，<code>AMapper</code>中还定义了一个跟<code>BTable</code>有关的查询语句，类似如下所述：</p><div class="language-xml" data-highlighter="shiki" data-ext="xml" data-title="xml" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">&lt;</span><span style="color:#72F088;">select</span><span style="color:#91CBFF;"> id</span><span style="color:#F0F3F6;">=</span><span style="color:#ADDCFF;">&quot;selectATableWithJoin&quot;</span><span style="color:#91CBFF;"> resultMap</span><span style="color:#F0F3F6;">=</span><span style="color:#ADDCFF;">&quot;BaseResultMap&quot;</span><span style="color:#91CBFF;"> useCache</span><span style="color:#F0F3F6;">=</span><span style="color:#ADDCFF;">&quot;true&quot;</span><span style="color:#F0F3F6;">&gt;  </span></span>
<span class="line"><span style="color:#F0F3F6;">  select * from ATable left join BTable on ....  </span></span>
<span class="line"><span style="color:#F0F3F6;">&lt;/</span><span style="color:#72F088;">select</span><span style="color:#F0F3F6;">&gt;</span></span></code></pre></div><p>执行以下操作：<br> 执行<code>AMapper</code>中的<code>&quot;selectATableWithJoin&quot;</code>操作，此时会将查询到的结果放置到<code>AMapper</code>对应的二级缓存<code>ACache</code>中；<br> 执行<code>BMapper</code>中对<code>BTable</code>的更新操作<code>(update、delete、insert)</code>后，<code>BTable</code>的数据更新；<br> 再执行 1 完全相同的查询，这时候会直接从<code>AMapper</code>二级缓存<code>ACache</code>中取值，将<code>ACache</code>中的值直接返回；</p><p>好，问题就出现在第 3 步上：</p><p>由于<code>AMapper</code>的<code>“selectATableWithJoin”</code>对应的 SQL 语句需要和<code>BTable</code>进行<code>join</code>查找，而在第 2 步<code>BTable</code>的数据已经更新了，但是第 3 步查询的值是第 1 步的缓存值，已经极有可能跟真实数据库结果不一样，即<code>ACache</code>中缓存数据过期了！</p><p>总结来看，就是：对于某些使用了<code>join</code>连接的查询，如果其关联的表数据发生了更新，<code>join</code>连接的查询由于先前缓存的原因，导致查询结果和真实数据不同步；</p><p>从 MyBatis 的角度来看，这个问题可以这样表述：对于某些表执行了更新<code>(update、delete、insert)</code>操作后，如何去清空跟这些表有关联的查询语句所造成的缓存</p><h3 id="当前mybatis二级缓存的工作机制" tabindex="-1"><a class="header-anchor" href="#当前mybatis二级缓存的工作机制"><span>当前MyBatis二级缓存的工作机制</span></a></h3><p>MyBatis 二级缓存的一个重要特点：即松散的<code>Cache</code>缓存管理和维护</p><figure><img src="`+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>一个<code>Mapper</code>中定义的增删改查操作只能影响到自己关联的<code>Cache</code>对象。如上图所示的<code>Mapper namespace1</code>中定义的若干 CRUD 语句，产生的缓存只会被放置到相应关联的<code>Cache1</code>中，即<code>Mapper namespace2,namespace3,namespace4</code>中的 CRUD 的语句不会影响到<code>Cache1</code>。</p><p>可以看出，<code>Mapper</code>之间的缓存关系比较松散，相互关联的程度比较弱。</p><p>现在再回到上面描述的问题，如果我们将<code>AMapper</code>和<code>BMapper</code>共用一个<code>Cache</code>对象，那么，当<code>BMapper</code>执行更新操作时，可以清空对应<code>Cache</code>中的所有的缓存数据，这样的话，数据不是也可以保持最新吗？</p><p>确实这个也是一种解决方案，不过，它会使缓存的使用效率变的很低！<code>AMapper</code>和<code>BMapper</code>的任意的更新操作都会将共用的<code>Cache</code>清空，会频繁地清空<code>Cache</code>，导致<code>Cache</code>实际的命中率和使用率就变得很低了，所以这种策略实际情况下是不可取的。</p><p>最理想的解决方案就是：对于某些表执行了更新(<code>update、delete、insert</code>)操作后，去清空跟这些指定的表有关联的查询语句所造成的缓存; 这样，就是以很细的粒度管理 MyBatis 内部的缓存，使得缓存的使用率和准确率都能大大地提升。</p>',53)]))}const M=c(h,[["render",y],["__file","MyBatis详解—二级缓存实现机制.html.vue"]]),b=JSON.parse('{"path":"/java/mybatis/MyBatis%E8%AF%A6%E8%A7%A3%E2%80%94%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6.html","title":"","lang":"zh-CN","frontmatter":{"description":"MyBatis二级缓存实现 MyBatis 的二级缓存是Application级别的缓存，它可以提高对数据库查询的效率，以提高应用的性能。 MyBatis的缓存机制整体设计以及二级缓存的工作模式 如图所示，当开一个会话时，一个SqlSession对象会使用一个Executor对象来完成会话操作，MyBatis 的二级缓存机制的关键就是对这个Execut...","head":[["meta",{"property":"og:url","content":"https://0oWSQo0.github.io/wsq-blog/java/mybatis/MyBatis%E8%AF%A6%E8%A7%A3%E2%80%94%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6.html"}],["meta",{"property":"og:description","content":"MyBatis二级缓存实现 MyBatis 的二级缓存是Application级别的缓存，它可以提高对数据库查询的效率，以提高应用的性能。 MyBatis的缓存机制整体设计以及二级缓存的工作模式 如图所示，当开一个会话时，一个SqlSession对象会使用一个Executor对象来完成会话操作，MyBatis 的二级缓存机制的关键就是对这个Execut..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-04-27T02:39:10.000Z"}],["meta",{"property":"article:modified_time","content":"2025-04-27T02:39:10.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-04-27T02:39:10.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"WSQ\\",\\"url\\":\\"https://0oWSQo0.github.com\\"}]}"]]},"headers":[{"level":2,"title":"MyBatis二级缓存实现","slug":"mybatis二级缓存实现","link":"#mybatis二级缓存实现","children":[{"level":3,"title":"MyBatis的缓存机制整体设计以及二级缓存的工作模式","slug":"mybatis的缓存机制整体设计以及二级缓存的工作模式","link":"#mybatis的缓存机制整体设计以及二级缓存的工作模式","children":[]},{"level":3,"title":"MyBatis二级缓存的划分","slug":"mybatis二级缓存的划分","link":"#mybatis二级缓存的划分","children":[]},{"level":3,"title":"使用二级缓存，必须要具备的条件","slug":"使用二级缓存-必须要具备的条件","link":"#使用二级缓存-必须要具备的条件","children":[]},{"level":3,"title":"一级缓存和二级缓存的使用顺序","slug":"一级缓存和二级缓存的使用顺序","link":"#一级缓存和二级缓存的使用顺序","children":[]},{"level":3,"title":"二级缓存实现的选择","slug":"二级缓存实现的选择","link":"#二级缓存实现的选择","children":[]},{"level":3,"title":"MyBatis自身提供的二级缓存的实现","slug":"mybatis自身提供的二级缓存的实现","link":"#mybatis自身提供的二级缓存的实现","children":[]}]},{"level":2,"title":"如何细粒度地控制你的MyBatis二级缓存","slug":"如何细粒度地控制你的mybatis二级缓存","link":"#如何细粒度地控制你的mybatis二级缓存","children":[{"level":3,"title":"一个关于MyBatis的二级缓存的实际问题","slug":"一个关于mybatis的二级缓存的实际问题","link":"#一个关于mybatis的二级缓存的实际问题","children":[]},{"level":3,"title":"当前MyBatis二级缓存的工作机制","slug":"当前mybatis二级缓存的工作机制","link":"#当前mybatis二级缓存的工作机制","children":[]}]}],"git":{"createdTime":1730426129000,"updatedTime":1745721550000,"contributors":[{"name":"WSQ","email":"592786982@qq.com","commits":2}]},"readingTime":{"minutes":7.78,"words":2334},"filePathRelative":"java/mybatis/MyBatis详解—二级缓存实现机制.md","localizedDate":"2024年11月1日","autoDesc":true}');export{M as comp,b as data};
