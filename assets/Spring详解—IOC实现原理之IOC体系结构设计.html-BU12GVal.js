import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,d as n,e as c,o as t,r as l}from"./app-BAoNGAQX.js";const i="/wsq-blog/assets/spring-framework-ioc-source-7-wSJUeA6x.png",p="/wsq-blog/assets/spring-framework-ioc-source-2-SX-97uGs.png",r="/wsq-blog/assets/spring-framework-ioc-source-3-Bfw8Q-U6.png",d="/wsq-blog/assets/spring-framework-ioc-source-5-yi00IQuI.png",F="/wsq-blog/assets/spring-framework-ioc-source-4-CE_UtKiI.png",y="/wsq-blog/assets/spring-framework-ioc-source-51-CDvWsURy.png",B="/wsq-blog/assets/spring-framework-ioc-source-61-CObcgL5Q.png",g="/wsq-blog/assets/spring-framework-ioc-source-71-FsuHwjSP.png",b={};function f(h,e){const a=l("Mermaid");return t(),s("div",null,[e[0]||(e[0]=n('<h2 id="站在设计者的角度考虑设计ioc容器" tabindex="-1"><a class="header-anchor" href="#站在设计者的角度考虑设计ioc容器"><span>站在设计者的角度考虑设计IOC容器</span></a></h2><figure><img src="'+i+'" alt="IOC容器的整体功能" tabindex="0" loading="lazy"><figcaption>IOC容器的整体功能</figcaption></figure><p>IOC 容器包含的几个部分：</p><ul><li>加载<code>Bean</code>的配置（比如<code>xml</code>配置）</li><li>根据<code>Bean</code>的定义加载生成<code>Bean</code>的实例，并放置在<code>Bean</code>容器中</li><li>除了基础<code>Bean</code>外，还有常规针对企业级业务的特别<code>Bean</code>。比如国际化<code>Message</code>，事件<code>Event</code>等生成特殊的类结构去支撑</li><li>对容器中的<code>Bean</code>提供统一的管理和调用</li></ul><h2 id="ioc的体系结构设计" tabindex="-1"><a class="header-anchor" href="#ioc的体系结构设计"><span>IoC的体系结构设计</span></a></h2><h3 id="beanfactory和beanregistry-ioc容器功能规范和bean的注册" tabindex="-1"><a class="header-anchor" href="#beanfactory和beanregistry-ioc容器功能规范和bean的注册"><span>BeanFactory和BeanRegistry：IOC容器功能规范和Bean的注册</span></a></h3><p><code>Spring Bean</code>的创建是典型的工厂模式，这一系列的<code>Bean</code>工厂，也即 IOC 容器为开发者管理对象间的依赖关系提供了很多便利和基础服务，在 Spring 中有许多的 IOC 容器的实现供用户选择和使用，这是IOC 容器的基础；在顶层的结构设计主要围绕着<code>BeanFactory</code>和<code>xxxRegistry</code>进行：</p><ul><li><code>BeanFactory</code>：工厂模式定义了 IOC 容器的基本功能规范</li><li><code>BeanRegistry</code>：向 IOC 容器手工注册<code>BeanDefinition</code>对象的方法</li></ul><p>其相互关系如下：</p><figure><img src="'+p+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>我们再通过几个问题来辅助理解。</p><h3 id="beanfactory定义了-ioc-容器基本功能规范" tabindex="-1"><a class="header-anchor" href="#beanfactory定义了-ioc-容器基本功能规范"><span>BeanFactory定义了 IOC 容器基本功能规范</span></a></h3><p><code>BeanFactory</code>作为最顶层的一个接口类，它定义了 IOC 容器的基本功能规范，<code>BeanFactory</code>有三个子类：<code>ListableBeanFactory、HierarchicalBeanFactory</code>和<code>AutowireCapableBeanFactory</code>。我们看下<code>BeanFactory</code>接口：</p><div class="language-java" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">public</span><span style="color:#FF9492;"> interface</span><span style="color:#FFB757;"> BeanFactory</span><span style="color:#F0F3F6;"> {    </span></span>
<span class="line"><span style="color:#BDC4CC;">    //用于取消引用实例并将其与FactoryBean创建的bean区分开来。</span></span>
<span class="line"><span style="color:#BDC4CC;">    // 例如，如果命名的bean是FactoryBean，则获取将返回Factory，而不是Factory返回的实例。</span></span>
<span class="line"><span style="color:#F0F3F6;">    String</span><span style="color:#F0F3F6;"> FACTORY_BEAN_PREFIX</span><span style="color:#FF9492;"> =</span><span style="color:#ADDCFF;"> &quot;&amp;&quot;</span><span style="color:#F0F3F6;">; </span></span>
<span class="line"><span style="color:#F0F3F6;">        </span></span>
<span class="line"><span style="color:#BDC4CC;">    //根据bean的名字和Class类型等来得到bean实例    </span></span>
<span class="line"><span style="color:#F0F3F6;">    Object </span><span style="color:#DBB7FF;">getBean</span><span style="color:#F0F3F6;">(String </span><span style="color:#FFB757;">name</span><span style="color:#F0F3F6;">) </span><span style="color:#FF9492;">throws</span><span style="color:#F0F3F6;"> BeansException;    </span></span>
<span class="line"><span style="color:#F0F3F6;">    Object </span><span style="color:#DBB7FF;">getBean</span><span style="color:#F0F3F6;">(String </span><span style="color:#FFB757;">name</span><span style="color:#F0F3F6;">, Class </span><span style="color:#FFB757;">requiredType</span><span style="color:#F0F3F6;">) </span><span style="color:#FF9492;">throws</span><span style="color:#F0F3F6;"> BeansException;    </span></span>
<span class="line"><span style="color:#F0F3F6;">    Object </span><span style="color:#DBB7FF;">getBean</span><span style="color:#F0F3F6;">(String </span><span style="color:#FFB757;">name</span><span style="color:#F0F3F6;">, Object... </span><span style="color:#FFB757;">args</span><span style="color:#F0F3F6;">) </span><span style="color:#FF9492;">throws</span><span style="color:#F0F3F6;"> BeansException;</span></span>
<span class="line"><span style="color:#F0F3F6;">    &lt;</span><span style="color:#FF9492;">T</span><span style="color:#F0F3F6;">&gt; T </span><span style="color:#DBB7FF;">getBean</span><span style="color:#F0F3F6;">(Class&lt;</span><span style="color:#FF9492;">T</span><span style="color:#F0F3F6;">&gt; </span><span style="color:#FFB757;">requiredType</span><span style="color:#F0F3F6;">) </span><span style="color:#FF9492;">throws</span><span style="color:#F0F3F6;"> BeansException;</span></span>
<span class="line"><span style="color:#F0F3F6;">    &lt;</span><span style="color:#FF9492;">T</span><span style="color:#F0F3F6;">&gt; T </span><span style="color:#DBB7FF;">getBean</span><span style="color:#F0F3F6;">(Class&lt;</span><span style="color:#FF9492;">T</span><span style="color:#F0F3F6;">&gt; </span><span style="color:#FFB757;">requiredType</span><span style="color:#F0F3F6;">, Object... </span><span style="color:#FFB757;">args</span><span style="color:#F0F3F6;">) </span><span style="color:#FF9492;">throws</span><span style="color:#F0F3F6;"> BeansException;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;">    //返回指定bean的Provider</span></span>
<span class="line"><span style="color:#F0F3F6;">    &lt;</span><span style="color:#FF9492;">T</span><span style="color:#F0F3F6;">&gt; ObjectProvider&lt;</span><span style="color:#FF9492;">T</span><span style="color:#F0F3F6;">&gt; </span><span style="color:#DBB7FF;">getBeanProvider</span><span style="color:#F0F3F6;">(Class&lt;</span><span style="color:#FF9492;">T</span><span style="color:#F0F3F6;">&gt; </span><span style="color:#FFB757;">requiredType</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#F0F3F6;">    &lt;</span><span style="color:#FF9492;">T</span><span style="color:#F0F3F6;">&gt; ObjectProvider&lt;</span><span style="color:#FF9492;">T</span><span style="color:#F0F3F6;">&gt; </span><span style="color:#DBB7FF;">getBeanProvider</span><span style="color:#F0F3F6;">(ResolvableType </span><span style="color:#FFB757;">requiredType</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;">    //检查工厂中是否包含给定name的bean，或者外部注册的bean</span></span>
<span class="line"><span style="color:#FF9492;">    boolean</span><span style="color:#DBB7FF;"> containsBean</span><span style="color:#F0F3F6;">(String </span><span style="color:#FFB757;">name</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;">    //检查所给定name的bean是否为单例/原型</span></span>
<span class="line"><span style="color:#FF9492;">    boolean</span><span style="color:#DBB7FF;"> isSingleton</span><span style="color:#F0F3F6;">(String </span><span style="color:#FFB757;">name</span><span style="color:#F0F3F6;">) </span><span style="color:#FF9492;">throws</span><span style="color:#F0F3F6;"> NoSuchBeanDefinitionException;</span></span>
<span class="line"><span style="color:#FF9492;">    boolean</span><span style="color:#DBB7FF;"> isPrototype</span><span style="color:#F0F3F6;">(String </span><span style="color:#FFB757;">name</span><span style="color:#F0F3F6;">) </span><span style="color:#FF9492;">throws</span><span style="color:#F0F3F6;"> NoSuchBeanDefinitionException;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;">    //判断所给name的类型与type是否匹配</span></span>
<span class="line"><span style="color:#FF9492;">    boolean</span><span style="color:#DBB7FF;"> isTypeMatch</span><span style="color:#F0F3F6;">(String </span><span style="color:#FFB757;">name</span><span style="color:#F0F3F6;">, ResolvableType </span><span style="color:#FFB757;">typeToMatch</span><span style="color:#F0F3F6;">) </span><span style="color:#FF9492;">throws</span><span style="color:#F0F3F6;"> NoSuchBeanDefinitionException;</span></span>
<span class="line"><span style="color:#FF9492;">    boolean</span><span style="color:#DBB7FF;"> isTypeMatch</span><span style="color:#F0F3F6;">(String </span><span style="color:#FFB757;">name</span><span style="color:#F0F3F6;">, Class&lt;</span><span style="color:#FF9492;">?</span><span style="color:#F0F3F6;">&gt; </span><span style="color:#FFB757;">typeToMatch</span><span style="color:#F0F3F6;">) </span><span style="color:#FF9492;">throws</span><span style="color:#F0F3F6;"> NoSuchBeanDefinitionException;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;">    //获取给定name的bean的类型</span></span>
<span class="line"><span style="color:#F0F3F6;">    @</span><span style="color:#FF9492;">Nullable</span></span>
<span class="line"><span style="color:#F0F3F6;">    Class&lt;</span><span style="color:#FF9492;">?</span><span style="color:#F0F3F6;">&gt; </span><span style="color:#DBB7FF;">getType</span><span style="color:#F0F3F6;">(String </span><span style="color:#FFB757;">name</span><span style="color:#F0F3F6;">) </span><span style="color:#FF9492;">throws</span><span style="color:#F0F3F6;"> NoSuchBeanDefinitionException;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;">    //返回给定name的bean的别名</span></span>
<span class="line"><span style="color:#FF9492;">    String</span><span style="color:#F0F3F6;">[] </span><span style="color:#DBB7FF;">getAliases</span><span style="color:#F0F3F6;">(String </span><span style="color:#FFB757;">name</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><h3 id="beanfactory为何要定义这么多层次的接口-定义了哪些接口" tabindex="-1"><a class="header-anchor" href="#beanfactory为何要定义这么多层次的接口-定义了哪些接口"><span>BeanFactory为何要定义这么多层次的接口？定义了哪些接口？</span></a></h3><p>主要是为了区分在 Spring 内部在操作过程中对象的传递和转化过程中，对对象的数据访问所做的限制。</p><p>有哪些接口呢？</p><ul><li><code>ListableBeanFactory</code>：该接口定义了访问容器中<code>Bean</code>基本信息的若干方法，如查看<code>Bean</code>的个数、获取某一类型<code>Bean</code>的配置名、查看容器中是否包括某一<code>Bean</code>等方法；</li><li><code>HierarchicalBeanFactory</code>：父子级联 IoC 容器的接口，子容器可以通过接口方法访问父容器；通过<code>HierarchicalBeanFactory</code>接口，Spring 的 IoC 容器可以建立父子层级关联的容器体系，子容器可以访问父容器中的<code>Bean</code>，但父容器不能访问子容器的<code>Bean</code>。Spring 使用父子容器实现了很多功能，比如在 Spring MVC 中，展现层<code>Bean</code>位于一个子容器中，而业务层和持久层的<code>Bean</code>位于父容器中。这样，展现层<code>Bean</code>就可以引用业务层和持久层的<code>Bean</code>，而业务层和持久层的<code>Bean</code>则看不到展现层的<code>Bean</code>。</li><li><code>ConfigurableBeanFactory</code>：是一个重要的接口，增强了 IoC 容器的可定制性，它定义了设置类装载器、属性编辑器、容器初始化后置处理器等方法；</li><li><code>ConfigurableListableBeanFactory</code>: <code>ListableBeanFactory</code>和<code>ConfigurableBeanFactory</code>的融合；</li><li><code>AutowireCapableBeanFactory</code>：定义了将容器中的<code>Bean</code>按某种规则（如按名字匹配、按类型匹配等）进行自动装配的方法；</li></ul><h3 id="如何将bean注册到beanfactory中-beanregistry" tabindex="-1"><a class="header-anchor" href="#如何将bean注册到beanfactory中-beanregistry"><span>如何将Bean注册到BeanFactory中？BeanRegistry</span></a></h3><p>Spring 配置文件中每一个<code>&lt;bean&gt;</code>节点元素在 Spring 容器里都通过一个<code>BeanDefinition</code>对象表示，它描述了<code>Bean</code>的配置信息。而<code>BeanDefinitionRegistry</code>接口提供了向容器手工注册<code>BeanDefinition</code>对象的方法。</p><h2 id="beandefinition-各种bean对象及其相互的关系" tabindex="-1"><a class="header-anchor" href="#beandefinition-各种bean对象及其相互的关系"><span>BeanDefinition：各种Bean对象及其相互的关系</span></a></h2><p><code>Bean</code>对象存在依赖嵌套等关系，所以设计者设计了<code>BeanDefinition</code>，它用来对<code>Bean</code>对象及关系定义；我们在理解时只需要抓住如下三个要点：</p><ul><li><code>BeanDefinition</code>定义了各种<code>Bean</code>对象及其相互的关系</li><li><code>BeanDefinitionReader</code>这是<code>BeanDefinition</code>的解析器</li><li><code>BeanDefinitionHolder</code>这是<code>BeanDefination</code>的包装类，用来存储<code>BeanDefinition</code>，<code>name</code>以及<code>aliases</code>等</li></ul><h3 id="beandefinition" tabindex="-1"><a class="header-anchor" href="#beandefinition"><span>BeanDefinition</span></a></h3><p>SpringIOC 容器管理了我们定义的各种<code>Bean</code>对象及其相互的关系，<code>Bean</code>对象在 Spring 实现中是以<code>BeanDefinition</code>来描述的，其继承体系如下：</p><figure><img src="`+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="beandefinitionreader" tabindex="-1"><a class="header-anchor" href="#beandefinitionreader"><span>BeanDefinitionReader</span></a></h3><p><code>Bean</code>的解析过程非常复杂，功能被分的很细，因为这里需要被扩展的地方很多，必须保证有足够的灵活性，以应对可能的变化。<code>Bean</code>的解析主要就是对 Spring 配置文件的解析。这个解析过程主要通过下面的类完成：</p>',28)),c(a,{id:"mermaid-148",code:"eJyNkE0KwjAQhdd6ilygPUEpqBVx68rtNE4lkEwkSQui3t20Qhe1+VnO8L437w2XYG0j4G5AbRmbRrZHoAY7QcIJTY3mvUJyF4QbGvbysk1Vncmh6YBjXfvFZ2Y9B710SYuRyNGW5buOBgqkzkt7pEEYTaPbAR7QSpyIMLBrrTPAF5kXvX7Sk9F6eGYIr0pGVdGbK/+Z/5IG//t7LBK8KDwUs/V4qE6a/QIU6eRf"}),e[1]||(e[1]=n('<figure><img src="'+d+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="beandefinitionholder" tabindex="-1"><a class="header-anchor" href="#beandefinitionholder"><span>BeanDefinitionHolder</span></a></h3><p><code>BeanDefinitionHolder</code>这是<code>BeanDefination</code>的包装类，用来存储<code>BeanDefinition</code>，<code>name</code>以及<code>aliases</code>等。</p><figure><img src="'+F+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="applicationcontext-ioc接口设计和实现" tabindex="-1"><a class="header-anchor" href="#applicationcontext-ioc接口设计和实现"><span>ApplicationContext：IOC接口设计和实现</span></a></h2><p>IoC 容器的接口类是<code>ApplicationContext</code>，很显然它必然继承<code>BeanFactory</code>对<code>Bean</code>规范（最基本的 ioc 容器的实现）进行定义。而<code>ApplicationContext</code>表示的是应用的上下文，除了对<code>Bean</code>的管理外，还至少应该包含了：</p><ul><li>访问资源：对不同方式的<code>Bean</code>配置（即资源）进行加载。(实现<code>ResourcePatternResolver</code>接口)</li><li>国际化: 支持信息源，可以实现国际化。（实现<code>MessageSource</code>接口）</li><li>应用事件: 支持应用事件。(实现<code>ApplicationEventPublisher</code>接口)</li></ul><h3 id="applicationcontext接口的设计" tabindex="-1"><a class="header-anchor" href="#applicationcontext接口的设计"><span>ApplicationContext接口的设计</span></a></h3><figure><img src="'+y+'" alt="整体结构" tabindex="0" loading="lazy"><figcaption><code>ApplicationContext</code>整体结构</figcaption></figure><ul><li><code>HierarchicalBeanFactory</code>和<code>ListableBeanFactory</code>：<code>ApplicationContext</code>继承了<code>HierarchicalBeanFactory</code>和<code>ListableBeanFactory</code>接口，在此基础上，还通过多个其他的接口扩展了<code>BeanFactory</code>的功能：</li><li><code>ApplicationEventPublisher</code>：让容器拥有发布应用上下文事件的功能，包括容器启动事件、关闭事件等。实现了<code>ApplicationListener</code>事件监听接口的<code>Bean</code>可以接收到容器事件，并对事件进行响应处理 。 在<code>ApplicationContext</code>抽象实现类<code>AbstractApplicationContext</code>中，我们可以发现存在一个 <code>ApplicationEventMulticaster</code>，它负责保存所有监听器，以便在容器产生上下文事件时通知这些事件监听者。</li><li><code>MessageSource</code>：为应用提供 i18n 国际化消息访问的功能；</li><li><code>ResourcePatternResolver</code>：所有<code>ApplicationContext</code>实现类都实现了类似于<code>PathMatchingResourcePatternResolver</code>的功能，可以通过带前缀的<code>Ant</code>风格的资源文件路径装载 Spring 的配置文件。</li><li><code>LifeCycle</code>：该接口提供了<code>start()</code>和<code>stop()</code>两个方法，主要用于控制异步处理过程。在具体使用时，该接口同时被<code>ApplicationContext</code>实现及具体<code>Bean</code>实现，<code>ApplicationContext</code>会将<code>start/stop</code>的信息传递给容器中所有实现了该接口的<code>Bean</code>，以达到管理和控制 JMX、任务调度等目的。</li></ul><h3 id="applicationcontext接口的实现" tabindex="-1"><a class="header-anchor" href="#applicationcontext接口的实现"><span>ApplicationContext接口的实现</span></a></h3><p>在考虑<code>ApplicationContext</code>接口的实现时，关键的点在于，不同<code>Bean</code>的配置方式（比如<code>xml,groovy,annotation</code>等）有着不同的资源加载方式，这便衍生除了众多<code>ApplicationContext</code>的实现类。</p><figure><img src="'+B+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>第一，从类结构设计上看， 围绕着是否需要<code>Refresh</code>容器衍生出两个抽象类：<br><code>GenericApplicationContext</code>： 是初始化的时候就创建容器，往后的每次<code>refresh</code>都不会更改<br><code>AbstractRefreshableApplicationContext</code>：<code>AbstractRefreshableApplicationContext</code>及子类的每次<code>refresh</code>都是先清除已有(如果不存在就创建)的容器，然后再重新创建；<code>AbstractRefreshableApplicationContext</code>及子类无法做到<code>GenericApplicationContext</code>混合搭配从不同源头获取<code>bean</code>的定义信息</p><p>第二， 从加载的源来看（比如<code>xml,groovy,annotation</code>等）， 衍生出众多类型的<code>ApplicationContext</code>, 典型比如:<br><code>FileSystemXmlApplicationContext</code>： 从文件系统下的一个或多个xml配置文件中加载上下文定义，也就是说系统盘符中加载xml配置文件。<br><code>ClassPathXmlApplicationContext</code>： 从类路径下的一个或多个xml配置文件中加载上下文定义，适用于xml配置的方式。<br><code>AnnotationConfigApplicationContext</code>： 从一个或多个基于java的配置类中加载上下文定义，适用于java注解的方式。<br><code>ConfigurableApplicationContext</code>： 扩展于<code>ApplicationContext</code>，它新增加了两个主要的方法： refresh()和 close()，让 <code>ApplicationContext</code>具有启动、刷新和关闭应用上下文的能力。在应用上下文关闭的情况下调用 refresh()即可启动应用上下文，在已经启动的状态下，调用<code>refresh()</code>则清除缓存并重新装载配置信息，而调用<code>close()</code>则可关闭应用上下文。这些接口方法为容器的控制管理带来了便利，但作为开发者，我们并不需要过多关心这些方法。</p><p>第三， 更进一步理解：设计者在设计时<code>AnnotationConfigApplicationContext</code>为什么是继承<code>GenericApplicationContext</code>？因为基于注解的配置，是不太会被运行时修改的，这意味着不需要进行动态<code>Bean</code>配置和刷新容器，所以只需要<code>GenericApplicationContext</code>。</p><p>而基于XML这种配置文件，这种文件是容易修改的，需要动态性刷新<code>Bean</code>的支持，所以 XML 相关的配置必然继承<code>AbstractRefreshableApplicationContext</code>； 且存在多种<code>xml</code>的加载方式（位置不同的设计），所以必然会设计出<code>AbstractXmlApplicationContext</code>, 其中包含对XML配置解析成<code>BeanDefination</code>的过程。</p><p>我们把之前的设计要点和设计结构结合起来看：</p><figure><img src="'+g+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',19))])}const m=o(b,[["render",f],["__file","Spring详解—IOC实现原理之IOC体系结构设计.html.vue"]]),x=JSON.parse('{"path":"/java/Spring/Spring%E8%AF%A6%E8%A7%A3%E2%80%94IOC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B9%8BIOC%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1.html","title":"","lang":"zh-CN","frontmatter":{"description":"站在设计者的角度考虑设计IOC容器 IOC容器的整体功能IOC容器的整体功能 IOC 容器包含的几个部分： 加载Bean的配置（比如xml配置） 根据Bean的定义加载生成Bean的实例，并放置在Bean容器中 除了基础Bean外，还有常规针对企业级业务的特别Bean。比如国际化Message，事件Event等生成特殊的类结构去支撑 对容器中的Bean...","head":[["meta",{"property":"og:url","content":"https://0oWSQo0.github.io/wsq-blog/java/Spring/Spring%E8%AF%A6%E8%A7%A3%E2%80%94IOC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B9%8BIOC%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1.html"}],["meta",{"property":"og:description","content":"站在设计者的角度考虑设计IOC容器 IOC容器的整体功能IOC容器的整体功能 IOC 容器包含的几个部分： 加载Bean的配置（比如xml配置） 根据Bean的定义加载生成Bean的实例，并放置在Bean容器中 除了基础Bean外，还有常规针对企业级业务的特别Bean。比如国际化Message，事件Event等生成特殊的类结构去支撑 对容器中的Bean..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-11-01T01:55:29.000Z"}],["meta",{"property":"article:modified_time","content":"2024-11-01T01:55:29.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-11-01T01:55:29.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"WSQ\\",\\"url\\":\\"https://0oWSQo0.github.com\\"}]}"]]},"headers":[{"level":2,"title":"站在设计者的角度考虑设计IOC容器","slug":"站在设计者的角度考虑设计ioc容器","link":"#站在设计者的角度考虑设计ioc容器","children":[]},{"level":2,"title":"IoC的体系结构设计","slug":"ioc的体系结构设计","link":"#ioc的体系结构设计","children":[{"level":3,"title":"BeanFactory和BeanRegistry：IOC容器功能规范和Bean的注册","slug":"beanfactory和beanregistry-ioc容器功能规范和bean的注册","link":"#beanfactory和beanregistry-ioc容器功能规范和bean的注册","children":[]},{"level":3,"title":"BeanFactory定义了 IOC 容器基本功能规范","slug":"beanfactory定义了-ioc-容器基本功能规范","link":"#beanfactory定义了-ioc-容器基本功能规范","children":[]},{"level":3,"title":"BeanFactory为何要定义这么多层次的接口？定义了哪些接口？","slug":"beanfactory为何要定义这么多层次的接口-定义了哪些接口","link":"#beanfactory为何要定义这么多层次的接口-定义了哪些接口","children":[]},{"level":3,"title":"如何将Bean注册到BeanFactory中？BeanRegistry","slug":"如何将bean注册到beanfactory中-beanregistry","link":"#如何将bean注册到beanfactory中-beanregistry","children":[]}]},{"level":2,"title":"BeanDefinition：各种Bean对象及其相互的关系","slug":"beandefinition-各种bean对象及其相互的关系","link":"#beandefinition-各种bean对象及其相互的关系","children":[{"level":3,"title":"BeanDefinition","slug":"beandefinition","link":"#beandefinition","children":[]},{"level":3,"title":"BeanDefinitionReader","slug":"beandefinitionreader","link":"#beandefinitionreader","children":[]},{"level":3,"title":"BeanDefinitionHolder","slug":"beandefinitionholder","link":"#beandefinitionholder","children":[]}]},{"level":2,"title":"ApplicationContext：IOC接口设计和实现","slug":"applicationcontext-ioc接口设计和实现","link":"#applicationcontext-ioc接口设计和实现","children":[{"level":3,"title":"ApplicationContext接口的设计","slug":"applicationcontext接口的设计","link":"#applicationcontext接口的设计","children":[]},{"level":3,"title":"ApplicationContext接口的实现","slug":"applicationcontext接口的实现","link":"#applicationcontext接口的实现","children":[]}]}],"git":{"createdTime":1730426129000,"updatedTime":1730426129000,"contributors":[{"name":"WSQ","email":"592786982@qq.com","commits":1}]},"readingTime":{"minutes":8.57,"words":2572},"filePathRelative":"java/Spring/Spring详解—IOC实现原理之IOC体系结构设计.md","localizedDate":"2024年11月1日","autoDesc":true}');export{m as comp,x as data};
