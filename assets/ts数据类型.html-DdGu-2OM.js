import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as o,d as n,o as l}from"./app-ByvFWdWZ.js";const p={};function e(c,s){return l(),o("div",null,s[0]||(s[0]=[n(`<p>TypeScript 继承了 JavaScript 的类型，在这个基础上，定义了一套自己的类型系统。</p><h2 id="基本类型" tabindex="-1"><a class="header-anchor" href="#基本类型"><span>基本类型</span></a></h2><h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述"><span>概述</span></a></h2><p>JavaScript 将值分成8种类型：</p><ul><li><code>boolean</code></li><li><code>string</code></li><li><code>number</code></li><li><code>bigint</code></li><li><code>symbol</code></li><li><code>object</code></li><li><code>undefined</code></li><li><code>null</code></li></ul><p>TypeScript 继承了 JavaScript 的类型设计，以上 8 种类型可以看作 TypeScript 的基本类型。</p><p>注意，上面所有类型的名称都是小写字母，首字母大写的<code>Number、String、Boolean</code>等在 JavaScript 语言中都是内置对象，而不是类型名称。</p><p>另外，<code>undefined</code>和<code>null</code>既可以作为值，也可以作为类型，取决于在哪里使用它们。</p><p>这 8 种基本类型是 TypeScript 类型系统的基础，复杂类型由它们组合而成。</p><h3 id="boolean-类型" tabindex="-1"><a class="header-anchor" href="#boolean-类型"><span>boolean 类型</span></a></h3><p><code>boolean</code>类型只包含<code>true</code>和<code>false</code>两个布尔值。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> x</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">boolean</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> true</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> y</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">boolean</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> false</span></span></code></pre></div><h3 id="string-类型" tabindex="-1"><a class="header-anchor" href="#string-类型"><span>string 类型</span></a></h3><p><code>string</code>类型包含所有字符串。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> x</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">string</span><span style="color:#FF9492;"> =</span><span style="color:#ADDCFF;"> &#39;hello&#39;</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> y</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">string</span><span style="color:#FF9492;"> =</span><span style="color:#ADDCFF;"> \`\${</span><span style="color:#F0F3F6;">x</span><span style="color:#ADDCFF;">} world\`</span></span></code></pre></div><h3 id="number-类型" tabindex="-1"><a class="header-anchor" href="#number-类型"><span>number 类型</span></a></h3><p><code>number</code>类型包含所有整数和浮点数。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> x</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">number</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> 123</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> y</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">number</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> 3.14</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> z</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">number</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> 0xffff</span></span></code></pre></div><h3 id="bigint-类型" tabindex="-1"><a class="header-anchor" href="#bigint-类型"><span>bigint 类型</span></a></h3><p><code>bigint</code>类型包含所有的大整数。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> x</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">bigint</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> 123</span><span style="color:#FF9492;">n</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> y</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">bigint</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> 0xffff</span><span style="color:#FF9492;">n</span></span></code></pre></div><p>上面示例中，变量<code>x</code>和<code>y</code>就属于<code>bigint</code>类型。</p><p><code>bigint</code>与<code>number</code>类型不兼容。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> x</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">bigint</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> 123</span><span style="color:#BDC4CC;"> // 报错</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> y</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">bigint</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> 3.14</span><span style="color:#BDC4CC;"> // 报错</span></span></code></pre></div><p>上面示例中，<code>bigint</code>类型赋值为整数和小数，都会报错。</p><div class="hint-container tip"><p class="hint-container-title">提示</p><p>注意，<code>bigint</code>类型是 ES2020 标准引入的。如果使用这个类型，TypeScript 编译的目标 JavaScript 版本不能低于<code>ES2020</code>（即编译参数<code>target</code>不低于<code>es2020</code>）。</p></div><h3 id="symbol-类型" tabindex="-1"><a class="header-anchor" href="#symbol-类型"><span>symbol 类型</span></a></h3><p><code>Symbol</code>是 ES2015 新引入的一种原始类型的值。它类似于字符串，但是每一个<code>Symbol</code>值都是独一无二的，与其他任何值都不相等。</p><p><code>Symbol</code>值通过<code>Symbol()</code>函数生成。在 TypeScript 里面，<code>Symbol</code>的类型使用<code>symbol</code>表示。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> x</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">symbol</span><span style="color:#FF9492;"> =</span><span style="color:#DBB7FF;"> Symbol</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> y</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">symbol</span><span style="color:#FF9492;"> =</span><span style="color:#DBB7FF;"> Symbol</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">x </span><span style="color:#FF9492;">===</span><span style="color:#F0F3F6;"> y </span><span style="color:#BDC4CC;">// false</span></span></code></pre></div><p>上面示例中，变量<code>x</code>和<code>y</code>的类型都是<code>symbol</code>，且都用<code>Symbol()</code>生成，但是它们是不相等的。</p><h4 id="unique-symbol" tabindex="-1"><a class="header-anchor" href="#unique-symbol"><span>unique symbol</span></a></h4><p><code>symbol</code>类型包含所有的<code>Symbol</code>值，但是无法表示某一个具体的<code>Symbol</code>值。</p><p>比如，5 是一个具体的数值，就用 5 这个字面量来表示，这也是它的值类型。但是，<code>Symbol</code>值不存在字面量，必须通过变量来引用，所以写不出只包含单个<code>Symbol</code>值的那种值类型。</p><p>为了解决这个问题，TypeScript 设计了<code>symbol</code>的一个子类型<code>unique symbol</code>，它表示单个的、某个具体的<code>Symbol</code>值。</p><p>因为<code>unique symbol</code>表示单个值，所以这个类型的变量是不能修改值的，只能用<code>const</code>命令声明，不能用<code>let</code>声明。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">// 正确</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> x</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;">unique</span><span style="color:#91CBFF;"> symbol</span><span style="color:#FF9492;"> =</span><span style="color:#DBB7FF;"> Symbol</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;">// 报错</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> y</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;">unique</span><span style="color:#91CBFF;"> symbol</span><span style="color:#FF9492;"> =</span><span style="color:#DBB7FF;"> Symbol</span><span style="color:#F0F3F6;">();</span></span></code></pre></div><p>上面示例中，<code>let</code>命令声明的变量，不能是<code>unique symbol</code>类型，会报错。</p><p><code>const</code>命令为变量赋值<code>Symbol</code>值时，变量类型默认就是<code>unique symbol</code>，所以类型可以省略不写。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> x</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;">unique</span><span style="color:#91CBFF;"> symbol</span><span style="color:#FF9492;"> =</span><span style="color:#DBB7FF;"> Symbol</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#BDC4CC;">// 等同于</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> x</span><span style="color:#FF9492;"> =</span><span style="color:#DBB7FF;"> Symbol</span><span style="color:#F0F3F6;">();</span></span></code></pre></div><p>每个声明为<code>unique symbol</code>类型的变量，它们的值都是不一样的，其实属于两个值类型。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> a</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;">unique</span><span style="color:#91CBFF;"> symbol</span><span style="color:#FF9492;"> =</span><span style="color:#DBB7FF;"> Symbol</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> b</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;">unique</span><span style="color:#91CBFF;"> symbol</span><span style="color:#FF9492;"> =</span><span style="color:#DBB7FF;"> Symbol</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">a </span><span style="color:#FF9492;">===</span><span style="color:#F0F3F6;"> b </span><span style="color:#BDC4CC;">// 报错</span></span></code></pre></div><p>上面示例中，变量a和变量b的类型虽然都是<code>unique symbol</code>，但其实是两个值类型。不同类型的值肯定是不相等的，所以最后一行就报错了。</p><p>由于<code>Symbol</code>类似于字符串，可以参考下面的例子来理解。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> a</span><span style="color:#FF9492;">:</span><span style="color:#ADDCFF;">&#39;hello&#39;</span><span style="color:#FF9492;"> =</span><span style="color:#ADDCFF;"> &#39;hello&#39;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> b</span><span style="color:#FF9492;">:</span><span style="color:#ADDCFF;">&#39;world&#39;</span><span style="color:#FF9492;"> =</span><span style="color:#ADDCFF;"> &#39;world&#39;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">a </span><span style="color:#FF9492;">===</span><span style="color:#F0F3F6;"> b </span><span style="color:#BDC4CC;">// 报错</span></span></code></pre></div><p>上面示例中，变量<code>a</code>和<code>b</code>都是字符串，但是属于不同的值类型，不能使用严格相等运算符进行比较。</p><p>而且，由于变量<code>a</code>和<code>b</code>是两个类型，就不能把一个赋值给另一个。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> a</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;">unique</span><span style="color:#91CBFF;"> symbol</span><span style="color:#FF9492;"> =</span><span style="color:#DBB7FF;"> Symbol</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> b</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;">unique</span><span style="color:#91CBFF;"> symbol</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> a; </span><span style="color:#BDC4CC;">// 报错</span></span></code></pre></div><p>上面示例中，变量<code>a</code>和变量<code>b</code>的类型都是<code>unique symbol</code>，但是其实类型不同，所以把<code>a</code>赋值给<code>b</code>会报错。</p><p>上例变量<code>b</code>的类型，如果要写成与变量<code>a</code>同一个<code>unique symbol</code>值类型，只能写成类型为<code>typeof a</code>。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> a</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;">unique</span><span style="color:#91CBFF;"> symbol</span><span style="color:#FF9492;"> =</span><span style="color:#DBB7FF;"> Symbol</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> b</span><span style="color:#FF9492;">:typeof</span><span style="color:#F0F3F6;"> a </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> a; </span><span style="color:#BDC4CC;">// 正确</span></span></code></pre></div><p>不过我们知道，相同参数的<code>Symbol.for()</code>方法会返回相同的<code>Symbol</code>值。TypeScript 目前无法识别这种情况，所以可能出现多个<code>unique symbol</code>类型的变量，等于同一个<code>Symbol</code>值的情况。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> a</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;">unique</span><span style="color:#91CBFF;"> symbol</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> Symbol.</span><span style="color:#DBB7FF;">for</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;foo&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> b</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;">unique</span><span style="color:#91CBFF;"> symbol</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> Symbol.</span><span style="color:#DBB7FF;">for</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;foo&#39;</span><span style="color:#F0F3F6;">);</span></span></code></pre></div><p>上面示例中，变量<code>a</code>和<code>b</code>是两个不同的值类型，但是它们的值其实是相等的。</p><p><code>unique symbol</code>类型是<code>symbol</code>类型的子类型，所以可以将前者赋值给后者，但是反过来就不行。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> a</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;">unique</span><span style="color:#91CBFF;"> symbol</span><span style="color:#FF9492;"> =</span><span style="color:#DBB7FF;"> Symbol</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> b</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">symbol</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> a; </span><span style="color:#BDC4CC;">// 正确</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> c</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;">unique</span><span style="color:#91CBFF;"> symbol</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> b; </span><span style="color:#BDC4CC;">// 报错</span></span></code></pre></div><p>上面示例中，<code>unique symbol</code>类型（变量<code>a</code>）赋值给<code>symbol</code>类型（变量<code>b</code>）是可以的，但是<code>symbol</code>类型（变量<code>b</code>）赋值给<code>unique symbol</code>类型（变量<code>c</code>）会报错。</p><p><code>unique symbol</code>类型的一个作用，就是用作属性名，这可以保证不会跟其他属性名冲突。如果要把某一个特定的<code>Symbol</code>值当作属性名，那么它的类型只能是<code>unique symbol</code>，不能是<code>symbol</code>。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> x</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;">unique</span><span style="color:#91CBFF;"> symbol</span><span style="color:#FF9492;"> =</span><span style="color:#DBB7FF;"> Symbol</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> y</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">symbol</span><span style="color:#FF9492;"> =</span><span style="color:#DBB7FF;"> Symbol</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">interface</span><span style="color:#FFB757;"> Foo</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">  [x]</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> string</span><span style="color:#F0F3F6;">; </span><span style="color:#BDC4CC;">// 正确</span></span>
<span class="line"><span style="color:#F0F3F6;">  [y]</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> string</span><span style="color:#F0F3F6;">; </span><span style="color:#BDC4CC;">// 报错</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面示例中，变量<code>y</code>当作属性名，但是<code>y</code>的类型是<code>symbol</code>，不是固定不变的值，导致报错。</p><p><code>unique symbol</code>类型也可以用作类（<code>class</code>）的属性值，但只能赋值给类的<code>readonly static</code>属性。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> C</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">	static</span><span style="color:#FF9492;"> readonly</span><span style="color:#FFB757;"> foo</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;">unique</span><span style="color:#91CBFF;"> symbol</span><span style="color:#FF9492;"> =</span><span style="color:#DBB7FF;"> Symbol</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面示例中，静态只读属性<code>foo</code>的类型就是<code>unique symbol</code>。注意，这时<code>static</code>和<code>readonly</code>两个限定符缺一不可，这是为了保证这个属性是固定不变的。</p><h4 id="类型推断" tabindex="-1"><a class="header-anchor" href="#类型推断"><span>类型推断</span></a></h4><p>如果变量声明时没有给出类型，TypeScript 会推断某个<code>Symbol</code>值变量的类型。</p><p><code>let</code>命令声明的变量，推断类型为<code>symbol</code>。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">// 类型为 symbol</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> x </span><span style="color:#FF9492;">=</span><span style="color:#DBB7FF;"> Symbol</span><span style="color:#F0F3F6;">();</span></span></code></pre></div><p><code>const</code>命令声明的变量，推断类型为<code>unique symbol</code>。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">// 类型为 unique symbol</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> x</span><span style="color:#FF9492;"> =</span><span style="color:#DBB7FF;"> Symbol</span><span style="color:#F0F3F6;">();</span></span></code></pre></div><p>但是，<code>const</code>命令声明的变量，如果赋值为另一个<code>symbol</code>类型的变量，则推断类型为<code>symbol</code>。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> x </span><span style="color:#FF9492;">=</span><span style="color:#DBB7FF;"> Symbol</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;">// 类型为 symbol</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> y</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> x;</span></span></code></pre></div><p><code>let</code>命令声明的变量，如果赋值为另一个<code>unique symbol</code>类型的变量，则推断类型还是<code>symbol</code>。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> x</span><span style="color:#FF9492;"> =</span><span style="color:#DBB7FF;"> Symbol</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;">// 类型为 symbol</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> y </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> x;</span></span></code></pre></div><h3 id="object-类型" tabindex="-1"><a class="header-anchor" href="#object-类型"><span>object 类型</span></a></h3><p>根据 JavaScript 的设计，<code>object</code>类型包含了所有对象、数组和函数。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> x</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">object</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> { foo: </span><span style="color:#91CBFF;">123</span><span style="color:#F0F3F6;"> }</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> y</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">object</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> [</span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">3</span><span style="color:#F0F3F6;">]</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#DBB7FF;"> z</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">object</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> (</span><span style="color:#FFB757;">n</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">number</span><span style="color:#F0F3F6;">) </span><span style="color:#FF9492;">=&gt;</span><span style="color:#F0F3F6;"> n </span><span style="color:#FF9492;">+</span><span style="color:#91CBFF;"> 1</span></span></code></pre></div><h3 id="undefined-类型-null-类型" tabindex="-1"><a class="header-anchor" href="#undefined-类型-null-类型"><span>undefined 类型，null 类型</span></a></h3><p><code>undefined</code>和<code>null</code>是两种独立类型，它们各自都只有一个值。</p><p><code>undefined</code>类型只包含一个值<code>undefined</code>，表示未定义（即还未给出定义，以后可能会有定义）。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> x</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">undefined</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> undefined</span></span></code></pre></div><p><code>null</code>类型也只包含一个值<code>null</code>，表示为空（即此处没有值）。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> x</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">null</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> null</span></span></code></pre></div><p>注意，如果没有声明类型的变量，被赋值为<code>undefined</code>或<code>null</code>，在关闭编译设置<code>noImplicitAny</code>和s<code>trictNullChecks</code>时，它们的类型会被推断为<code>any</code>。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">// 关闭 noImplicitAny 和 strictNullChecks</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> a </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> undefined</span><span style="color:#BDC4CC;">   // any</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> b</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> undefined</span><span style="color:#BDC4CC;"> // any</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> c </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> null</span><span style="color:#BDC4CC;">        // any</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> d</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> null</span><span style="color:#BDC4CC;">      // any</span></span></code></pre></div><p>如果希望避免这种情况，则需要打开编译选项<code>strictNullChecks</code>。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">// 打开编译设置 strictNullChecks</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> a </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> undefined</span><span style="color:#BDC4CC;">   // undefined</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> b</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> undefined</span><span style="color:#BDC4CC;"> // undefined</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> c </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> null</span><span style="color:#BDC4CC;">        // null</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> d</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> null</span><span style="color:#BDC4CC;">      // null</span></span></code></pre></div><p>上面示例中，打开编译设置<code>strictNullChecks</code>以后，赋值为<code>undefined</code>的变量会被推断为<code>undefined</code>类型，赋值为<code>null</code>的变量会被推断为<code>null</code>类型。</p><h2 id="包装对象类型" tabindex="-1"><a class="header-anchor" href="#包装对象类型"><span>包装对象类型</span></a></h2><h3 id="包装对象的概念" tabindex="-1"><a class="header-anchor" href="#包装对象的概念"><span>包装对象的概念</span></a></h3><p>JavaScript 的 8 种类型之中，<code>undefined</code>和<code>null</code>其实是两个特殊值，<code>object</code>属于复合类型，剩下的五种属于原始类型，代表最基本的、不可再分的值。</p><ul><li><code>boolean</code></li><li><code>string</code></li><li><code>number</code></li><li><code>bigint</code></li><li><code>symbol</code></li></ul><p>上面这五种原始类型的值，都有对应的包装对象。所谓“包装对象”，指的是这些值在需要时，会自动产生的对象。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#ADDCFF;">&#39;hello&#39;</span><span style="color:#F0F3F6;">.</span><span style="color:#DBB7FF;">charAt</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">) </span><span style="color:#BDC4CC;">// &#39;e&#39;</span></span></code></pre></div><p>上面示例中，字符串<code>hello</code>执行了<code>charAt()</code>方法。但是，在 JavaScript 语言中，只有对象才有方法，原始类型的值本身没有方法。这行代码之所以可以运行，就是因为在调用方法时，字符串会自动转为包装对象，<code>charAt()</code>方法其实是定义在包装对象上。</p><p>这样的设计大大方便了字符串处理，省去了将原始类型的值手动转成对象实例的麻烦。</p><p>五种包装对象之中，<code>symbol</code>类型和<code>bigint</code>类型无法直接获取它们的包装对象（即S<code>ymbol()</code>和<code>BigInt()</code>不能作为构造函数使用），但是剩下三种可以。</p><ul><li><code>Boolean()</code></li><li><code>String()</code></li><li><code>Number()</code></li></ul><p>以上三个构造函数，执行后可以直接获取某个原始类型值的包装对象。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> s</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> String</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;hello&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#FF9492;">typeof</span><span style="color:#F0F3F6;"> s </span><span style="color:#BDC4CC;">// &#39;object&#39;</span></span>
<span class="line"><span style="color:#F0F3F6;">s.</span><span style="color:#DBB7FF;">charAt</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">) </span><span style="color:#BDC4CC;">// &#39;e&#39;</span></span></code></pre></div><p>上面示例中，<code>s</code>就是字符串<code>hello</code>的包装对象，<code>typeof</code>运算符返回<code>object</code>，不是<code>string</code>，但是本质上它还是字符串，可以使用所有的字符串方法。</p><p>注意，<code>String()</code>只有当作构造函数使用时（即带有<code>new</code>命令调用），才会返回包装对象。如果当作普通函数使用（不带有<code>new</code>命令），返回就是一个普通字符串。其他两个构造函数<code>Number()</code>和<code>Boolean()</code>也是如此。</p><h3 id="包装对象类型与字面量类型" tabindex="-1"><a class="header-anchor" href="#包装对象类型与字面量类型"><span>包装对象类型与字面量类型</span></a></h3><p>由于包装对象的存在，导致每一个原始类型的值都有包装对象和字面量两种情况。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#ADDCFF;">&#39;hello&#39;</span><span style="color:#BDC4CC;"> // 字面量</span></span>
<span class="line"><span style="color:#FF9492;">new</span><span style="color:#DBB7FF;"> String</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;hello&#39;</span><span style="color:#F0F3F6;">) </span><span style="color:#BDC4CC;">// 包装对象</span></span></code></pre></div><p>上面示例中，第一行是字面量，第二行是包装对象，它们都是字符串。</p><p>为了区分这两种情况，TypeScript 对五种原始类型分别提供了大写和小写两种类型。</p><ul><li><code>Boolean</code>和<code>boolean</code></li><li><code>String</code>和<code>string</code></li><li><code>Number</code>和<code>number</code></li><li><code>BigInt</code>和<code>bigint</code></li><li><code>Symbol</code>和<code>symbol</code></li></ul><p>其中，大写类型同时包含包装对象和字面量两种情况，小写类型只包含字面量，不包含包装对象。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> s1</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;">String</span><span style="color:#FF9492;"> =</span><span style="color:#ADDCFF;"> &#39;hello&#39;</span><span style="color:#BDC4CC;"> // 正确</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> s2</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;">String</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> String</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;hello&#39;</span><span style="color:#F0F3F6;">) </span><span style="color:#BDC4CC;">// 正确</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> s3</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">string</span><span style="color:#FF9492;"> =</span><span style="color:#ADDCFF;"> &#39;hello&#39;</span><span style="color:#BDC4CC;"> // 正确</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> s4</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">string</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> String</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;hello&#39;</span><span style="color:#F0F3F6;">) </span><span style="color:#BDC4CC;">// 报错</span></span></code></pre></div><p>上面示例中，<code>String</code>类型可以赋值为字符串的字面量，也可以赋值为包装对象。但是，<code>string</code>类型只能赋值为字面量，赋值为包装对象就会报错。</p><p>建议只使用小写类型，不使用大写类型。因为绝大部分使用原始类型的场合，都是使用字面量，不使用包装对象。而且，TypeScript 把很多内置方法的参数，定义成小写类型，使用大写类型会报错。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> n1</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">number</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> 1</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> n2</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;">Number</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> 1</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">Math.</span><span style="color:#DBB7FF;">abs</span><span style="color:#F0F3F6;">(n1) </span><span style="color:#BDC4CC;">// 1</span></span>
<span class="line"><span style="color:#F0F3F6;">Math.</span><span style="color:#DBB7FF;">abs</span><span style="color:#F0F3F6;">(n2) </span><span style="color:#BDC4CC;">// 报错</span></span></code></pre></div><p>上面示例中，<code>Math.abs()</code>方法的参数类型被定义成小写的<code>number</code>，传入大写的<code>Number</code>类型就会报错。</p><p><code>Symbol()</code>和<code>BigInt()</code>这两个函数不能当作构造函数使用，所以没有办法直接获得<code>symbol</code>类型和<code>bigint</code>类型的包装对象，除非使用下面的写法。但是，它们没有使用场景，因此<code>Symbol</code>和<code>BigInt</code>这两个类型虽然存在，但是完全没有使用的理由。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> a </span><span style="color:#FF9492;">=</span><span style="color:#DBB7FF;"> Object</span><span style="color:#F0F3F6;">(</span><span style="color:#DBB7FF;">Symbol</span><span style="color:#F0F3F6;">())</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> b </span><span style="color:#FF9492;">=</span><span style="color:#DBB7FF;"> Object</span><span style="color:#F0F3F6;">(</span><span style="color:#DBB7FF;">BigInt</span><span style="color:#F0F3F6;">())</span></span></code></pre></div><p>上面示例中，得到的就是<code>Symbol</code>和<code>BigInt</code>的包装对象，但是没有使用的意义。</p><div class="hint-container warning"><p class="hint-container-title">注意</p><p>目前在 TypeScript 里面，<code>symbol</code>和<code>Symbol</code>两种写法没有差异，<code>bigint</code>和<code>BigInt</code>也是如此，不知道是否属于官方的疏忽。建议始终使用小写的<code>symbol</code>和<code>bigint</code>，不使用大写的<code>Symbol</code>和<code>BigInt</code>。</p></div><h2 id="object-类型与-object-类型" tabindex="-1"><a class="header-anchor" href="#object-类型与-object-类型"><span>Object 类型与 object 类型</span></a></h2><p>TypeScript 的对象类型也有大写<code>Object</code>和小写<code>object</code>两种。</p><h3 id="object-类型-1" tabindex="-1"><a class="header-anchor" href="#object-类型-1"><span>Object 类型</span></a></h3><p>大写的<code>Object</code>类型代表 JavaScript 语言里面的广义对象。所有可以转成对象的值，都是<code>Object</code>类型，这囊括了几乎所有的值。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> obj</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;">Object</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">obj </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> true</span></span>
<span class="line"><span style="color:#F0F3F6;">obj </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &#39;hi&#39;</span></span>
<span class="line"><span style="color:#F0F3F6;">obj </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 1</span></span>
<span class="line"><span style="color:#F0F3F6;">obj </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> { foo: </span><span style="color:#91CBFF;">123</span><span style="color:#F0F3F6;"> }</span></span>
<span class="line"><span style="color:#F0F3F6;">obj </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [</span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">]</span></span>
<span class="line"><span style="color:#DBB7FF;">obj</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> (</span><span style="color:#FFB757;">a</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">number</span><span style="color:#F0F3F6;">) </span><span style="color:#FF9492;">=&gt;</span><span style="color:#F0F3F6;"> a </span><span style="color:#FF9492;">+</span><span style="color:#91CBFF;"> 1</span></span></code></pre></div><p>上面示例中，原始类型值、对象、数组、函数都是合法的<code>Object</code>类型。</p><p>事实上，除了<code>undefined</code>和<code>null</code>这两个值不能转为对象，其他任何值都可以赋值给<code>Object</code>类型。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> obj</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;">Object</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">obj </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> undefined</span><span style="color:#F0F3F6;">; </span><span style="color:#BDC4CC;">// 报错</span></span>
<span class="line"><span style="color:#F0F3F6;">obj </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> null</span><span style="color:#F0F3F6;">; </span><span style="color:#BDC4CC;">// 报错</span></span></code></pre></div><p>另外，空对象<code>{}</code>是<code>Object</code>类型的简写形式，所以使用<code>Object</code>时常常用空对象代替。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> obj</span><span style="color:#FF9492;">:</span><span style="color:#F0F3F6;">{}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">obj </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> true</span></span>
<span class="line"><span style="color:#F0F3F6;">obj </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &#39;hi&#39;</span></span>
<span class="line"><span style="color:#F0F3F6;">obj </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 1</span></span>
<span class="line"><span style="color:#F0F3F6;">obj </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> { foo: </span><span style="color:#91CBFF;">123</span><span style="color:#F0F3F6;"> }</span></span>
<span class="line"><span style="color:#F0F3F6;">obj </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [</span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">]</span></span>
<span class="line"><span style="color:#DBB7FF;">obj</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> (</span><span style="color:#FFB757;">a</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">number</span><span style="color:#F0F3F6;">) </span><span style="color:#FF9492;">=&gt;</span><span style="color:#F0F3F6;"> a </span><span style="color:#FF9492;">+</span><span style="color:#91CBFF;"> 1</span></span></code></pre></div><p>上面示例中，变量<code>obj</code>的类型是空对象<code>{}</code>，就代表<code>Object</code>类型。</p><p>显然，无所不包的<code>Object</code>类型既不符合直觉，也不方便使用。</p><h3 id="object-类型-2" tabindex="-1"><a class="header-anchor" href="#object-类型-2"><span>object 类型</span></a></h3><p>小写的<code>object</code>类型代表 JavaScript 里面的狭义对象，即可以用字面量表示的对象，只包含对象、数组和函数，不包括原始类型的值。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> obj</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">object</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">obj </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> { foo: </span><span style="color:#91CBFF;">123</span><span style="color:#F0F3F6;"> }</span></span>
<span class="line"><span style="color:#F0F3F6;">obj </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [</span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">]</span></span>
<span class="line"><span style="color:#DBB7FF;">obj</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> (</span><span style="color:#FFB757;">a</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">number</span><span style="color:#F0F3F6;">) </span><span style="color:#FF9492;">=&gt;</span><span style="color:#F0F3F6;"> a </span><span style="color:#FF9492;">+</span><span style="color:#91CBFF;"> 1</span></span>
<span class="line"><span style="color:#F0F3F6;">obj </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> true</span><span style="color:#BDC4CC;"> // 报错</span></span>
<span class="line"><span style="color:#F0F3F6;">obj </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &#39;hi&#39;</span><span style="color:#BDC4CC;"> // 报错</span></span>
<span class="line"><span style="color:#F0F3F6;">obj </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 1</span><span style="color:#BDC4CC;"> // 报错</span></span></code></pre></div><p>上面示例中，<code>object</code>类型不包含原始类型值，只包含对象、数组和函数。</p><p>大多数时候，我们使用对象类型，只希望包含真正的对象，不希望包含原始类型。所以，建议总是使用小写类型<code>object</code>，不使用大写类型<code>Object</code>。</p><p>注意，无论是大写的<code>Object</code>类型，还是小写的<code>object</code>类型，都只包含 JavaScript 内置对象原生的属性和方法，用户自定义的属性和方法都不存在于这两个类型之中。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> o1</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;">Object</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> { foo: </span><span style="color:#91CBFF;">0</span><span style="color:#F0F3F6;"> }</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> o2</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">object</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> { foo: </span><span style="color:#91CBFF;">0</span><span style="color:#F0F3F6;"> }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">o1.</span><span style="color:#DBB7FF;">toString</span><span style="color:#F0F3F6;">() </span><span style="color:#BDC4CC;">// 正确</span></span>
<span class="line"><span style="color:#F0F3F6;">o1.foo </span><span style="color:#BDC4CC;">// 报错</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">o2.</span><span style="color:#DBB7FF;">toString</span><span style="color:#F0F3F6;">() </span><span style="color:#BDC4CC;">// 正确</span></span>
<span class="line"><span style="color:#F0F3F6;">o2.foo </span><span style="color:#BDC4CC;">// 报错</span></span></code></pre></div><p>上面示例中，<code>toString()</code>是对象的原生方法，可以正确访问。<code>foo</code>是自定义属性，访问就会报错。</p><h2 id="undefined-和-null-的特殊性" tabindex="-1"><a class="header-anchor" href="#undefined-和-null-的特殊性"><span>undefined 和 null 的特殊性</span></a></h2><p><code>undefined</code>和<code>null</code>既是值，又是类型。</p><p>作为值，它们有一个特殊的地方：任何其他类型的变量都可以赋值为<code>undefined</code>或<code>null</code>。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> age</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">number</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> 24</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">age </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> null</span><span style="color:#BDC4CC;">      // 正确</span></span>
<span class="line"><span style="color:#F0F3F6;">age </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> undefined</span><span style="color:#BDC4CC;"> // 正确</span></span></code></pre></div><p>上面代码中，变量<code>age</code>的类型是<code>number</code>，但是赋值为<code>null</code>或<code>undefined</code>并不报错。</p><p>这并不是因为<code>undefined</code>和<code>null</code>包含在<code>number</code>类型里面，而是故意这样设计，任何类型的变量都可以赋值为<code>undefined</code>和<code>null</code>，以便跟 JavaScript 的行为保持一致。</p><p>JavaScript 的行为是，变量如果等于<code>undefined</code>就表示还没有赋值，如果等于<code>null</code>就表示值为空。所以，TypeScript 就允许了任何类型的变量都可以赋值为这两个值。</p><p>但是有时候，这并不是开发者想要的行为，也不利于发挥类型系统的优势。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> obj</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">object</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> undefined</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">obj.</span><span style="color:#DBB7FF;">toString</span><span style="color:#F0F3F6;">() </span><span style="color:#BDC4CC;">// 编译不报错，运行就报错</span></span></code></pre></div><p>上面示例中，变量<code>obj</code>等于<code>undefined</code>，编译不会报错。但是，实际执行时，调用<code>obj.toString()</code>就报错了，因为<code>undefined</code>不是对象，没有这个方法。</p><p>为了避免这种情况，及早发现错误，TypeScript 提供了一个编译选项<code>strictNullChecks</code>。只要打开这个选项，<code>undefined</code>和<code>null</code>就不能赋值给其他类型的变量（除了<code>any</code>类型和<code>unknown</code>类型）。</p><p>下面是 tsc 命令打开这个编译选项的例子。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">// tsc --strictNullChecks app.ts</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> age</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">number</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> 24</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">age </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> null</span><span style="color:#F0F3F6;">;      </span><span style="color:#BDC4CC;">// 报错</span></span>
<span class="line"><span style="color:#F0F3F6;">age </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> undefined</span><span style="color:#F0F3F6;">; </span><span style="color:#BDC4CC;">// 报错</span></span></code></pre></div><p>上面示例中，打开<code>--strictNullChecks</code>以后，<code>number</code>类型的变量<code>age</code>就不能赋值为<code>undefined</code>和<code>null</code>。</p><p>这个选项在配置文件<code>tsconfig.json</code>的写法如下。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">{</span></span>
<span class="line"><span style="color:#ADDCFF;">  &quot;compilerOptions&quot;</span><span style="color:#F0F3F6;">: {</span></span>
<span class="line"><span style="color:#ADDCFF;">    &quot;strictNullChecks&quot;</span><span style="color:#F0F3F6;">: </span><span style="color:#91CBFF;">true</span></span>
<span class="line"><span style="color:#BDC4CC;">    // ...</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>打开<code>strictNullChecks</code>以后，<code>undefined</code>和<code>null</code>这两种值也不能互相赋值了。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">// 打开 strictNullChecks</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> x</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">undefined</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> null</span><span style="color:#F0F3F6;">; </span><span style="color:#BDC4CC;">// 报错</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> y</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">null</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> undefined</span><span style="color:#F0F3F6;">; </span><span style="color:#BDC4CC;">// 报错</span></span></code></pre></div><p>上面示例中，<code>undefined</code>类型的变量赋值为<code>null</code>，或者<code>null</code>类型的变量赋值为<code>undefined</code>，都会报错。</p><p>总之，打开<code>strictNullChecks</code>以后，<code>undefined</code>和<code>null</code>只能赋值给自身，或者<code>any</code>类型和<code>unknown</code>类型的变量。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> x</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">any</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> undefined</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> y</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">unknown</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> null</span><span style="color:#F0F3F6;">;</span></span></code></pre></div><h2 id="值类型" tabindex="-1"><a class="header-anchor" href="#值类型"><span>值类型</span></a></h2><p>TypeScript 规定，单个值也是一种类型，称为“值类型”。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> x</span><span style="color:#FF9492;">:</span><span style="color:#ADDCFF;">&#39;hello&#39;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">x </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &#39;hello&#39;</span><span style="color:#F0F3F6;">; </span><span style="color:#BDC4CC;">// 正确</span></span>
<span class="line"><span style="color:#F0F3F6;">x </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &#39;world&#39;</span><span style="color:#F0F3F6;">; </span><span style="color:#BDC4CC;">// 报错</span></span></code></pre></div><p>上面示例中，变量<code>x</code>的类型是字符串<code>hello</code>，导致它只能赋值为这个字符串，赋值为其他字符串就会报错。</p><p>TypeScript 推断类型时，遇到<code>const</code>命令声明的变量，如果代码里面没有注明类型，就会推断该变量是值类型。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">// x 的类型是 &quot;https&quot;</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> x</span><span style="color:#FF9492;"> =</span><span style="color:#ADDCFF;"> &#39;https&#39;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;">// y 的类型是 string</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> y</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">string</span><span style="color:#FF9492;"> =</span><span style="color:#ADDCFF;"> &#39;https&#39;</span><span style="color:#F0F3F6;">;</span></span></code></pre></div><p>上面示例中，变量<code>x</code>是<code>const</code>命令声明的，TypeScript 就会推断它的类型是值<code>https</code>，而不是<code>string</code>类型。</p><p>这样推断是合理的，因为<code>const</code>命令声明的变量，一旦声明就不能改变，相当于常量。值类型就意味着不能赋为其他值。</p><p>注意，<code>const</code>命令声明的变量，如果赋值为对象，并不会推断为值类型。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">// x 的类型是 { foo: number }</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> x</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> { foo: </span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;"> }</span></span></code></pre></div><p>上面示例中，变量x没有被推断为值类型，而是推断属性foo的类型是number。这是因为 JavaScript 里面，const变量赋值为对象时，属性值是可以改变的。</p><p>值类型可能会出现一些很奇怪的报错。</p><p>const x:5 = 4 + 1; // 报错<br> 上面示例中，等号左侧的类型是数值5，等号右侧4 + 1的类型，TypeScript 推测为number。由于5是number的子类型，number是5的父类型，父类型不能赋值给子类型，所以报错了（详见本章后文）。</p><p>但是，反过来是可以的，子类型可以赋值给父类型。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> x</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">5</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> 5</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> y</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">number</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> 4</span><span style="color:#FF9492;"> +</span><span style="color:#91CBFF;"> 1</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">x </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> y; </span><span style="color:#BDC4CC;">// 报错</span></span>
<span class="line"><span style="color:#F0F3F6;">y </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> x; </span><span style="color:#BDC4CC;">// 正确</span></span></code></pre></div><p>上面示例中，变量<code>x</code>属于子类型，变量<code>y</code>属于父类型。子类型<code>x</code>不能赋值为父类型<code>y</code>，但是反过来是可以的。</p><p>如果一定要让子类型可以赋值为父类型的值，就要用到类型断言。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> x</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">5</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> (</span><span style="color:#91CBFF;">4</span><span style="color:#FF9492;"> +</span><span style="color:#91CBFF;"> 1</span><span style="color:#F0F3F6;">) </span><span style="color:#FF9492;">as</span><span style="color:#91CBFF;"> 5</span><span style="color:#F0F3F6;">; </span><span style="color:#BDC4CC;">// 正确</span></span></code></pre></div><p>上面示例中，在<code>4+1</code>后面加上<code>as 5</code>，就是告诉编译器，可以把<code>4+1</code>的类型视为值类型 5，这样就不会报错了。</p><p>只包含单个值的值类型，用处不大。实际开发中，往往将多个值结合，作为联合类型使用。</p><h2 id="联合类型" tabindex="-1"><a class="header-anchor" href="#联合类型"><span>联合类型</span></a></h2><p>联合类型指的是多个类型组成的一个新类型，使用符号<code>|</code>表示。</p><p>联合类型<code>A|B</code>表示，任何一个类型只要属于<code>A</code>或<code>B</code>，就属于联合类型<code>A|B</code>。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> x</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">string</span><span style="color:#FF9492;">|</span><span style="color:#91CBFF;">number</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">x </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 123</span><span style="color:#BDC4CC;"> // 正确</span></span>
<span class="line"><span style="color:#F0F3F6;">x </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &#39;abc&#39;</span><span style="color:#BDC4CC;"> // 正确</span></span></code></pre></div><p>上面示例中，变量<code>x</code>就是联合类型<code>string|number</code>，表示它的值既可以是字符串，也可以是数值。</p><p>联合类型可以与值类型相结合，表示一个变量的值有若干种可能。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> setting</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">true</span><span style="color:#FF9492;">|</span><span style="color:#91CBFF;">false</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> gender</span><span style="color:#FF9492;">:</span><span style="color:#ADDCFF;">&#39;male&#39;</span><span style="color:#FF9492;">|</span><span style="color:#ADDCFF;">&#39;female&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> rainbowColor</span><span style="color:#FF9492;">:</span><span style="color:#ADDCFF;">&#39;赤&#39;</span><span style="color:#FF9492;">|</span><span style="color:#ADDCFF;">&#39;橙&#39;</span><span style="color:#FF9492;">|</span><span style="color:#ADDCFF;">&#39;黄&#39;</span><span style="color:#FF9492;">|</span><span style="color:#ADDCFF;">&#39;绿&#39;</span><span style="color:#FF9492;">|</span><span style="color:#ADDCFF;">&#39;青&#39;</span><span style="color:#FF9492;">|</span><span style="color:#ADDCFF;">&#39;蓝&#39;</span><span style="color:#FF9492;">|</span><span style="color:#ADDCFF;">&#39;紫&#39;</span></span></code></pre></div><p>上面的示例都是由值类型组成的联合类型，非常清晰地表达了变量的取值范围。其中，<code>true|false</code>其实就是布尔类型<code>boolean</code>。</p><p>前面提到，打开编译选项<code>strictNullChecks</code>后，其他类型的变量不能赋值为<code>undefined</code>或<code>null</code>。这时，如果某个变量确实可能包含空值，就可以采用联合类型的写法。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> name</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">string</span><span style="color:#FF9492;">|</span><span style="color:#91CBFF;">null</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">name </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &#39;John&#39;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">name </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> null</span><span style="color:#F0F3F6;">;</span></span></code></pre></div><p>上面示例中，变量<code>name</code>的值可以是字符串，也可以是<code>null</code>。</p><p>联合类型的第一个成员前面，也可以加上竖杠<code>|</code>，这样便于多行书写。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> x</span><span style="color:#FF9492;">:</span></span>
<span class="line"><span style="color:#FF9492;">|</span><span style="color:#ADDCFF;"> &#39;one&#39;</span></span>
<span class="line"><span style="color:#FF9492;">|</span><span style="color:#ADDCFF;"> &#39;two&#39;</span></span>
<span class="line"><span style="color:#FF9492;">|</span><span style="color:#ADDCFF;"> &#39;three&#39;</span></span>
<span class="line"><span style="color:#FF9492;">|</span><span style="color:#ADDCFF;"> &#39;four&#39;</span><span style="color:#F0F3F6;">;</span></span></code></pre></div><p>如果一个变量有多种类型，读取该变量时，往往需要进行“类型缩小”，区分该值到底属于哪一种类型，然后再进一步处理。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">function</span><span style="color:#DBB7FF;"> printId</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">id</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">number</span><span style="color:#FF9492;">|</span><span style="color:#91CBFF;">string</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#F0F3F6;">    console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(id.</span><span style="color:#DBB7FF;">toUpperCase</span><span style="color:#F0F3F6;">()); </span><span style="color:#BDC4CC;">// 报错</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面示例中，参数变量<code>id</code>可能是数值，也可能是字符串，这时直接对这个变量调用<code>toUpperCase()</code>方法会报错，因为这个方法只存在于字符串，不存在于数值。</p><p>解决方法就是对参数<code>id</code>做一下类型缩小，确定它的类型以后再进行处理。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">function</span><span style="color:#DBB7FF;"> printId</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">id</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">number</span><span style="color:#FF9492;">|</span><span style="color:#91CBFF;">string</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#FF9492;">  if</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">typeof</span><span style="color:#F0F3F6;"> id </span><span style="color:#FF9492;">===</span><span style="color:#ADDCFF;"> &#39;string&#39;</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#F0F3F6;">    console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(id.</span><span style="color:#DBB7FF;">toUpperCase</span><span style="color:#F0F3F6;">());</span></span>
<span class="line"><span style="color:#F0F3F6;">  } </span><span style="color:#FF9492;">else</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">    console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(id);</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面示例中，函数体内部会判断一下变量<code>id</code>的类型，如果是字符串，就对其执行<code>toUpperCase()</code>方法。</p><p>“类型缩小”是 TypeScript 处理联合类型的标准方法，凡是遇到可能为多种类型的场合，都需要先缩小类型，再进行处理。实际上，联合类型本身可以看成是一种“类型放大”，处理时就需要“类型缩小”。</p><p>下面是“类型缩小”的另一个例子。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">function</span><span style="color:#DBB7FF;"> getPort</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">scheme</span><span style="color:#FF9492;">:</span><span style="color:#ADDCFF;"> &#39;http&#39;</span><span style="color:#FF9492;">|</span><span style="color:#ADDCFF;">&#39;https&#39;</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#FF9492;">  switch</span><span style="color:#F0F3F6;"> (scheme) {</span></span>
<span class="line"><span style="color:#FF9492;">    case</span><span style="color:#ADDCFF;"> &#39;http&#39;</span><span style="color:#F0F3F6;">:</span></span>
<span class="line"><span style="color:#FF9492;">      return</span><span style="color:#91CBFF;"> 80</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">    case</span><span style="color:#ADDCFF;"> &#39;https&#39;</span><span style="color:#F0F3F6;">:</span></span>
<span class="line"><span style="color:#FF9492;">      return</span><span style="color:#91CBFF;"> 443</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面示例中，函数体内部对参数变量<code>scheme</code>进行类型缩小，根据不同的值类型，返回不同的结果。</p><h2 id="交叉类型" tabindex="-1"><a class="header-anchor" href="#交叉类型"><span>交叉类型</span></a></h2><p>交叉类型指的多个类型组成的一个新类型，使用符号<code>&amp;</code>表示。</p><p>交叉类型<code>A&amp;B</code>表示，任何一个类型必须同时属于<code>A</code>和<code>B</code>，才属于交叉类型<code>A&amp;B</code>，即交叉类型同时满足<code>A</code>和<code>B</code>的特征。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> x</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">number</span><span style="color:#FF9492;">&amp;</span><span style="color:#91CBFF;">string</span><span style="color:#F0F3F6;">;</span></span></code></pre></div><p>上面示例中，变量<code>x</code>同时是数值和字符串，这当然是不可能的，所以 TypeScript 会认为<code>x</code>的类型实际是<code>never</code>。</p><p>交叉类型的主要用途是表示对象的合成。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> obj</span><span style="color:#FF9492;">:</span></span>
<span class="line"><span style="color:#F0F3F6;">  { </span><span style="color:#FFB757;">foo</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> string</span><span style="color:#F0F3F6;"> } </span><span style="color:#FF9492;">&amp;</span></span>
<span class="line"><span style="color:#F0F3F6;">  { </span><span style="color:#FFB757;">bar</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> string</span><span style="color:#F0F3F6;"> };</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">obj </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">  foo: </span><span style="color:#ADDCFF;">&#39;hello&#39;</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#F0F3F6;">  bar: </span><span style="color:#ADDCFF;">&#39;world&#39;</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span></code></pre></div><p>上面示例中，变量<code>obj</code>同时具有属性<code>foo</code>和属性<code>bar</code>。</p><p>交叉类型常常用来为对象类型添加新属性。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">type</span><span style="color:#FFB757;"> A</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> { </span><span style="color:#FFB757;">foo</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> number</span><span style="color:#F0F3F6;"> };</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">type</span><span style="color:#FFB757;"> B</span><span style="color:#FF9492;"> =</span><span style="color:#FFB757;"> A</span><span style="color:#FF9492;"> &amp;</span><span style="color:#F0F3F6;"> { </span><span style="color:#FFB757;">bar</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> number</span><span style="color:#F0F3F6;"> };</span></span></code></pre></div><p>上面示例中，类型<code>B</code>是一个交叉类型，用来在<code>A</code>的基础上增加了属性<code>bar</code>。</p><h2 id="type-命令" tabindex="-1"><a class="header-anchor" href="#type-命令"><span>type 命令</span></a></h2><p><code>type</code>命令用来定义一个类型的别名。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">type</span><span style="color:#FFB757;"> Age</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> number</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> age</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;">Age</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> 55</span><span style="color:#F0F3F6;">;</span></span></code></pre></div><p>上面示例中，<code>type</code>命令为<code>number</code>类型定义了一个别名<code>Age</code>。这样就能像使用<code>number</code>一样，使用<code>Age</code>作为类型。</p><p>别名可以让类型的名字变得更有意义，也能增加代码的可读性，还可以使复杂类型用起来更方便，便于以后修改变量的类型。</p><p>别名不允许重名。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">type</span><span style="color:#FFB757;"> Color</span><span style="color:#FF9492;"> =</span><span style="color:#ADDCFF;"> &#39;red&#39;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">type</span><span style="color:#FFB757;"> Color</span><span style="color:#FF9492;"> =</span><span style="color:#ADDCFF;"> &#39;blue&#39;</span><span style="color:#F0F3F6;">; </span><span style="color:#BDC4CC;">// 报错</span></span></code></pre></div><p>上面示例中，同一个别名<code>Color</code>声明了两次，就报错了。</p><p>别名的作用域是块级作用域。这意味着，代码块内部定义的别名，影响不到外部。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">type</span><span style="color:#FFB757;"> Color</span><span style="color:#FF9492;"> =</span><span style="color:#ADDCFF;"> &#39;red&#39;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">if</span><span style="color:#F0F3F6;"> (Math.</span><span style="color:#DBB7FF;">random</span><span style="color:#F0F3F6;">() </span><span style="color:#FF9492;">&lt;</span><span style="color:#91CBFF;"> 0.5</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#FF9492;">  type</span><span style="color:#FFB757;"> Color</span><span style="color:#FF9492;"> =</span><span style="color:#ADDCFF;"> &#39;blue&#39;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面示例中，<code>if</code>代码块内部的类型别名<code>Color</code>，跟外部的<code>Color</code>是不一样的。</p><p>别名支持使用表达式，也可以在定义一个别名时，使用另一个别名，即别名允许嵌套。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">type</span><span style="color:#FFB757;"> World</span><span style="color:#FF9492;"> =</span><span style="color:#ADDCFF;"> &quot;world&quot;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">type</span><span style="color:#FFB757;"> Greeting</span><span style="color:#FF9492;"> =</span><span style="color:#ADDCFF;"> \`hello \${</span><span style="color:#FFB757;">World</span><span style="color:#ADDCFF;">}\`</span><span style="color:#F0F3F6;">;</span></span></code></pre></div><p>上面示例中，别名<code>Greeting</code>使用了模板字符串，读取另一个别名<code>World</code>。</p><p><code>type</code>命令属于类型相关的代码，编译成 JavaScript 的时候，会被全部删除。</p><h2 id="typeof-运算符" tabindex="-1"><a class="header-anchor" href="#typeof-运算符"><span>typeof 运算符</span></a></h2><p>JavaScript 语言中，<code>typeof</code>运算符是一个一元运算符，返回一个字符串，代表操作数的类型。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">typeof</span><span style="color:#ADDCFF;"> &#39;foo&#39;</span><span style="color:#F0F3F6;">; </span><span style="color:#BDC4CC;">// &#39;string&#39;</span></span></code></pre></div><p>注意，这时<code>typeof</code>的操作数是一个值。</p><p>JavaScript 里面，<code>typeof</code>运算符只可能返回八种结果，而且都是字符串。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">typeof</span><span style="color:#91CBFF;"> undefined</span><span style="color:#F0F3F6;">; </span><span style="color:#BDC4CC;">// &quot;undefined&quot;</span></span>
<span class="line"><span style="color:#FF9492;">typeof</span><span style="color:#91CBFF;"> true</span><span style="color:#F0F3F6;">; </span><span style="color:#BDC4CC;">// &quot;boolean&quot;</span></span>
<span class="line"><span style="color:#FF9492;">typeof</span><span style="color:#91CBFF;"> 1337</span><span style="color:#F0F3F6;">; </span><span style="color:#BDC4CC;">// &quot;number&quot;</span></span>
<span class="line"><span style="color:#FF9492;">typeof</span><span style="color:#ADDCFF;"> &quot;foo&quot;</span><span style="color:#F0F3F6;">; </span><span style="color:#BDC4CC;">// &quot;string&quot;</span></span>
<span class="line"><span style="color:#FF9492;">typeof</span><span style="color:#F0F3F6;"> {}; </span><span style="color:#BDC4CC;">// &quot;object&quot;</span></span>
<span class="line"><span style="color:#FF9492;">typeof</span><span style="color:#F0F3F6;"> parseInt; </span><span style="color:#BDC4CC;">// &quot;function&quot;</span></span>
<span class="line"><span style="color:#FF9492;">typeof</span><span style="color:#DBB7FF;"> Symbol</span><span style="color:#F0F3F6;">(); </span><span style="color:#BDC4CC;">// &quot;symbol&quot;</span></span>
<span class="line"><span style="color:#FF9492;">typeof</span><span style="color:#91CBFF;"> 127</span><span style="color:#FF9492;">n</span><span style="color:#BDC4CC;"> // &quot;bigint&quot;</span></span></code></pre></div><p>TypeScript 将<code>typeof</code>运算符移植到了类型运算，它的操作数依然是一个值，但是返回的不是字符串，而是该值的 TypeScript 类型。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> a</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> { x: </span><span style="color:#91CBFF;">0</span><span style="color:#F0F3F6;"> };</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">type</span><span style="color:#FFB757;"> T0</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> typeof</span><span style="color:#F0F3F6;"> a;   </span><span style="color:#BDC4CC;">// { x: number }</span></span>
<span class="line"><span style="color:#FF9492;">type</span><span style="color:#FFB757;"> T1</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> typeof</span><span style="color:#F0F3F6;"> a.x; </span><span style="color:#BDC4CC;">// number</span></span></code></pre></div><p>上面示例中，<code>typeof a</code>表示返回变量<code>a</code>的 TypeScript 类型（<code>{ x: number }</code>）。同理，<code>typeof a.x</code>返回的是属性<code>x</code>的类型（<code>number</code>）。</p><p>这种用法的<code>typeof</code>返回的是 TypeScript 类型，所以只能用在类型运算之中（即跟类型相关的代码之中），不能用在值运算。</p><p>也就是说，同一段代码可能存在两种<code>typeof</code>运算符，一种用在值相关的 JavaScript 代码部分，另一种用在类型相关的 TypeScript 代码部分。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> a </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 1</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> b</span><span style="color:#FF9492;">:typeof</span><span style="color:#F0F3F6;"> a;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">if</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">typeof</span><span style="color:#F0F3F6;"> a </span><span style="color:#FF9492;">===</span><span style="color:#ADDCFF;"> &#39;number&#39;</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#F0F3F6;">  b </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> a;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面示例中，用到了两个<code>typeof</code>，第一个是类型运算，第二个是值运算。它们是不一样的，不要混淆。</p><p>JavaScript 的<code>typeof</code>遵守 JavaScript 规则，TypeScript 的<code>typeof</code>遵守 TypeScript 规则。它们的一个重要区别在于，编译后，前者会保留，后者会被全部删除。</p><p>上例的代码编译结果如下。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> a </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 1</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> b;</span></span>
<span class="line"><span style="color:#FF9492;">if</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">typeof</span><span style="color:#F0F3F6;"> a </span><span style="color:#FF9492;">===</span><span style="color:#ADDCFF;"> &#39;number&#39;</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#F0F3F6;">    b </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> a;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面示例中，只保留了原始代码的第二个<code>typeof</code>，删除了第一个<code>typeof</code>。</p><p>由于编译时不会进行 JavaScript 的值运算，所以 TypeScript 规定，<code>typeof</code>的参数只能是标识符，不能是需要运算的表达式。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">type</span><span style="color:#FFB757;"> T</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> typeof</span><span style="color:#DBB7FF;"> Date</span><span style="color:#F0F3F6;">(); </span><span style="color:#BDC4CC;">// 报错</span></span></code></pre></div><p>上面示例会报错，原因是<code>typeof</code>的参数不能是一个值的运算式，而<code>Date()</code>需要运算才知道结果。</p><p>另外，<code>typeof</code>命令的参数不能是类型。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">type</span><span style="color:#FFB757;"> Age</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> number</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">type</span><span style="color:#FFB757;"> MyAge</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> typeof</span><span style="color:#F0F3F6;"> Age; </span><span style="color:#BDC4CC;">// 报错</span></span></code></pre></div><p>上面示例中，<code>Age</code>是一个类型别名，用作<code>typeof</code>命令的参数就会报错。</p><p><code>typeof</code>是一个很重要的 TypeScript 运算符，有些场合不知道某个变量<code>foo</code>的类型，这时使用<code>typeof foo</code>就可以获得它的类型。</p><h2 id="块级类型声明" tabindex="-1"><a class="header-anchor" href="#块级类型声明"><span>块级类型声明</span></a></h2><p>TypeScript 支持块级类型声明，即类型可以声明在代码块（用大括号表示）里面，并且只在当前代码块有效。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">if</span><span style="color:#F0F3F6;"> (</span><span style="color:#91CBFF;">true</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#FF9492;">  type</span><span style="color:#FFB757;"> T</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> number</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">  let</span><span style="color:#F0F3F6;"> v</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;">T</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> 5</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">} </span><span style="color:#FF9492;">else</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  type</span><span style="color:#FFB757;"> T</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> string</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">  let</span><span style="color:#F0F3F6;"> v</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;">T</span><span style="color:#FF9492;"> =</span><span style="color:#ADDCFF;"> &#39;hello&#39;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面示例中，存在两个代码块，其中分别有一个类型<code>T</code>的声明。这两个声明都只在自己的代码块内部有效，在代码块外部无效。</p><h2 id="类型的兼容" tabindex="-1"><a class="header-anchor" href="#类型的兼容"><span>类型的兼容</span></a></h2><p>TypeScript 的类型存在兼容关系，某些类型可以兼容其他类型。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">type</span><span style="color:#FFB757;"> T</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> number</span><span style="color:#FF9492;">|</span><span style="color:#91CBFF;">string</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> a</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">number</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> 1</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> b</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;">T</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> a;</span></span></code></pre></div><p>上面示例中，变量<code>a</code>和<code>b</code>的类型是不一样的，但是变量<code>a</code>赋值给变量<code>b</code>并不会报错。这时，我们就认为，<code>b</code>的类型兼容<code>a</code>的类型。</p><p>TypeScript 为这种情况定义了一个专门术语。如果类型<code>A</code>的值可以赋值给类型<code>B</code>，那么类型<code>A</code>就称为类型<code>B</code>的子类型。在上例中，类型<code>number</code>就是类型<code>number|string</code>的子类型。</p><p>TypeScript 的一个规则是，凡是可以使用父类型的地方，都可以使用子类型，但是反过来不行。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> a</span><span style="color:#FF9492;">:</span><span style="color:#ADDCFF;">&#39;hi&#39;</span><span style="color:#FF9492;"> =</span><span style="color:#ADDCFF;"> &#39;hi&#39;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> b</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">string</span><span style="color:#FF9492;"> =</span><span style="color:#ADDCFF;"> &#39;hello&#39;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">b </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> a; </span><span style="color:#BDC4CC;">// 正确</span></span>
<span class="line"><span style="color:#F0F3F6;">a </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> b; </span><span style="color:#BDC4CC;">// 报错</span></span></code></pre></div><p>上面示例中，<code>hi</code>是<code>string</code>的子类型，<code>string</code>是<code>hi</code>的父类型。所以，变量<code>a</code>可以赋值给变量<code>b</code>，但是反过来就会报错。</p><p>之所以有这样的规则，是因为子类型继承了父类型的所有特征，所以可以用在父类型的场合。但是，子类型还可能有一些父类型没有的特征，所以父类型不能用在子类型的场合。</p>`,264)]))}const r=a(p,[["render",e],["__file","ts数据类型.html.vue"]]),d=JSON.parse('{"path":"/js/ts/ts%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html","title":"","lang":"zh-CN","frontmatter":{"description":"TypeScript 继承了 JavaScript 的类型，在这个基础上，定义了一套自己的类型系统。 基本类型 概述 JavaScript 将值分成8种类型： boolean string number bigint symbol object undefined null TypeScript 继承了 JavaScript 的类型设计，以上 8 种类...","head":[["meta",{"property":"og:url","content":"https://0oWSQo0.github.io/wsq-blog/js/ts/ts%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html"}],["meta",{"property":"og:description","content":"TypeScript 继承了 JavaScript 的类型，在这个基础上，定义了一套自己的类型系统。 基本类型 概述 JavaScript 将值分成8种类型： boolean string number bigint symbol object undefined null TypeScript 继承了 JavaScript 的类型设计，以上 8 种类..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-09-11T05:57:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-09-11T05:57:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-09-11T05:57:00.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"WSQ\\",\\"url\\":\\"https://0oWSQo0.github.com\\"}]}"]]},"headers":[{"level":2,"title":"基本类型","slug":"基本类型","link":"#基本类型","children":[]},{"level":2,"title":"概述","slug":"概述","link":"#概述","children":[{"level":3,"title":"boolean 类型","slug":"boolean-类型","link":"#boolean-类型","children":[]},{"level":3,"title":"string 类型","slug":"string-类型","link":"#string-类型","children":[]},{"level":3,"title":"number 类型","slug":"number-类型","link":"#number-类型","children":[]},{"level":3,"title":"bigint 类型","slug":"bigint-类型","link":"#bigint-类型","children":[]},{"level":3,"title":"symbol 类型","slug":"symbol-类型","link":"#symbol-类型","children":[]},{"level":3,"title":"object 类型","slug":"object-类型","link":"#object-类型","children":[]},{"level":3,"title":"undefined 类型，null 类型","slug":"undefined-类型-null-类型","link":"#undefined-类型-null-类型","children":[]}]},{"level":2,"title":"包装对象类型","slug":"包装对象类型","link":"#包装对象类型","children":[{"level":3,"title":"包装对象的概念","slug":"包装对象的概念","link":"#包装对象的概念","children":[]},{"level":3,"title":"包装对象类型与字面量类型","slug":"包装对象类型与字面量类型","link":"#包装对象类型与字面量类型","children":[]}]},{"level":2,"title":"Object 类型与 object 类型","slug":"object-类型与-object-类型","link":"#object-类型与-object-类型","children":[{"level":3,"title":"Object 类型","slug":"object-类型-1","link":"#object-类型-1","children":[]},{"level":3,"title":"object 类型","slug":"object-类型-2","link":"#object-类型-2","children":[]}]},{"level":2,"title":"undefined 和 null 的特殊性","slug":"undefined-和-null-的特殊性","link":"#undefined-和-null-的特殊性","children":[]},{"level":2,"title":"值类型","slug":"值类型","link":"#值类型","children":[]},{"level":2,"title":"联合类型","slug":"联合类型","link":"#联合类型","children":[]},{"level":2,"title":"交叉类型","slug":"交叉类型","link":"#交叉类型","children":[]},{"level":2,"title":"type 命令","slug":"type-命令","link":"#type-命令","children":[]},{"level":2,"title":"typeof 运算符","slug":"typeof-运算符","link":"#typeof-运算符","children":[]},{"level":2,"title":"块级类型声明","slug":"块级类型声明","link":"#块级类型声明","children":[]},{"level":2,"title":"类型的兼容","slug":"类型的兼容","link":"#类型的兼容","children":[]}],"git":{"createdTime":1726034220000,"updatedTime":1726034220000,"contributors":[{"name":"WSQ","email":"592786982@qq.com","commits":1}]},"readingTime":{"minutes":22.76,"words":6828},"filePathRelative":"js/ts/ts数据类型.md","localizedDate":"2024年9月11日","autoDesc":true}');export{r as comp,d as data};
