import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,d as l,o as p}from"./app-ByvFWdWZ.js";const o={};function e(F,s){return p(),n("div",null,s[0]||(s[0]=[l(`<p>JavaScript 数组在 TypeScript 里面分成两种类型，分别是数组（<code>array</code>）和元组（<code>tuple</code>）。</p><h2 id="数组" tabindex="-1"><a class="header-anchor" href="#数组"><span>数组</span></a></h2><p>TypeScript 数组有一个根本特征：所有成员的类型必须相同，但是成员数量是不确定的，可以是无限数量的成员，也可以是零成员。</p><p>数组的类型有两种写法。第一种写法是在数组成员的类型后面，加上一对方括号。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> arr</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">number</span><span style="color:#F0F3F6;">[] </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [</span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">3</span><span style="color:#F0F3F6;">];</span></span></code></pre></div><p>上面示例中，数组<code>arr</code>的类型是<code>number[]</code>，其中<code>number</code>表示数组成员类型是<code>number</code>。</p><p>如果数组成员的类型比较复杂，可以写在圆括号里面。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> arr</span><span style="color:#FF9492;">:</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">number</span><span style="color:#FF9492;">|</span><span style="color:#91CBFF;">string</span><span style="color:#F0F3F6;">)[];</span></span></code></pre></div><p>上面示例中，数组<code>arr</code>的成员类型是<code>number|string</code>。</p><p>这个例子里面的圆括号是必须的，否则因为竖杠<code>|</code>的优先级低于<code>[]</code>，TypeScript 会把<code>number|string[]</code>理解成<code>number</code>和<code>string[]</code>的联合类型。</p><p>如果数组成员可以是任意类型，写成<code>any[]</code>。当然，这种写法是应该避免的。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> arr</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">any</span><span style="color:#F0F3F6;">[];</span></span></code></pre></div><p>数组类型的第二种写法是使用 TypeScript 内置的<code>Array</code>接口。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> arr</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;">Array</span><span style="color:#F0F3F6;">&lt;</span><span style="color:#91CBFF;">number</span><span style="color:#F0F3F6;">&gt; </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [</span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">3</span><span style="color:#F0F3F6;">];</span></span></code></pre></div><p>上面示例中，数组<code>arr</code>的类型是<code>Array&lt;number&gt;</code>，其中<code>number</code>表示成员类型是<code>number</code>。</p><p>这种写法对于成员类型比较复杂的数组，代码可读性会稍微好一些。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> arr</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;">Array</span><span style="color:#F0F3F6;">&lt;</span><span style="color:#91CBFF;">number</span><span style="color:#FF9492;">|</span><span style="color:#91CBFF;">string</span><span style="color:#F0F3F6;">&gt;;</span></span></code></pre></div><p>这种写法本质上属于泛型，这里只要知道怎么写就可以了。</p><p>数组类型声明了以后，成员数量是不限制的，任意数量的成员都可以，也可以是空数组。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> arr</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">number</span><span style="color:#F0F3F6;">[];</span></span>
<span class="line"><span style="color:#F0F3F6;">arr </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [];</span></span>
<span class="line"><span style="color:#F0F3F6;">arr </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [</span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">];</span></span>
<span class="line"><span style="color:#F0F3F6;">arr </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [</span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">];</span></span>
<span class="line"><span style="color:#F0F3F6;">arr </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [</span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">3</span><span style="color:#F0F3F6;">];</span></span></code></pre></div><p>上面示例中，数组<code>arr</code>无论有多少个成员，都是正确的。</p><p>这种规定的隐藏含义就是，数组的成员是可以动态变化的。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> arr</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">number</span><span style="color:#F0F3F6;">[] </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [</span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">3</span><span style="color:#F0F3F6;">];</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">arr[</span><span style="color:#91CBFF;">3</span><span style="color:#F0F3F6;">] </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 4</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">arr.</span><span style="color:#91CBFF;">length</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> 2</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">arr </span><span style="color:#BDC4CC;">// [1, 2]</span></span></code></pre></div><p>上面示例中，数组增加成员或减少成员，都是可以的。</p><p>正是由于成员数量可以动态变化，所以 TypeScript 不会对数组边界进行检查，越界访问数组并不会报错。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> arr</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">number</span><span style="color:#F0F3F6;">[] </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [</span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">3</span><span style="color:#F0F3F6;">];</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> foo </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> arr[</span><span style="color:#91CBFF;">3</span><span style="color:#F0F3F6;">]; </span><span style="color:#BDC4CC;">// 正确</span></span></code></pre></div><p>上面示例中，变量<code>foo</code>的值是一个不存在的数组成员，TypeScript 并不会报错。</p><p>TypeScript 允许使用方括号读取数组成员的类型。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">type</span><span style="color:#FFB757;"> Names</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> string</span><span style="color:#F0F3F6;">[];</span></span>
<span class="line"><span style="color:#FF9492;">type</span><span style="color:#FFB757;"> Name</span><span style="color:#FF9492;"> =</span><span style="color:#FFB757;"> Names</span><span style="color:#F0F3F6;">[</span><span style="color:#91CBFF;">0</span><span style="color:#F0F3F6;">]; </span><span style="color:#BDC4CC;">// string</span></span></code></pre></div><p>上面示例中，类型<code>Names</code>是字符串数组，那么<code>Names[0]</code>返回的类型就是<code>string</code>。</p><p>由于数组成员的索引类型都是<code>number</code>，所以读取成员类型也可以写成下面这样。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">type</span><span style="color:#FFB757;"> Names</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> string</span><span style="color:#F0F3F6;">[];</span></span>
<span class="line"><span style="color:#FF9492;">type</span><span style="color:#FFB757;"> Name</span><span style="color:#FF9492;"> =</span><span style="color:#FFB757;"> Names</span><span style="color:#F0F3F6;">[</span><span style="color:#91CBFF;">number</span><span style="color:#F0F3F6;">]; </span><span style="color:#BDC4CC;">// string</span></span></code></pre></div><p>上面示例中，<code>Names[number]</code>表示数组<code>Names</code>所有数值索引的成员类型，所以返回<code>string</code>。</p><h3 id="数组的类型推断" tabindex="-1"><a class="header-anchor" href="#数组的类型推断"><span>数组的类型推断</span></a></h3><p>如果数组变量没有声明类型，TypeScript 就会推断数组成员的类型。这时，推断行为会因为值的不同，而有所不同。</p><p>如果变量的初始值是空数组，那么 TypeScript 会推断数组类型是<code>any[]</code>。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">// 推断为 any[]</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> arr</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> [];</span></span></code></pre></div><p>后面，为这个数组赋值时，TypeScript 会自动更新类型推断。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> arr</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> [];</span></span>
<span class="line"><span style="color:#F0F3F6;">arr </span><span style="color:#BDC4CC;">// 推断为 any[]</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">arr.</span><span style="color:#DBB7FF;">push</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">123</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#F0F3F6;">arr </span><span style="color:#BDC4CC;">// 推断类型为 number[]</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">arr.</span><span style="color:#DBB7FF;">push</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;abc&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#F0F3F6;">arr </span><span style="color:#BDC4CC;">// 推断类型为 (string|number)[]</span></span></code></pre></div><p>上面示例中，数组变量<code>arr</code>的初始值是空数组，然后随着新成员的加入，TypeScript 会自动修改推断的数组类型。</p><p>但是，类型推断的自动更新只发生初始值为空数组的情况。如果初始值不是空数组，类型推断就不会更新。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">// 推断类型为 number[]</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> arr</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> [</span><span style="color:#91CBFF;">123</span><span style="color:#F0F3F6;">];</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">arr.</span><span style="color:#DBB7FF;">push</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;abc&#39;</span><span style="color:#F0F3F6;">); </span><span style="color:#BDC4CC;">// 报错</span></span></code></pre></div><p>上面示例中，数组变量<code>arr</code>的初始值是<code>[123]</code>，TypeScript 就推断成员类型为<code>number</code>。新成员如果不是这个类型，TypeScript 就会报错，而不会更新类型推断。</p><h3 id="只读数组-const-断言" tabindex="-1"><a class="header-anchor" href="#只读数组-const-断言"><span>只读数组，const 断言</span></a></h3><p>JavaScript 规定，<code>const</code>命令声明的数组变量是可以改变成员的。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> arr</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> [</span><span style="color:#91CBFF;">0</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">];</span></span>
<span class="line"><span style="color:#F0F3F6;">arr[</span><span style="color:#91CBFF;">0</span><span style="color:#F0F3F6;">] </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 2</span><span style="color:#F0F3F6;">;</span></span></code></pre></div><p>上面示例中，修改<code>const</code>命令声明的数组的成员是允许的。</p><p>但是，很多时候确实有声明为只读数组的需求，即不允许变动数组成员。</p><p>TypeScript 允许声明只读数组，方法是在数组类型前面加上<code>readonly</code>关键字。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> arr</span><span style="color:#FF9492;">:readonly</span><span style="color:#91CBFF;"> number</span><span style="color:#F0F3F6;">[] </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [</span><span style="color:#91CBFF;">0</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">];</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">arr[</span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">] </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 2</span><span style="color:#F0F3F6;">; </span><span style="color:#BDC4CC;">// 报错</span></span>
<span class="line"><span style="color:#F0F3F6;">arr.</span><span style="color:#DBB7FF;">push</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">3</span><span style="color:#F0F3F6;">); </span><span style="color:#BDC4CC;">// 报错</span></span>
<span class="line"><span style="color:#FF9492;">delete</span><span style="color:#F0F3F6;"> arr[</span><span style="color:#91CBFF;">0</span><span style="color:#F0F3F6;">]; </span><span style="color:#BDC4CC;">// 报错</span></span></code></pre></div><p>上面示例中，<code>arr</code>是一个只读数组，删除、修改、新增数组成员都会报错。</p><p>TypeScript 将<code>readonly number[]</code>与<code>number[]</code>视为两种不一样的类型，后者是前者的子类型。</p><p>这是因为只读数组没有<code>pop()、push()</code>之类会改变原数组的方法，所以<code>number[]</code>的方法数量要多于<code>readonly number[]</code>，这意味着<code>number[]</code>其实是<code>readonly number[]</code>的子类型。</p><p>我们知道，子类型继承了父类型的所有特征，并加上了自己的特征，所以子类型<code>number[]</code>可以用于所有使用父类型的场合，反过来就不行。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> a1</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">number</span><span style="color:#F0F3F6;">[] </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [</span><span style="color:#91CBFF;">0</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">];</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> a2</span><span style="color:#FF9492;">:readonly</span><span style="color:#91CBFF;"> number</span><span style="color:#F0F3F6;">[] </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> a1; </span><span style="color:#BDC4CC;">// 正确</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">a1 </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> a2; </span><span style="color:#BDC4CC;">// 报错</span></span></code></pre></div><p>上面示例中，子类型<code>number[]</code>可以赋值给父类型<code>readonly number[]</code>，但是反过来就会报错。</p><p>由于只读数组是数组的父类型，所以它不能代替数组。这一点很容易产生令人困惑的报错。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">function</span><span style="color:#DBB7FF;"> getSum</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">s</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">number</span><span style="color:#F0F3F6;">[]) {</span></span>
<span class="line"><span style="color:#BDC4CC;">// ...</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> arr</span><span style="color:#FF9492;">:readonly</span><span style="color:#91CBFF;"> number</span><span style="color:#F0F3F6;">[] </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [</span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">3</span><span style="color:#F0F3F6;">];</span></span>
<span class="line"></span>
<span class="line"><span style="color:#DBB7FF;">getSum</span><span style="color:#F0F3F6;">(arr) </span><span style="color:#BDC4CC;">// 报错</span></span></code></pre></div><p>上面示例中，函数<code>getSum()</code>的参数s是一个数组，传入只读数组就会报错。原因就是只读数组是数组的父类型，父类型不能替代子类型。这个问题的解决方法是使用类型断言getSum(arr as number[])，详见《类型断言》一章。</p><p>注意，<code>readonly</code>关键字不能与数组的泛型写法一起使用。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">// 报错</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> arr</span><span style="color:#FF9492;">:readonly</span><span style="color:#FFB757;"> Array</span><span style="color:#F0F3F6;">&lt;</span><span style="color:#91CBFF;">number</span><span style="color:#F0F3F6;">&gt; </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [</span><span style="color:#91CBFF;">0</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">];</span></span></code></pre></div><p>上面示例中，<code>readonly</code>与数组的泛型写法一起使用，就会报错。</p><p>实际上，TypeScript 提供了两个专门的泛型，用来生成只读数组的类型。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> a1</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;">ReadonlyArray</span><span style="color:#F0F3F6;">&lt;</span><span style="color:#91CBFF;">number</span><span style="color:#F0F3F6;">&gt; </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [</span><span style="color:#91CBFF;">0</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">];</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> a2</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;">Readonly</span><span style="color:#F0F3F6;">&lt;</span><span style="color:#91CBFF;">number</span><span style="color:#F0F3F6;">[]&gt; </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [</span><span style="color:#91CBFF;">0</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">];</span></span></code></pre></div><p>上面示例中，泛型<code>ReadonlyArray&lt;T&gt;</code>和<code>Readonly&lt;T[]&gt;</code>都可以用来生成只读数组类型。两者尖括号里面的写法不一样，<code>Readonly&lt;T[]&gt;</code>的尖括号里面是整个数组（<code>number[]</code>），而<code>ReadonlyArray&lt;T&gt;</code>的尖括号里面是数组成员（<code>number</code>）。</p><p>只读数组还有一种声明方法，就是使用“<code>const</code>断言”。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> arr</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> [</span><span style="color:#91CBFF;">0</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">] </span><span style="color:#FF9492;">as</span><span style="color:#FF9492;"> const</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">arr[</span><span style="color:#91CBFF;">0</span><span style="color:#F0F3F6;">] </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [</span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">]; </span><span style="color:#BDC4CC;">// 报错</span></span></code></pre></div><p>上面示例中，<code>as const</code>告诉 TypeScript，推断类型时要把变量arr推断为只读数组，从而使得数组成员无法改变。</p><h3 id="多维数组" tabindex="-1"><a class="header-anchor" href="#多维数组"><span>多维数组</span></a></h3><p>TypeScript 使用<code>T[][]</code>的形式，表示二维数组，<code>T</code>是最底层数组成员的类型。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> multi</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">number</span><span style="color:#F0F3F6;">[][] </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [[</span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">,</span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">,</span><span style="color:#91CBFF;">3</span><span style="color:#F0F3F6;">], [</span><span style="color:#91CBFF;">23</span><span style="color:#F0F3F6;">,</span><span style="color:#91CBFF;">24</span><span style="color:#F0F3F6;">,</span><span style="color:#91CBFF;">25</span><span style="color:#F0F3F6;">]];</span></span></code></pre></div><p>上面示例中，变量<code>multi</code>的类型是<code>number[][]</code>，表示它是一个二维数组，最底层的数组成员类型是<code>number</code>。</p><h2 id="元组" tabindex="-1"><a class="header-anchor" href="#元组"><span>元组</span></a></h2><p>元组（<code>tuple</code>）是 TypeScript 特有的数据类型，JavaScript 没有单独区分这种类型。它表示成员类型可以自由设置的数组，即数组的各个成员的类型可以不同。</p><p>由于成员的类型可以不一样，所以元组必须明确声明每个成员的类型。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> s</span><span style="color:#FF9492;">:</span><span style="color:#F0F3F6;">[</span><span style="color:#91CBFF;">string</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">string</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">boolean</span><span style="color:#F0F3F6;">] </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [</span><span style="color:#ADDCFF;">&#39;a&#39;</span><span style="color:#F0F3F6;">, </span><span style="color:#ADDCFF;">&#39;b&#39;</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">true</span><span style="color:#F0F3F6;">];</span></span></code></pre></div><p>上面示例中，元组s的前两个成员的类型是<code>string</code>，最后一个成员的类型是<code>boolean</code>。</p><p>元组类型的写法，与数组有一个重大差异。数组的成员类型写在方括号外面（<code>number[]</code>），元组的成员类型是写在方括号里面（[number]）。TypeScript 的区分方法就是，成员类型写在方括号里面的就是元组，写在外面的就是数组。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">// 数组</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> a</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">number</span><span style="color:#F0F3F6;">[] </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [</span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">];</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;">// 元组</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> t</span><span style="color:#FF9492;">:</span><span style="color:#F0F3F6;">[</span><span style="color:#91CBFF;">number</span><span style="color:#F0F3F6;">] </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [</span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">];</span></span></code></pre></div><p>上面示例中，变量<code>a</code>和<code>t</code>的值都是<code>[1]</code>，但是它们的类型是不一样的。<code>a</code>是一个数组，成员类型<code>number</code>写在方括号外面；<code>t</code>是一个元组，成员类型<code>number</code>写在方括号里面。</p><p>使用元组时，必须明确给出类型声明（上例的<code>[number]</code>），不能省略，否则 TypeScript 会把一个值自动推断为数组。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">// a 的类型被推断为 (number | boolean)[]</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> a </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [</span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">true</span><span style="color:#F0F3F6;">];</span></span></code></pre></div><p>上面示例中，变量<code>a</code>的值其实是一个元组，但是 TypeScript 会将其推断为一个联合类型的数组，即<code>a</code>的类型为<code>(number | boolean)[]</code>。所以，元组必须显式给出类型声明。</p><p>元组成员的类型可以添加问号后缀（<code>?</code>），表示该成员是可选的。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> a</span><span style="color:#FF9492;">:</span><span style="color:#F0F3F6;">[</span><span style="color:#91CBFF;">number</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">number</span><span style="color:#FF9492;">?</span><span style="color:#F0F3F6;">] </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [</span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">];</span></span></code></pre></div><p>上面示例中，元组<code>a</code>的第二个成员是可选的，可以省略。</p><p>注意，问号只能用于元组的尾部成员，也就是说，所有可选成员必须在必选成员之后。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">type</span><span style="color:#FFB757;"> myTuple</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> [</span></span>
<span class="line"><span style="color:#91CBFF;">    number</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#91CBFF;">    number</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#91CBFF;">    number</span><span style="color:#FF9492;">?</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#91CBFF;">    string</span><span style="color:#FF9492;">?</span></span>
<span class="line"><span style="color:#F0F3F6;">];</span></span></code></pre></div><p>上面示例中，元组<code>myTuple</code>的最后两个成员是可选的。也就是说，它的成员数量可能有两个、三个和四个。</p><p>由于需要声明每个成员的类型，所以大多数情况下，元组的成员数量是有限的，从类型声明就可以明确知道，元组包含多少个成员，越界的成员会报错。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> x</span><span style="color:#FF9492;">:</span><span style="color:#F0F3F6;">[</span><span style="color:#91CBFF;">string</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">string</span><span style="color:#F0F3F6;">] </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [</span><span style="color:#ADDCFF;">&#39;a&#39;</span><span style="color:#F0F3F6;">, </span><span style="color:#ADDCFF;">&#39;b&#39;</span><span style="color:#F0F3F6;">];</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">x[</span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">] </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &#39;c&#39;</span><span style="color:#F0F3F6;">; </span><span style="color:#BDC4CC;">// 报错</span></span></code></pre></div><p>上面示例中，变量<code>x</code>是一个只有两个成员的元组，如果对第三个成员赋值就报错了。</p><p>但是，使用扩展运算符（<code>...</code>），可以表示不限成员数量的元组。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">type</span><span style="color:#FFB757;"> NamedNums</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> [</span></span>
<span class="line"><span style="color:#91CBFF;">  string</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#FF9492;">  ...</span><span style="color:#91CBFF;">number</span><span style="color:#F0F3F6;">[]</span></span>
<span class="line"><span style="color:#F0F3F6;">];</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> a</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;">NamedNums</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> [</span><span style="color:#ADDCFF;">&#39;A&#39;</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">];</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> b</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;">NamedNums</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> [</span><span style="color:#ADDCFF;">&#39;B&#39;</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">3</span><span style="color:#F0F3F6;">];</span></span></code></pre></div><p>上面示例中，元组类型<code>NamedNums</code>的第一个成员是字符串，后面的成员使用扩展运算符来展开一个数组，从而实现了不定数量的成员。</p><p>扩展运算符（<code>...</code>）用在元组的任意位置都可以，它的后面只能是一个数组或元组。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">type</span><span style="color:#FFB757;"> t1</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> [</span><span style="color:#91CBFF;">string</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">number</span><span style="color:#F0F3F6;">, </span><span style="color:#FF9492;">...</span><span style="color:#91CBFF;">boolean</span><span style="color:#F0F3F6;">[]];</span></span>
<span class="line"><span style="color:#FF9492;">type</span><span style="color:#FFB757;"> t2</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> [</span><span style="color:#91CBFF;">string</span><span style="color:#F0F3F6;">, </span><span style="color:#FF9492;">...</span><span style="color:#91CBFF;">boolean</span><span style="color:#F0F3F6;">[], </span><span style="color:#91CBFF;">number</span><span style="color:#F0F3F6;">];</span></span>
<span class="line"><span style="color:#FF9492;">type</span><span style="color:#FFB757;"> t3</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> [</span><span style="color:#FF9492;">...</span><span style="color:#91CBFF;">boolean</span><span style="color:#F0F3F6;">[], </span><span style="color:#91CBFF;">string</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">number</span><span style="color:#F0F3F6;">];</span></span></code></pre></div><p>上面示例中，扩展运算符分别在元组的尾部、中部和头部，<code>...</code>的后面是一个数组<code>boolean[]</code>。</p><p>如果不确定元组成员的类型和数量，可以写成下面这样。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">type</span><span style="color:#FFB757;"> Tuple</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> [</span><span style="color:#FF9492;">...</span><span style="color:#91CBFF;">any</span><span style="color:#F0F3F6;">[]];</span></span></code></pre></div><p>上面示例中，元组<code>Tuple</code>可以放置任意数量和类型的成员。但是这样写，也就失去了使用元组和 TypeScript 的意义。</p><p>元组的成员可以添加成员名，这个成员名是说明性的，可以任意取名，没有实际作用。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">type</span><span style="color:#FFB757;"> Color</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> [</span></span>
<span class="line"><span style="color:#FFB757;">  red</span><span style="color:#F0F3F6;">: </span><span style="color:#91CBFF;">number</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#FFB757;">  green</span><span style="color:#F0F3F6;">: </span><span style="color:#91CBFF;">number</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#FFB757;">  blue</span><span style="color:#F0F3F6;">: </span><span style="color:#91CBFF;">number</span></span>
<span class="line"><span style="color:#F0F3F6;">];</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> c</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;">Color</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> [</span><span style="color:#91CBFF;">255</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">255</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">255</span><span style="color:#F0F3F6;">];</span></span></code></pre></div><p>上面示例中，类型<code>Color</code>是一个元组，它有三个成员。每个成员都有一个名字，写在具体类型的前面，使用冒号分隔。这几个名字可以随便取，没有实际作用，只是用来说明每个成员的含义。</p><p>元组可以通过方括号，读取成员类型。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">type</span><span style="color:#FFB757;"> Tuple</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> [</span><span style="color:#91CBFF;">string</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">number</span><span style="color:#F0F3F6;">];</span></span>
<span class="line"><span style="color:#FF9492;">type</span><span style="color:#FFB757;"> Age</span><span style="color:#FF9492;"> =</span><span style="color:#FFB757;"> Tuple</span><span style="color:#F0F3F6;">[</span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">]; </span><span style="color:#BDC4CC;">// number</span></span></code></pre></div><p>上面示例中，<code>Tuple[1]</code>返回 1 号位置的成员类型。</p><p>由于元组的成员都是数值索引，即索引类型都是<code>number</code>，所以可以像下面这样读取。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">type</span><span style="color:#FFB757;"> Tuple</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> [</span><span style="color:#91CBFF;">string</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">number</span><span style="color:#F0F3F6;">, </span><span style="color:#FFB757;">Date</span><span style="color:#F0F3F6;">];</span></span>
<span class="line"><span style="color:#FF9492;">type</span><span style="color:#FFB757;"> TupleEl</span><span style="color:#FF9492;"> =</span><span style="color:#FFB757;"> Tuple</span><span style="color:#F0F3F6;">[</span><span style="color:#91CBFF;">number</span><span style="color:#F0F3F6;">];  </span><span style="color:#BDC4CC;">// string|number|Date</span></span></code></pre></div><p>上面示例中，<code>Tuple[number]</code>表示元组<code>Tuple</code>的所有数值索引的成员类型，所以返回<code>string|number|Date</code>，即这个类型是三种值的联合类型。</p><h3 id="只读元组" tabindex="-1"><a class="header-anchor" href="#只读元组"><span>只读元组</span></a></h3><p>元组也可以是只读的，不允许修改，有两种写法。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">// 写法一</span></span>
<span class="line"><span style="color:#FF9492;">type</span><span style="color:#FFB757;"> t</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> readonly</span><span style="color:#F0F3F6;"> [</span><span style="color:#91CBFF;">number</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">string</span><span style="color:#F0F3F6;">]</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;">// 写法二</span></span>
<span class="line"><span style="color:#FF9492;">type</span><span style="color:#FFB757;"> t</span><span style="color:#FF9492;"> =</span><span style="color:#FFB757;"> Readonly</span><span style="color:#F0F3F6;">&lt;[</span><span style="color:#91CBFF;">number</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">string</span><span style="color:#F0F3F6;">]&gt;</span></span></code></pre></div><p>上面示例中，两种写法都可以得到只读元组，其中写法二是一个泛型，用到了工具类型<code>Readonly&lt;T&gt;</code>。</p><p>跟数组一样，只读元组是元组的父类型。所以，元组可以替代只读元组，而只读元组不能替代元组。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">type</span><span style="color:#FFB757;"> t1</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> readonly</span><span style="color:#F0F3F6;"> [</span><span style="color:#91CBFF;">number</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">number</span><span style="color:#F0F3F6;">];</span></span>
<span class="line"><span style="color:#FF9492;">type</span><span style="color:#FFB757;"> t2</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> [</span><span style="color:#91CBFF;">number</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">number</span><span style="color:#F0F3F6;">];</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> x</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;">t2</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> [</span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">];</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> y</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;">t1</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> x; </span><span style="color:#BDC4CC;">// 正确</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">x </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> y; </span><span style="color:#BDC4CC;">// 报错</span></span></code></pre></div><p>上面示例中，类型<code>t1</code>是只读元组，类型<code>t2</code>是普通元组。<code>t2</code>类型可以赋值给<code>t1</code>类型，反过来就会报错。</p><p>由于只读元组不能替代元组，所以会产生一些令人困惑的报错。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">function</span><span style="color:#DBB7FF;"> distanceFromOrigin</span><span style="color:#F0F3F6;">([</span><span style="color:#FFB757;">x</span><span style="color:#F0F3F6;">, </span><span style="color:#FFB757;">y</span><span style="color:#F0F3F6;">]</span><span style="color:#FF9492;">:</span><span style="color:#F0F3F6;">[</span><span style="color:#91CBFF;">number</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">number</span><span style="color:#F0F3F6;">]) {</span></span>
<span class="line"><span style="color:#FF9492;">  return</span><span style="color:#F0F3F6;"> Math.</span><span style="color:#DBB7FF;">sqrt</span><span style="color:#F0F3F6;">(x</span><span style="color:#FF9492;">**</span><span style="color:#91CBFF;">2</span><span style="color:#FF9492;"> +</span><span style="color:#F0F3F6;"> y</span><span style="color:#FF9492;">**</span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> point </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [</span><span style="color:#91CBFF;">3</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">4</span><span style="color:#F0F3F6;">] </span><span style="color:#FF9492;">as</span><span style="color:#FF9492;"> const</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#DBB7FF;">distanceFromOrigin</span><span style="color:#F0F3F6;">(point); </span><span style="color:#BDC4CC;">// 报错</span></span></code></pre></div><p>上面示例中，函数<code>distanceFromOrigin()</code>的参数是一个元组，传入只读元组就会报错，因为只读元组不能替代元组。</p><p>读者可能注意到了，上例中<code>[3, 4] as const</code>的写法，生成的是只读数组，其实生成的同时也是只读元组。因为它生成的实际上是一个只读的“值类型”<code>readonly [3, 4]</code>，把它解读成只读数组或只读元组都可以。</p><p>上面示例报错的解决方法，就是使用类型断言，在最后一行将传入的参数断言为普通元组。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#DBB7FF;">distanceFromOrigin</span><span style="color:#F0F3F6;">(point </span><span style="color:#FF9492;">as</span><span style="color:#F0F3F6;"> [</span><span style="color:#91CBFF;">number</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">number</span><span style="color:#F0F3F6;">])</span></span></code></pre></div><h3 id="成员数量的推断" tabindex="-1"><a class="header-anchor" href="#成员数量的推断"><span>成员数量的推断</span></a></h3><p>如果没有可选成员和扩展运算符，TypeScript 会推断出元组的成员数量（即元组长度）。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">function</span><span style="color:#DBB7FF;"> f</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">point</span><span style="color:#FF9492;">:</span><span style="color:#F0F3F6;"> [</span><span style="color:#91CBFF;">number</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">number</span><span style="color:#F0F3F6;">]) {</span></span>
<span class="line"><span style="color:#FF9492;">  if</span><span style="color:#F0F3F6;"> (point.</span><span style="color:#91CBFF;">length</span><span style="color:#FF9492;"> ===</span><span style="color:#91CBFF;"> 3</span><span style="color:#F0F3F6;">) {  </span><span style="color:#BDC4CC;">// 报错</span></span>
<span class="line"><span style="color:#BDC4CC;">    // ...</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面示例会报错，原因是 TypeScript 发现元组<code>point</code>的长度是 2，不可能等于 3，这个判断无意义。</p><p>如果包含了可选成员，TypeScript 会推断出可能的成员数量。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">function</span><span style="color:#DBB7FF;"> f</span><span style="color:#F0F3F6;">(</span></span>
<span class="line"><span style="color:#FFB757;">  point</span><span style="color:#FF9492;">:</span><span style="color:#F0F3F6;">[</span><span style="color:#91CBFF;">number</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">number</span><span style="color:#FF9492;">?</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">number</span><span style="color:#FF9492;">?</span><span style="color:#F0F3F6;">]</span></span>
<span class="line"><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#FF9492;">  if</span><span style="color:#F0F3F6;"> (point.</span><span style="color:#91CBFF;">length</span><span style="color:#FF9492;"> ===</span><span style="color:#91CBFF;"> 4</span><span style="color:#F0F3F6;">) {  </span><span style="color:#BDC4CC;">// 报错</span></span>
<span class="line"><span style="color:#BDC4CC;">    // ...</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面示例会报错，原因是 TypeScript 发现<code>point.length</code>的类型是<code>1|2|3</code>，不可能等于 4。</p><p>如果使用了扩展运算符，TypeScript 就无法推断出成员数量。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> myTuple</span><span style="color:#FF9492;">:</span><span style="color:#F0F3F6;">[</span><span style="color:#FF9492;">...</span><span style="color:#91CBFF;">string</span><span style="color:#F0F3F6;">[]] </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [</span><span style="color:#ADDCFF;">&#39;a&#39;</span><span style="color:#F0F3F6;">, </span><span style="color:#ADDCFF;">&#39;b&#39;</span><span style="color:#F0F3F6;">, </span><span style="color:#ADDCFF;">&#39;c&#39;</span><span style="color:#F0F3F6;">];</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">if</span><span style="color:#F0F3F6;"> (myTuple.</span><span style="color:#91CBFF;">length</span><span style="color:#FF9492;"> ===</span><span style="color:#91CBFF;"> 4</span><span style="color:#F0F3F6;">) { </span><span style="color:#BDC4CC;">// 正确</span></span>
<span class="line"><span style="color:#BDC4CC;">  // ...</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面示例中，<code>myTuple</code>只有三个成员，但是 TypeScript 推断不出它的成员数量，因为它的类型用到了扩展运算符，TypeScript 把<code>myTuple</code>当成数组看待，而数组的成员数量是不确定的。</p><p>一旦扩展运算符使得元组的成员数量无法推断，TypeScript 内部就会把该元组当成数组处理。</p><h3 id="扩展运算符与成员数量" tabindex="-1"><a class="header-anchor" href="#扩展运算符与成员数量"><span>扩展运算符与成员数量</span></a></h3><p>扩展运算符（<code>...</code>）将数组（注意，不是元组）转换成一个逗号分隔的序列，这时 TypeScript 会认为这个序列的成员数量是不确定的，因为数组的成员数量是不确定的。</p><p>这导致如果函数调用时，使用扩展运算符传入函数参数，可能发生参数数量与数组长度不匹配的报错。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> arr</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> [</span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">];</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">function</span><span style="color:#DBB7FF;"> add</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">x</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">number</span><span style="color:#F0F3F6;">, </span><span style="color:#FFB757;">y</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">number</span><span style="color:#F0F3F6;">){</span></span>
<span class="line"><span style="color:#BDC4CC;">  // ...</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#DBB7FF;">add</span><span style="color:#F0F3F6;">(</span><span style="color:#FF9492;">...</span><span style="color:#F0F3F6;">arr) </span><span style="color:#BDC4CC;">// 报错</span></span></code></pre></div><p>上面示例会报错，原因是函数<code>add()</code>只能接受两个参数，但是传入的是<code>...arr</code>，TypeScript 认为转换后的参数个数是不确定的。</p><p>有些函数可以接受任意数量的参数，这时使用扩展运算符就不会报错。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> arr</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> [</span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">3</span><span style="color:#F0F3F6;">];</span></span>
<span class="line"><span style="color:#F0F3F6;">console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(</span><span style="color:#FF9492;">...</span><span style="color:#F0F3F6;">arr) </span><span style="color:#BDC4CC;">// 正确</span></span></code></pre></div><p>上面示例中，<code>console.log()</code>可以接受任意数量的参数，所以传入<code>...arr</code>就不会报错。</p><p>解决这个问题的一个方法，就是把成员数量不确定的数组，写成成员数量确定的元组，再使用扩展运算符。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> arr</span><span style="color:#FF9492;">:</span><span style="color:#F0F3F6;">[</span><span style="color:#91CBFF;">number</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">number</span><span style="color:#F0F3F6;">] </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [</span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">];</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">function</span><span style="color:#DBB7FF;"> add</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">x</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">number</span><span style="color:#F0F3F6;">, </span><span style="color:#FFB757;">y</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">number</span><span style="color:#F0F3F6;">){</span></span>
<span class="line"><span style="color:#BDC4CC;">  // ...</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#DBB7FF;">add</span><span style="color:#F0F3F6;">(</span><span style="color:#FF9492;">...</span><span style="color:#F0F3F6;">arr) </span><span style="color:#BDC4CC;">// 正确</span></span></code></pre></div><p>上面示例中，<code>arr</code>是一个拥有两个成员的元组，所以 TypeScript 能够确定<code>...arr</code>可以匹配函数<code>add()</code>的参数数量，就不会报错了。</p><p>另一种写法是使用<code>as const</code>断言。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> arr</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> [</span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">] </span><span style="color:#FF9492;">as</span><span style="color:#FF9492;"> const</span><span style="color:#F0F3F6;">;</span></span></code></pre></div><p>上面这种写法也可以，因为 TypeScript 会认为<code>arr</code>的类型是<code>readonly [1, 2]</code>，这是一个只读的值类型，可以当作数组，也可以当作元组。</p>`,148)]))}const r=a(o,[["render",e],["__file","ts数组和元组.html.vue"]]),y=JSON.parse('{"path":"/js/ts/ts%E6%95%B0%E7%BB%84%E5%92%8C%E5%85%83%E7%BB%84.html","title":"","lang":"zh-CN","frontmatter":{"description":"JavaScript 数组在 TypeScript 里面分成两种类型，分别是数组（array）和元组（tuple）。 数组 TypeScript 数组有一个根本特征：所有成员的类型必须相同，但是成员数量是不确定的，可以是无限数量的成员，也可以是零成员。 数组的类型有两种写法。第一种写法是在数组成员的类型后面，加上一对方括号。 上面示例中，数组arr的类...","head":[["meta",{"property":"og:url","content":"https://0oWSQo0.github.io/wsq-blog/js/ts/ts%E6%95%B0%E7%BB%84%E5%92%8C%E5%85%83%E7%BB%84.html"}],["meta",{"property":"og:description","content":"JavaScript 数组在 TypeScript 里面分成两种类型，分别是数组（array）和元组（tuple）。 数组 TypeScript 数组有一个根本特征：所有成员的类型必须相同，但是成员数量是不确定的，可以是无限数量的成员，也可以是零成员。 数组的类型有两种写法。第一种写法是在数组成员的类型后面，加上一对方括号。 上面示例中，数组arr的类..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-09-11T05:57:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-09-11T05:57:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-09-11T05:57:00.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"WSQ\\",\\"url\\":\\"https://0oWSQo0.github.com\\"}]}"]]},"headers":[{"level":2,"title":"数组","slug":"数组","link":"#数组","children":[{"level":3,"title":"数组的类型推断","slug":"数组的类型推断","link":"#数组的类型推断","children":[]},{"level":3,"title":"只读数组，const 断言","slug":"只读数组-const-断言","link":"#只读数组-const-断言","children":[]},{"level":3,"title":"多维数组","slug":"多维数组","link":"#多维数组","children":[]}]},{"level":2,"title":"元组","slug":"元组","link":"#元组","children":[{"level":3,"title":"只读元组","slug":"只读元组","link":"#只读元组","children":[]},{"level":3,"title":"成员数量的推断","slug":"成员数量的推断","link":"#成员数量的推断","children":[]},{"level":3,"title":"扩展运算符与成员数量","slug":"扩展运算符与成员数量","link":"#扩展运算符与成员数量","children":[]}]}],"git":{"createdTime":1726034220000,"updatedTime":1726034220000,"contributors":[{"name":"WSQ","email":"592786982@qq.com","commits":1}]},"readingTime":{"minutes":13.26,"words":3979},"filePathRelative":"js/ts/ts数组和元组.md","localizedDate":"2024年9月11日","autoDesc":true}');export{r as comp,y as data};
