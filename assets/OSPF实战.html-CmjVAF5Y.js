import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,d as p,o as n}from"./app-Coac0FJ0.js";const o={};function c(l,a){return n(),e("div",null,a[0]||(a[0]=[p(`<h1 id="ospf-基础命令" tabindex="-1"><a class="header-anchor" href="#ospf-基础命令"><span>OSPF 基础命令</span></a></h1><p>掌握三条命令，就能玩转 OSPF：</p><ul><li>创建 OSPF 进程，进入配置视图</li><li>创建 OSPF 区域</li><li>接口激活 OSPF</li></ul><h2 id="创建-ospf-进程" tabindex="-1"><a class="header-anchor" href="#创建-ospf-进程"><span>创建 OSPF 进程</span></a></h2><p>在系统视图下，使用 OSPF 命令，创建 OSPF 进程。</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>[Router]ospf 1 Router-id 1.1.1.1</span></span></code></pre></div><p>上面的命令，是在<code>Router</code>上创建<code>Process-ID</code>为 1 的 OSPF 进程，并进入配置视图。使用的<code>Router-ID</code>是<code>1.1.1.1</code>。</p><p><code>Process-ID</code>是可选参数，表示 OSPF 进程的编号，只在设备本身生效，也就是说，两台设备建立 OSPF 邻居时，不要求双方的<code>Process-ID</code>一样。如果不指定<code>Process-ID</code>，会分配一个默认值作为<code>Process-ID</code>。</p><p><code>router-id</code>也是可选参数，用来指定设备的<code>Router-ID</code>。通常，手动配置<code>Router-ID</code>，不会使用默认值。</p><h2 id="创建-ospf-区域" tabindex="-1"><a class="header-anchor" href="#创建-ospf-区域"><span>创建 OSPF 区域</span></a></h2><p>创建完 OSPF 进程后，就需要创建 OSPF 区域。在配置视图下，使用<code>area</code>命令创建区域，并指定区域 ID。</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>[Router]ospf 1 Router-id 1.1.1.1</span></span>
<span class="line"><span>[Router-ospf-1]area 1</span></span></code></pre></div><p>在 OSPF 进程 1 中，创建<code>Area1</code>。</p><h2 id="接口激活-ospf" tabindex="-1"><a class="header-anchor" href="#接口激活-ospf"><span>接口激活 OSPF</span></a></h2><p>默认状态下，所有接口都没有激活 OSPF，要在接口激活 OSPF，有两种方法：</p><h3 id="在区域视图激活-ospf" tabindex="-1"><a class="header-anchor" href="#在区域视图激活-ospf"><span>在区域视图激活 OSPF</span></a></h3><p>在区域视图下，使用<code>network</code>命令，再加上 IP 地址和通配符掩码，满足条件的接口激活 OSPF。</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>[Router]ospf 1 Router-id 1.1.1.1</span></span>
<span class="line"><span>[Router-ospf-1]area 0</span></span>
<span class="line"><span>[Router-ospf-1-area-0.0.0.0]network 192.168.1.0 0.0.0.255</span></span></code></pre></div><p>举个栗子：<code>network 192.168.1.0 0.0.0.255</code>，IP 地址是<code>192.168.1.0</code>，通配符掩码是<code>0.0.0.255</code>。通配符掩码中，比特位为 0 的需要匹配，比特位为 1 的不需要匹配。命令中匹配的 IP 地址是<code>192.168.1.0</code>至<code>192.168.1.255</code>。</p><p><a href="OSPF%E5%AE%9E%E6%88%98/1.png"></a></p><p>计算方法是，把<code>192.168.1.0</code>用二进制表示，把通配符掩码<code>0.0.0.255</code>也换算成二进制，每个比特位对应。前 24 位全为 0，后 8 位全为 1。匹配的 IP 地址，以<code>192.168.1</code>开头，后面是 0 至 255 的任意值。接口 IP 地址在这个范围内，且 IP 地址掩码长度大于或等于<code>network</code>命令的 0 比特位数，就在接口上激活 OSPF。</p><p>有两个特殊的<code>network</code>命令，一个是<code>network x.x.x.x 0.0.0.0</code>，比如<code>network 192.168.1.1 0.0.0.0</code>，IP 地址是<code>192.168.1.1</code>的接口激活 OSPF，无论网络掩码长度多少。另一个是<code>network 0.0.0.0 255.255.255.255</code>，匹配任意 IP 地址，所有配置了 IP 地址的接口，都会激活 OSPF。</p><h3 id="在指定接口激活-ospf" tabindex="-1"><a class="header-anchor" href="#在指定接口激活-ospf"><span>在指定接口激活 OSPF</span></a></h3><p>上面的方法，可以使用一条命令，在多个接口激活 OSPF。另一个方法就是在指定接口激活 OSPF。先创建 OSPF 进程和区域，然后进入接口视图，使用<code>ospf enable</code>命令激活。</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[Router]ospf 1 Router-id 1.1.1.1 </span><span style="color:#BDC4CC;">#创建OSPF进程</span></span>
<span class="line"><span style="color:#F0F3F6;">[Router-ospf-1]area 0 </span><span style="color:#BDC4CC;">#创建Area0</span></span>
<span class="line"><span style="color:#F0F3F6;">[Router-ospf-1-area-0.0.0.0]quit</span></span>
<span class="line"><span style="color:#F0F3F6;">[Router-ospf-1]quit</span></span>
<span class="line"><span style="color:#F0F3F6;">[Router]interface GigabitEthernet 0/0 </span><span style="color:#BDC4CC;">#进入GE0/0接口视图</span></span>
<span class="line"><span style="color:#F0F3F6;">[Router-GigabitEthernet0/0]ospf enable 1 area 0 </span><span style="color:#BDC4CC;">#激活OSPF</span></span></code></pre></div><h1 id="ospf-单区域实验" tabindex="-1"><a class="header-anchor" href="#ospf-单区域实验"><span>OSPF 单区域实验</span></a></h1><p><a href="OSPF%E5%AE%9E%E6%88%98/2.png"></a></p><p>路由器 RT1 的两个接口分别连接<code>172.16.1.0/24</code>和<code>172.16.2.0/24</code>网段，另一个接口连接路由器 RT2。RT2 创建 Loopback 接口，配置 IP 地址<code>172.16.255.2/24</code>，模拟 RT2 的直连网段。在 RT1 和 RT2 上运行 OSPF，让 PC 可以访问全部网段。</p><p>RT1 配置如下：</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[RT1]ospf 1 router-id 1.1.1.1</span></span>
<span class="line"><span style="color:#F0F3F6;">[RT1-ospf-1]area 0</span></span>
<span class="line"><span style="color:#F0F3F6;">[RT1-ospf-1-area-0.0.0.0]network 172.16.1.0 0.0.0.255</span></span>
<span class="line"><span style="color:#F0F3F6;">[RT1-ospf-1-area-0.0.0.0]network 172.16.2.0 0.0.0.255</span></span>
<span class="line"><span style="color:#F0F3F6;">[RT1-ospf-1-area-0.0.0.0]network 172.16.12.0 0.0.0.3</span></span></code></pre></div><p>RT2 配置如下：</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[RT2]ospf 1 router-id 2.2.2.2</span></span>
<span class="line"><span style="color:#F0F3F6;">[RT2-ospf-1]area 0</span></span>
<span class="line"><span style="color:#F0F3F6;">[RT2-ospf-1-area-0.0.0.0]network 172.16.12.0 0.0.0.3</span></span>
<span class="line"><span style="color:#F0F3F6;">[RT2-ospf-1-area-0.0.0.]network 172.16.255.0 0.0.0.255</span></span></code></pre></div><p>配置完成后，RT1 和 RT2 建立邻接关系，交换 LSA。查看 RT1 的邻居表：</p><p><a href="OSPF%E5%AE%9E%E6%88%98/3.png"></a></p><p>邻接表中，RT1 在<code>Area0</code>发现邻居，<code>Router-ID</code>是<code>2.2.2.2</code>，接口 IP 地址是<code>172.16.12.2</code>，邻居状态是<code>Full</code>，对端是<code>Master</code>。</p><p>再看 RT1 的 OSPF 路由表：</p><p><a href="OSPF%E5%AE%9E%E6%88%98/4.png"></a></p><p>命令<code>display ospf routing</code>，是查看 OSPF 路由表，并不是路由器的全局路由器。这些 OSPF 路由表能否加载到全局路由表，还要看路由表优先级等因素。这里发现 R2 的 Loopback0 接口路由，是一条主机路由，实际上，Loopback0 接口的掩码长度是 24，而不是 32。这是因为 OSPF 把 Loopback 接口作为末梢网络，无论实际掩码是多少，Type-1 LSA 中，都以<code>255.255.255.255</code>进行通告。</p><p>查看 RT2 的 Type-1 LSA ：</p><p><a href="OSPF%E5%AE%9E%E6%88%98/5.png"></a></p><p>如果希望 RT2 的 Type-1 LSA 描述 Loopback 接口的实际掩码信息，可以把接口的网络类型改成 Broadcast 或 NBMA，比如：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>[RT2]interface LoopBack 0</span></span>
<span class="line"><span>[RT2-LoopBack0]ospf network-type broadcast</span></span></code></pre></div><p>再看 RT2 的 Type-1 LSA：</p><p><a href="OSPF%E5%AE%9E%E6%88%98/6.png"></a></p><p>RT2 以实际掩码信息通告<code>Loopback0</code>接口。现在看下 RT1 的路由表中 OSPF 路由：</p><p><a href="OSPF%E5%AE%9E%E6%88%98/7.png"></a></p><p>RT1 把<code>172.16.255.0/24</code>网段加载到路由表。同时，RT2 也获得到达<code>172.16.1.0/24</code>和<code>172.16.2.0/24</code>的路由。这样 PC 就能访问网络中的各个网段。</p><h1 id="silent-interface" tabindex="-1"><a class="header-anchor" href="#silent-interface"><span>Silent-Interface</span></a></h1><p><a href="OSPF%E5%AE%9E%E6%88%98/8.png"></a></p><p>上个实验的拓扑图中，RT1 的<code>GE0/0/0</code>和<code>GE0/0/1</code>接口连接终端网段，只有终端 PC，没有 OSPF 路由器。然而，接口已经激活了 OSPF，会周期性的发送<code>Hello</code>报文，但是 PC 无法识别、也不需要识别<code>Hello</code>报文。这时，可以把 RT1 的<code>GE0/0/0</code>和<code>GE0/0/1</code>配置成静默接口（<code>Silent-Interface</code>），接口就会禁止收发<code>Hello</code>报文。</p><p>R1 的配置如下：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>[RT1]ospf 1</span></span>
<span class="line"><span>[RT1-ospf-1]silent-interface GigabitEthernet 0/0/0</span></span>
<span class="line"><span>[RT1-ospf-1]silent-interface GigabitEthernet 0/0/1</span></span></code></pre></div><p>虽然两个接口指定为<code>Silent-Interface</code>，但是已经使用 network 命令激活 OSPF，因此 RT2 还是能通过 OSPF 学习到这两个接口网段的路由。</p><p><a href="OSPF%E5%AE%9E%E6%88%98/9.png"></a></p><h1 id="ospf-多区域实验" tabindex="-1"><a class="header-anchor" href="#ospf-多区域实验"><span>OSPF 多区域实验</span></a></h1><p><a href="OSPF%E5%AE%9E%E6%88%98/10.png"></a></p><p>RT1 和 RT2 是两台汇聚交换机，各自下挂两个终端网段，同时上连核心交换机 RT3 。在三台路由器上部署 OSPF ，使用多区域 OSPF 的设计，实现全网各个网段的数据互通。</p><p>RT1 的配置如下：</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[RT1]ospf 1 router-id 1.1.1.1</span></span>
<span class="line"><span style="color:#F0F3F6;">[RT1-ospf-1]area 1</span></span>
<span class="line"><span style="color:#F0F3F6;">[RT1-ospf-1-area-0.0.0.1]network 172.16.1.0 0.0.0.255</span></span>
<span class="line"><span style="color:#F0F3F6;">[RT1-ospf-1-area-0.0.0.1]network 172.16.2.0 0.0.0.255</span></span>
<span class="line"><span style="color:#F0F3F6;">[RT1-ospf-area-0.0.0.1]quit</span></span>
<span class="line"><span style="color:#F0F3F6;">[RT1-ospf-1]area 0</span></span>
<span class="line"><span style="color:#F0F3F6;">[RT1-ospf-1-area-0.0.0.o]network 172.16.0.0 0.0.0.3</span></span></code></pre></div><p>RT2 的配置如下：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>[RT2]ospf 1 router-id 2.2.2.2</span></span>
<span class="line"><span>[RT2-ospf-1]area 2</span></span>
<span class="line"><span>[RT2-ospf-1-area-0.0.0.2]network 172.16.9.0 0.0.0.255</span></span>
<span class="line"><span>[RT2-ospf-1-area-0.0.0.2]network 172.16.10.0 0.0.0.255</span></span>
<span class="line"><span>[RT2-ospf-1-area-0.0.0.2]quit</span></span>
<span class="line"><span>[RT2-ospf-1]area 0</span></span>
<span class="line"><span>[RT2-ospf-1-area-0.0.0.o]network 172.16.0.4 0.0.0.3</span></span></code></pre></div><p>RT3 的配置如下：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>[RT3]ospf 1 router-id 3.3.3.3</span></span>
<span class="line"><span>[RT3-ospf-1]area 0</span></span>
<span class="line"><span>[RT3-ospf-1-area-0.0.0.0]network 172.16.0.0 0.0.0.3</span></span>
<span class="line"><span>[RT3-ospf-1-area-0.0.0.0]network 172.16.0.4 0.0.0.3</span></span></code></pre></div><p>查看 RT3 的 OSPF 邻居表：</p><p><a href="OSPF%E5%AE%9E%E6%88%98/11.png"></a></p><p>RT3 和 RT1、RT2 建立的 FULL 的邻接关系，我们再看看 RT3 的路由表：</p><p><a href="OSPF%E5%AE%9E%E6%88%98/12.png"></a></p><p><code>Area0</code>的路由器 RT3，已经学到了 RT1 和 RT2 下连的终端网段路由。这些路由都是区域间路由，根据 RT1 和 RT2 在<code>Area0</code>泛洪的 Type-3 LSA 计算得出，而 RT3 要计算到达<code>Area1</code>和<code>Area2</code>的区域间路由，除了这些网段的 Type-3 LSA，还需要指定 ABR 的位置。作为 ABR，RT1 和 RT2 在泛洪 Type-1 LSA 时，会把 B 比特位设置为 1。因此，通过 Area0 内泛洪的<code>Type-1</code>、<code>Type-2</code>LSA ，RT3 能计算到达 ABR 的最佳路径。使用<code>display ospf abr-asbr</code>命令查看 ABR 和 ASBR 信息：</p><p><a href="OSPF%E5%AE%9E%E6%88%98/13.png"></a></p><p>在 RT1 和 RT2 上查看路由表，看到两台路由器都学到了全网的路由，RT1 和 RT2 下挂的 PC 就可以到达全网各个网段。</p><h1 id="ospf-cost-值" tabindex="-1"><a class="header-anchor" href="#ospf-cost-值"><span>OSPF Cost 值</span></a></h1><p><a href="OSPF%E5%AE%9E%E6%88%98/14.png"></a></p><p>R1 和 R2 连接到相同的一个网段：<code>192.168.100.0/24</code>，同时下连 R3。R1、R2、R3 都激活 OSPF，在相同的 Area 中，接口的 Cost 又是默认值，这时 R3 的路由表中，到达<code>192.168.100.0/24</code>会有两条等价路由：</p><p><a href="OSPF%E5%AE%9E%E6%88%98/15.png"></a></p><p>如果两条链路以主备方式工作，该如何实现呢？一个最简单的方法就是调整接口 Cost 值。比如把 R3 的<code>G0/0/2</code>接口 Cost 值调大，到达<code>192.168.100.0/24</code>的报文会转发给 R1，当 R1 故障时，R3 自动把流量切到 R2。</p><p>R3 的配置：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>[R3]interface GigabitEthernet 0/0/2</span></span>
<span class="line"><span>[R3-GigabitEthernet0/0/2]ospf cost 100</span></span></code></pre></div><p>查看接口参数：</p><p><a href="OSPF%E5%AE%9E%E6%88%98/16.png"></a></p><p>在查看 R3 的路由表：</p><p><a href="OSPF%E5%AE%9E%E6%88%98/17.png"></a></p><p>配置生效。</p><h1 id="ospf-特殊区域" tabindex="-1"><a class="header-anchor" href="#ospf-特殊区域"><span>OSPF 特殊区域</span></a></h1><p><a href="OSPF%E5%AE%9E%E6%88%98/18.png"></a></p><p>R1 、R2 、R3 运行 OSPF，R3 把自己的静态路由引入 OSPF，让域内的路由器学习到外部路由。</p><h2 id="_1、基本配置" tabindex="-1"><a class="header-anchor" href="#_1、基本配置"><span>1、基本配置</span></a></h2><p>R1 配置：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>[Rl]ospf i router-id 1.1.1.1</span></span>
<span class="line"><span>[R1-ospf-l]area 1</span></span>
<span class="line"><span>[R1-ospf-1-area-0.0.0.l]network 10.1.12.0 0.0.0.255</span></span></code></pre></div><p>R2 配置：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>[R2]ospf  router-id 2.2.2.2</span></span>
<span class="line"><span>[R2-ospf-l]area 1</span></span>
<span class="line"><span>[R2-ospf-1-area-0.0.0.]network 10.1.12.0 0.0.0.255</span></span>
<span class="line"><span>[R2-ospf-1-area-0.0.0.1]quit</span></span>
<span class="line"><span>[R2-ospf-1]area 0</span></span>
<span class="line"><span>[R2-ospf-1-area-0.0.0.0]network 10.1.23.0 0.0.0.255</span></span></code></pre></div><p>R3 配置：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>[R3]ip route-static 10.3.1.0 24 NULL 0</span></span>
<span class="line"><span>[R3]ip route-static 10.3.2.0 24 NULL O</span></span>
<span class="line"><span>[R3]ospf 1 router-id 3.3.3.3</span></span>
<span class="line"><span>[R3-ospf-1]area 0</span></span>
<span class="line"><span>[R3-ospf-1-area-0.0.0.o]network 10.1.23.0 0.0.0.255</span></span>
<span class="line"><span>[R3-ospf-1-area-0.0.0.0]quit</span></span>
<span class="line"><span>[R3-ospf-1]import-route static</span></span></code></pre></div><p>观察 R1 的路由表：</p><p><a href="OSPF%E5%AE%9E%E6%88%98/19.png"></a></p><p>R1 学习到了区域间路由和外部路由，外部路由标记位 O_ASE（ OSPF AS External ）。再看看 R1 的 LSDB：</p><p><a href="OSPF%E5%AE%9E%E6%88%98/20.png"></a></p><p>R1 的 LSDB，有 Type-1、Type-2、Type-3、Type-4、Type-5 LSA。Type-3 LSA 描述到达<code>10.1.23.0/24</code>的区域间路由。Type-4 LSA 描述到达 ASBR，也就是 R3 的路由，是由 ABR R2 产生。Type-5 LSA 描述外部路由<code>10.3.1.0/24</code>和<code>10.3.2.0/24</code>，并在整个 OSPF 域内泛洪，这时 R1 有到达各个网段的路由。</p><h2 id="_2、area1-配置为-stub-区域" tabindex="-1"><a class="header-anchor" href="#_2、area1-配置为-stub-区域"><span>2、Area1 配置为 Stub 区域</span></a></h2><p>先把 Area1 配置为 Stub 区域，R1 和 R2 的配置如下：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>[Rl]ospf 1</span></span>
<span class="line"><span>[R1-ospf-l]area 1</span></span>
<span class="line"><span>[R1-ospf-1-area-0.0.0.1]stub</span></span></code></pre></div><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>[R2]ospf 1</span></span>
<span class="line"><span>[R2-ospf-l]area 1</span></span>
<span class="line"><span>[R2-ospf-1-area-0.0.0.1]stub</span></span></code></pre></div><p>某个区域为 Stub 区域，区域内的路由器都要配置成 Stub 区域，否则无法正确建立邻居关系。Stub 区域的 ABR，即 R2，会阻挡 Type-4 、Type-5 LSA 进入区域内，减少 LSA 泛洪的数量，从而减小路由表规模，降低设备负担。</p><p>现在 R1 无法学到 OSPF 外部路由，同时 R2 会下发一条用 Type-3 LSA 描述的外部路由，让 Area1 内的路由器访问域外的网络。观察 R1 的路由表和 LSDB：</p><p><a href="OSPF%E5%AE%9E%E6%88%98/21.png"></a><br><a href="OSPF%E5%AE%9E%E6%88%98/22.png"></a></p><p>R1 的路由表减少，不再有 Type-4 和 Type-5 LSA ，只有 Type-1、Type-2、Type-3 LSA。</p><h2 id="_3、area1-配置为-totally-stub-区域" tabindex="-1"><a class="header-anchor" href="#_3、area1-配置为-totally-stub-区域"><span>3、Area1 配置为 Totally-Stub 区域</span></a></h2><p>如果要进一步减少 LSA 泛洪，可以把区域间的路由也阻挡。在上个实验的基础上，R2 配置如下：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>[R2]ospf 1</span></span>
<span class="line"><span>[R2-ospf-l]area 1</span></span>
<span class="line"><span>[R2-ospf-1-area-0.0.0.1]stub no-summary</span></span></code></pre></div><p>这时，R2 阻挡 Type-3、Type-4、Type-5 LSA 进入 Area1，同时自动下发一条默认路由，使用 Type-3 LSA 描述。这样当 R1 访问区域外的网络时，就使用默认路由转发数据。</p><p>查看 R1 路由表和 LSDB：</p><p><a href="OSPF%E5%AE%9E%E6%88%98/23.png"></a><br><a href="OSPF%E5%AE%9E%E6%88%98/24.png"></a></p><p>R1 路由表只有一条 0.0.0.0/0 的默认路由，极大简化了路由表。同时，R1 的 LSDB 也非常简洁。</p><h2 id="_4、area1-配置为-nssa" tabindex="-1"><a class="header-anchor" href="#_4、area1-配置为-nssa"><span>4、Area1 配置为 NSSA</span></a></h2><p><a href="OSPF%E5%AE%9E%E6%88%98/25.png"></a></p><p>网络发生变化，Area1 的 R1 连着一个外部路由，需要引入 OSPF，让域内路由器获得外部路由，但又希望保持 Stub 区域特性，那么可以把 Area1 配置为 NSSA。在上个实验的基础上，R1 配置如下：</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[R1]ip route-static 10.1.1.0 24 NULL 0 </span><span style="color:#BDC4CC;">#模拟外部路由</span></span>
<span class="line"><span style="color:#F0F3F6;">[R1]ospf 1</span></span>
<span class="line"><span style="color:#F0F3F6;">[Rl-ospf-l]area 1</span></span>
<span class="line"><span style="color:#F0F3F6;">[R1-ospf-1-area-0.0.0.1]undo stub</span></span>
<span class="line"><span style="color:#F0F3F6;">[R1-ospf-1-area-0.0.0.]nssa</span></span>
<span class="line"><span style="color:#F0F3F6;">[R1-ospf-1-area-0.0.0.1]quit</span></span>
<span class="line"><span style="color:#F0F3F6;">[R1-ospf-1]import-route static</span></span></code></pre></div><p>在 R1 创建静态路由，模拟成外部路由，先取消 Stub 配置，然后配置 NSSA，再把外部路由引入 OSPF。</p><p>R2 配置如下：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>[R2]ospf 1</span></span>
<span class="line"><span>[R2-ospf-l]area 1</span></span>
<span class="line"><span>[R2-ospf-1-area-0.0.0.]undo stub</span></span>
<span class="line"><span>[R2-ospf-1-area-0.0.0.1]nssa</span></span></code></pre></div><p>某个区域配置为 NSSA，则区域内的所有路由器都要进行相应配置，否则建立邻居关系会出现问题。Area1 区域成为 NSSA 后，会阻挡 Type-4、Type-5 LSA 进入区域。但是 ABR R2 会下发一条 Type-7 LSA 的默认路由，让区域内的路由器，通过默认路由到达域外网络。同时，会向 Area0 通告 Type-5 LSA 描述<code>10.1.1.0/24</code>路由，让 OSPF 其它区域的路由器都学习到这条路由。</p><p>查看 R1 的 LSDB ：</p><p><a href="OSPF%E5%AE%9E%E6%88%98/26.png"></a></p><p>R1 的 LSDB 中，有 Type-1、Type-2、Type-3、Type-7 LSA，其中两条 Type-7 LSA，一条是 R1 生成的，描述引入的外部路由<code>10.1.1.0/24</code>，另一条是 R2 生成的，是一条默认路由。再看看 R1 的路由表：</p><p><a href="OSPF%E5%AE%9E%E6%88%98/27.png"></a></p><p>再看看 R3 的 LSDB:</p><p><a href="OSPF%E5%AE%9E%E6%88%98/28.png"></a></p><p>R3 有三条 Type-5 LSA，其中两条是自己生成的，描述外部路由<code>10.3.1.0/24</code>和<code>10.3.2.0/24</code>，另一条是 R2 生成的，描述外部路由<code>10.1.1.0/24</code>。R2 把从 Area1 收到的 Type-7 LSA 转换成 Type-5 LSA，并通告到 Area0 中。查看 R3 路由表：</p><p><a href="OSPF%E5%AE%9E%E6%88%98/29.png"></a></p><h2 id="_5、area1-配置为-totally-nssa" tabindex="-1"><a class="header-anchor" href="#_5、area1-配置为-totally-nssa"><span>5、Area1 配置为 Totally NSSA</span></a></h2><p>为了进一步减少 Area1 的 LSA，把 Area1 配置成 Totally NSSA 实现。在上个实验的基础上，R2 配置如下：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>[R2]ospf 1</span></span>
<span class="line"><span>[R2-ospf-l]area 1</span></span>
<span class="line"><span>[R2-ospf-1-area-0.0.0.1]nssa no-summary</span></span></code></pre></div><p>这样 Area1 内不会有 Type-3 LSA 泛洪，R1 也学不到区域间路由。</p><p>看下 R1 的 LSDB：</p><p><a href="OSPF%E5%AE%9E%E6%88%98/30.png"></a></p><p>R1 的 LSDB 中，只有 Type-1、Type-2、Type-7 LSA 和一条描述的默认路由 Type-3 LSA。当 NSSA 内同时存在 Type-3 LSA 和 Type-7 LSA 描述的默认路由时，路由器优先使用 Type-3 LSA 的默认路由，忽略 Type-7 LSA 的默认路由。</p><h1 id="virtual-link" tabindex="-1"><a class="header-anchor" href="#virtual-link"><span>Virtual Link</span></a></h1><p><a href="OSPF%E5%AE%9E%E6%88%98/31.png"></a></p><p>R1、R2、R3 运行 OSPF，规划两个区域<code>Area0</code>和<code>Area23</code>。R3 有两条路由到达<code>192.168.2.0/24</code>网段，因为 R3 不能使用非 0 区域的 Type-3 LSA 来计算区域间路由，因此无论路径的 Cost 如何，R3 都会选择 R1 到达目的网段。查看 R3 的 OSPF 路由表：</p><p><a href="OSPF%E5%AE%9E%E6%88%98/32.png"></a></p><p>如果向让 R3 从 R2 到达<code>192.168.2.0/24</code>，即使用高带宽链路转发，一个简单的方法是，在 R2 和 R3 之间跨越<code>Area23</code>建立一条<code>Virtual Link</code>，通过这条<code>Virtual Link</code>，R2 直接把 Type-1 LSA 发送给 R3。</p><p>R2 配置如下：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>[R2]ospf 1</span></span>
<span class="line"><span>[R2-ospf-l]area 23</span></span>
<span class="line"><span>[R2-ospf-1-area-0.0.0.23]vlink-peer 3.3.3.3</span></span></code></pre></div><p>R3 配置如下：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>[R3]ospf 1</span></span>
<span class="line"><span>[R3-ospf-l]area 23</span></span>
<span class="line"><span>[R3-ospf-1-area-0.0.0.23]vlink-peer 2.2.2.2</span></span></code></pre></div><p>配置完成后，R2 和 R3 建立一条<code>Virtual Link</code>，<code>Virtual Link</code>穿过 Area23，在 R3 查看<code>Virtual Link</code>信息：</p><p><a href="OSPF%E5%AE%9E%E6%88%98/33.png"></a></p><p><code>Virtual Link</code>建立完成后，状态为<code>Full</code>，Cost 为 1，再看下 R3 的 OSPF 路由表：</p><p><a href="OSPF%E5%AE%9E%E6%88%98/34.png"></a></p><p><code>192.168.2.0/24</code>路由的下一跳变成了<code>192.168.23.2</code>，说明到达这个网段的下一跳切换到了 R2，达到预期目标。</p>`,149)]))}const i=s(o,[["render",c],["__file","OSPF实战.html.vue"]]),d=JSON.parse('{"path":"/network/OSPF%E5%AE%9E%E6%88%98.html","title":"OSPF实战","lang":"zh-CN","frontmatter":{"title":"OSPF实战","date":"2023-03-23T20:36:11.000Z","tags":"计算机网络","categories":"计算机网络","description":"OSPF 基础命令 掌握三条命令，就能玩转 OSPF： 创建 OSPF 进程，进入配置视图 创建 OSPF 区域 接口激活 OSPF 创建 OSPF 进程 在系统视图下，使用 OSPF 命令，创建 OSPF 进程。 上面的命令，是在Router上创建Process-ID为 1 的 OSPF 进程，并进入配置视图。使用的Router-ID是1.1.1.1...","head":[["meta",{"property":"og:url","content":"https://wsq01.github.io/wsq-blog/network/OSPF%E5%AE%9E%E6%88%98.html"}],["meta",{"property":"og:title","content":"OSPF实战"}],["meta",{"property":"og:description","content":"OSPF 基础命令 掌握三条命令，就能玩转 OSPF： 创建 OSPF 进程，进入配置视图 创建 OSPF 区域 接口激活 OSPF 创建 OSPF 进程 在系统视图下，使用 OSPF 命令，创建 OSPF 进程。 上面的命令，是在Router上创建Process-ID为 1 的 OSPF 进程，并进入配置视图。使用的Router-ID是1.1.1.1..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-04-23T09:49:11.000Z"}],["meta",{"property":"article:published_time","content":"2023-03-23T20:36:11.000Z"}],["meta",{"property":"article:modified_time","content":"2025-04-23T09:49:11.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"OSPF实战\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-03-23T20:36:11.000Z\\",\\"dateModified\\":\\"2025-04-23T09:49:11.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"WSQ\\",\\"url\\":\\"https://wsq01.github.com\\"}]}"]]},"headers":[{"level":2,"title":"创建 OSPF 进程","slug":"创建-ospf-进程","link":"#创建-ospf-进程","children":[]},{"level":2,"title":"创建 OSPF 区域","slug":"创建-ospf-区域","link":"#创建-ospf-区域","children":[]},{"level":2,"title":"接口激活 OSPF","slug":"接口激活-ospf","link":"#接口激活-ospf","children":[{"level":3,"title":"在区域视图激活 OSPF","slug":"在区域视图激活-ospf","link":"#在区域视图激活-ospf","children":[]},{"level":3,"title":"在指定接口激活 OSPF","slug":"在指定接口激活-ospf","link":"#在指定接口激活-ospf","children":[]}]},{"level":2,"title":"1、基本配置","slug":"_1、基本配置","link":"#_1、基本配置","children":[]},{"level":2,"title":"2、Area1 配置为 Stub 区域","slug":"_2、area1-配置为-stub-区域","link":"#_2、area1-配置为-stub-区域","children":[]},{"level":2,"title":"3、Area1 配置为 Totally-Stub 区域","slug":"_3、area1-配置为-totally-stub-区域","link":"#_3、area1-配置为-totally-stub-区域","children":[]},{"level":2,"title":"4、Area1 配置为 NSSA","slug":"_4、area1-配置为-nssa","link":"#_4、area1-配置为-nssa","children":[]},{"level":2,"title":"5、Area1 配置为 Totally NSSA","slug":"_5、area1-配置为-totally-nssa","link":"#_5、area1-配置为-totally-nssa","children":[]}],"git":{"createdTime":1745401751000,"updatedTime":1745401751000,"contributors":[{"name":"WSQ","email":"592786982@qq.com","commits":1}]},"readingTime":{"minutes":12.05,"words":3614},"filePathRelative":"network/OSPF实战.md","localizedDate":"2023年3月23日","autoDesc":true}');export{i as comp,d as data};
