import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,d as l,o}from"./app-Coac0FJ0.js";const e={};function d(c,s){return o(),t("div",null,s[0]||(s[0]=[l(`<h2 id="命令格式" tabindex="-1"><a class="header-anchor" href="#命令格式"><span>命令格式</span></a></h2><h3 id="命令提示符" tabindex="-1"><a class="header-anchor" href="#命令提示符"><span>命令提示符</span></a></h3><p>登录系统后，第一眼看到的内容是：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>[root@localhost ~]#</span></span></code></pre></div><p>这就是 Linux 系统的命令提示符。</p><ul><li><code>[]</code>：这是提示符的分隔符号，没有特殊含义</li><li><code>root</code>：显示的是当前的登录用户</li><li><code>@</code>：分隔符号，没有特殊含义</li><li><code>localhost</code>：当前系统的简写主机名（完整主机名是<code>localhost.localdomain</code>）</li><li><code>~</code>：代表用户当前所在的目录，此例中用户当前所在的目录是家目录</li><li><code>#</code>：命令提示符，Linux 用这个符号标识登录的用户权限等级。如果是超级用户，提示符就是<code>#</code>；如果是普通用户，提示符就是<code>$</code></li></ul><p>用户登录后，要有一个初始登录的位置，这个初始登录位置就称为用户的主目录：</p><ul><li>超级用户的主目录：<code>/root</code></li><li>普通用户的主目录：<code>/home/用户名</code></li></ul><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>[root@localhost ~]# cd /usr/local</span></span>
<span class="line"><span>[root@localhost local]#</span></span></code></pre></div><p>如果切换用户所在目录，那么命令提示符中的会变成用户当前所在目录的最后一个目录（不显示完整的所在目录<code>/usr/ local</code>，只显示最后一个目录<code>local</code>）。</p><h3 id="环境变量-ps1" tabindex="-1"><a class="header-anchor" href="#环境变量-ps1"><span>环境变量 PS1</span></a></h3><p>命令提示符通常是美元符号<code>$</code>，对于根用户则是井号<code>#</code>。这个符号是环境变量<code>PS1</code>决定的，执行下面的命令，可以看到当前命令提示符的定义。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FFB757;">$</span><span style="color:#ADDCFF;"> echo</span><span style="color:#F0F3F6;"> $PS1</span></span></code></pre></div><p>Bash 允许用户自定义命令提示符，只要改写这个变量即可。改写后的<code>PS1</code>，可以放在用户的 Bash 配置文件<code>.bashrc</code>里面，以后新建 Bash 对话时，新的提示符就会生效。要在当前窗口看到修改后的提示符，可以执行下面的命令。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FFB757;">$</span><span style="color:#ADDCFF;"> source</span><span style="color:#ADDCFF;"> ~/.bashrc</span></span></code></pre></div><p>命令提示符的定义，可以包含特殊的转义字符，表示特定内容。</p><table><thead><tr><th>转义字符</th><th>说明</th></tr></thead><tbody><tr><td>\\a</td><td>响铃，计算机发出一记声音</td></tr><tr><td>\\d</td><td>以星期、月、日格式表示当前日期，例如“Mon May 26”</td></tr><tr><td>\\h</td><td>本机的主机名</td></tr><tr><td>\\H</td><td>完整的主机名</td></tr><tr><td>\\j</td><td>运行在当前 Shell 会话的工作数</td></tr><tr><td>\\l</td><td>当前终端设备名</td></tr><tr><td>\\n</td><td>一个换行符</td></tr><tr><td>\\r</td><td>一个回车符</td></tr><tr><td>\\s</td><td>Shell 的名称</td></tr><tr><td>\\t</td><td>24小时制的hours:minutes:seconds格式表示当前时间</td></tr><tr><td>\\T</td><td>12小时制的当前时间</td></tr><tr><td>@</td><td>12小时制的AM/PM格式表示当前时间</td></tr><tr><td>\\A</td><td>24小时制的hours:minutes表示当前时间</td></tr><tr><td>\\u</td><td>当前用户名</td></tr><tr><td>\\v</td><td>Shell 的版本号</td></tr><tr><td>\\V</td><td>Shell 的版本号和发布号</td></tr><tr><td>\\w</td><td>当前的工作路径</td></tr><tr><td>\\W</td><td>当前目录名</td></tr><tr><td>!</td><td>当前命令在命令历史中的编号</td></tr><tr><td>#</td><td>当前 shell 会话中的命令数</td></tr><tr><td>$</td><td>普通用户显示为$字符，根用户显示为#字符</td></tr><tr><td>[</td><td>非打印字符序列的开始标志</td></tr><tr><td>]</td><td>非打印字符序列的结束标志</td></tr></tbody></table><p>举例来说，<code>[\\u@\\h \\W]\\$</code>这个提示符定义，显示出来就是<code>[user@host ~]$</code>（具体的显示内容取决于你的系统）。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[user@host </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]$ echo $PS1</span></span>
<span class="line"><span style="color:#F0F3F6;">[</span><span style="color:#FF9492;">\\u</span><span style="color:#F0F3F6;">@</span><span style="color:#FF9492;">\\h</span><span style="color:#FF9492;"> \\W</span><span style="color:#F0F3F6;">]</span><span style="color:#FF9492;">\\$</span></span></code></pre></div><p>改写<code>PS1</code>变量，就可以改变这个命令提示符。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FFB757;">$</span><span style="color:#ADDCFF;"> PS1=&quot;\\A \\h </span><span style="color:#FF9492;">\\$</span><span style="color:#ADDCFF;"> &quot;</span></span>
<span class="line"><span style="color:#FFB757;">17:33</span><span style="color:#ADDCFF;"> host</span><span style="color:#F0F3F6;"> $</span></span></code></pre></div><p>注意，<code>$</code>后面最好跟一个空格，这样的话，用户的输入与提示符就不会连在一起。</p><h3 id="命令的基本格式" tabindex="-1"><a class="header-anchor" href="#命令的基本格式"><span>命令的基本格式</span></a></h3><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>[root@localhost ~]# 命令 [选项] [参数]</span></span></code></pre></div><p>命令格式中的<code>[]</code>代表可选项，也就是有些命令可以不写选项或参数，也能执行。</p><h4 id="选项的作用" tabindex="-1"><a class="header-anchor" href="#选项的作用"><span>选项的作用</span></a></h4><p>Linux 的选项又分为短格式选项（<code>-l</code>）和长格式选项（<code>--all</code>）。短格式选项是英文的简写，用一个减号调用。</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# ls -l</span></span></code></pre></div><p>而长格式选项是英文完整单词，一般用两个减号调用。</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# ls --all</span></span></code></pre></div><p>一般情况下，短格式选项是长格式选项的缩写，也就是一个短格式选项会有对应的长格式选项。当然也有例外，比如<code>ls</code>命令的短格式选项<code>-l</code>就没有对应的长格式选项。</p><p>单个命令一般都是一行，用户按下回车键，就开始执行。有些命令比较长，写成多行会有利于阅读和编辑，这时可以在每一行的结尾加上反斜杠，Bash 就会将下一行跟当前行放在一起解释。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# echo foo bar</span></span>
<span class="line"><span style="color:#BDC4CC;"># 等同于</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# echo foo </span><span style="color:#FF9492;">\\</span></span>
<span class="line"><span style="color:#FFB757;">bar</span></span></code></pre></div><h4 id="参数的作用" tabindex="-1"><a class="header-anchor" href="#参数的作用"><span>参数的作用</span></a></h4><p>参数是命令的操作对象，一般文件、目录、用户和进程等可以作为参数被命令操作。</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# ls -l anaconda-ks.cfg</span></span>
<span class="line"><span style="color:#FFB757;">-rw-------.1</span><span style="color:#ADDCFF;"> root</span><span style="color:#ADDCFF;"> root</span><span style="color:#91CBFF;"> 1207</span><span style="color:#91CBFF;"> 1</span><span style="color:#ADDCFF;"> 月</span><span style="color:#91CBFF;"> 14</span><span style="color:#ADDCFF;"> 18:18</span><span style="color:#ADDCFF;"> anaconda-ks.cfg</span></span></code></pre></div><p>命令一般都需要加入参数，用于指定命令操作的对象是谁。如果可以省略参数，则一般都有默认参数。</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# ls</span></span>
<span class="line"><span style="color:#FFB757;">anaconda-ks.cfg</span><span style="color:#ADDCFF;"> install.log</span><span style="color:#ADDCFF;"> install.log.syslog</span></span></code></pre></div><p>这个<code>ls</code>命令后面没有指定参数，默认参数是当前所在位置，所以会显示当前目录下的文件名。</p><div class="hint-container tip"><p class="hint-container-title">提示</p><p>命令的选项用于调整命令功能，而命令的参数是这个命令的操作对象。</p></div><h3 id="空格" tabindex="-1"><a class="header-anchor" href="#空格"><span>空格</span></a></h3><p>Shell 使用空格（或<code>Tab</code>键）区分不同的参数。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# command foo bar</span></span></code></pre></div><p>上面命令中，<code>foo</code>和<code>bar</code>之间有一个空格，所以 Shell 认为它们是两个参数。</p><p>如果参数之间有多个空格，Shell 会自动忽略多余的空格。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# echo this is a     test</span></span>
<span class="line"><span style="color:#FFB757;">this</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> a</span><span style="color:#ADDCFF;"> test</span></span></code></pre></div><p>上面命令中，<code>a</code>和<code>test</code>之间有多个空格，Shell 会忽略多余的空格。</p><h3 id="分号" tabindex="-1"><a class="header-anchor" href="#分号"><span>分号</span></a></h3><p>分号（<code>;</code>）是命令的结束符，使得一行可以放置多个命令，上一个命令执行结束后，再执行第二个命令。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# clear; </span><span style="color:#FFB757;">ls</span></span></code></pre></div><p>上面例子中，先执行<code>clear</code>命令，执行完成后，再执行<code>ls</code>命令。</p><div class="hint-container warning"><p class="hint-container-title">注意</p><p>注意，使用分号时，第二个命令总是接着第一个命令执行，不管第一个命令执行成功或失败。</p></div><h3 id="命令的组合符-和" tabindex="-1"><a class="header-anchor" href="#命令的组合符-和"><span>命令的组合符&amp;&amp;和||</span></a></h3><p>除了分号，Shell 还提供两个命令组合符<code>&amp;&amp;</code>和<code>||</code>，允许更好地控制多个命令之间的继发关系。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FFB757;">Command1</span><span style="color:#F0F3F6;"> &amp;&amp; </span><span style="color:#FFB757;">Command2</span></span></code></pre></div><p>上面命令的意思是，如果<code>Command1</code>命令运行成功，则继续运行<code>Command2</code>命令。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FFB757;">Command1</span><span style="color:#FF9492;"> ||</span><span style="color:#FFB757;"> Command2</span></span></code></pre></div><p>上面命令的意思是，如果<code>Command1</code>命令运行失败，则继续运行<code>Command2</code>命令。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# cat filelist.txt; </span><span style="color:#FFB757;">ls</span><span style="color:#91CBFF;"> -l</span><span style="color:#ADDCFF;"> filelist.txt</span></span></code></pre></div><p>上面例子中，只要<code>cat</code>命令执行结束，不管成功或失败，都会继续执行<code>ls</code>命令。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# cat filelist.txt &amp;&amp; </span><span style="color:#FFB757;">ls</span><span style="color:#91CBFF;"> -l</span><span style="color:#ADDCFF;"> filelist.txt</span></span></code></pre></div><p>上面例子中，只有<code>cat</code>命令执行成功，才会继续执行<code>ls</code>命令。如果<code>cat</code>执行失败（比如不存在文件<code>flielist.txt</code>），那么<code>ls</code>命令就不会执行。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# mkdir foo </span><span style="color:#FF9492;">||</span><span style="color:#FFB757;"> mkdir</span><span style="color:#ADDCFF;"> bar</span></span></code></pre></div><p>上面例子中，只有<code>mkdir foo</code>命令执行失败（比如<code>foo</code>目录已经存在），才会继续执行<code>mkdir bar</code>命令。如果<code>mkdir foo</code>命令执行成功，就不会创建<code>bar</code>目录了。</p><h3 id="颜色" tabindex="-1"><a class="header-anchor" href="#颜色"><span>颜色</span></a></h3><p>默认情况下，命令提示符是显示终端预定义的颜色。Bash 允许自定义提示符颜色。</p><p>使用下面的代码，可以设定其后文本的颜色。</p><table><thead><tr><th>代码</th><th>颜色</th></tr></thead><tbody><tr><td>\\033[0;30m</td><td>黑色</td></tr><tr><td>\\033[1;30m</td><td>深灰色</td></tr><tr><td>\\033[0;31m</td><td>红色</td></tr><tr><td>\\033[1;31m</td><td>浅红色</td></tr><tr><td>\\033[0;32m</td><td>绿色</td></tr><tr><td>\\033[1;32m</td><td>浅绿色</td></tr><tr><td>\\033[0;33m</td><td>棕色</td></tr><tr><td>\\033[1;33m</td><td>黄色</td></tr><tr><td>\\033[0;34m</td><td>蓝色</td></tr><tr><td>\\033[1;34m</td><td>浅蓝色</td></tr><tr><td>\\033[0;35m</td><td>粉红</td></tr><tr><td>\\033[1;35m</td><td>浅粉色</td></tr><tr><td>\\033[0;36m</td><td>青色</td></tr><tr><td>\\033[1;36m</td><td>浅青色</td></tr><tr><td>\\033[0;37m</td><td>浅灰色</td></tr><tr><td>\\033[1;37m</td><td>白色</td></tr></tbody></table><p>举例来说，如果要将提示符设为红色，可以将·设成下面的代码。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">PS1</span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;">&#39;\\[\\033[0;31m\\]&lt;\\u@\\h \\W&gt;\\$&#39;</span></span></code></pre></div><p>但是，上面这样设置以后，用户在提示符后面输入的文本也是红色的。为了解决这个问题， 可以在结尾添加另一个特殊代码<code>\\[\\033[00m\\]</code>，表示将其后的文本恢复到默认颜色。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">PS1</span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;">&#39;\\[\\033[0;31m\\]&lt;\\u@\\h \\W&gt;\\$\\[\\033[00m\\]&#39;</span></span></code></pre></div><p>除了设置前景颜色，Bash 还允许设置背景颜色。</p><table><thead><tr><th>代码</th><th>颜色</th></tr></thead><tbody><tr><td>\\033[0;40m</td><td>蓝色</td></tr><tr><td>\\033[1;44m</td><td>黑色</td></tr><tr><td>\\033[0;41m</td><td>红色</td></tr><tr><td>\\033[1;45m</td><td>粉红</td></tr><tr><td>\\033[0;42m</td><td>绿色</td></tr><tr><td>\\033[1;46m</td><td>青色</td></tr><tr><td>\\033[0;43m</td><td>棕色</td></tr><tr><td>\\033[1;47m</td><td>浅灰色</td></tr></tbody></table><p>下面是一个带有红色背景的提示符。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">PS1</span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;">&#39;\\[\\033[0;41m\\]&lt;\\u@\\h \\W&gt;\\$\\[\\033[0m\\] &#39;</span></span></code></pre></div><h3 id="环境变量-ps2-ps3-ps4" tabindex="-1"><a class="header-anchor" href="#环境变量-ps2-ps3-ps4"><span>环境变量 PS2，PS3，PS4</span></a></h3><p>除了<code>PS1</code>，Bash 还提供了提示符相关的另外三个环境变量。</p><p>环境变量<code>PS2</code>是命令行折行输入时系统的提示符，默认为<code>&gt;</code>。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FFB757;">$</span><span style="color:#ADDCFF;"> echo</span><span style="color:#ADDCFF;"> &quot;hello</span></span>
<span class="line"><span style="color:#ADDCFF;">&gt; world&quot;</span></span></code></pre></div><p>上面命令中，输入<code>hello</code>以后按下回车键，系统会提示继续输入。这时，第二行显示的提示符就是<code>PS2</code>定义的<code>&gt;</code>。</p><p>环境变量<code>PS3</code>是使用<code>select</code>命令时，系统输入菜单的提示符。</p><p>环境变量<code>PS4</code>默认为<code>+</code>。它是使用 Bash 的<code>-x</code>参数执行脚本时，每一行命令在执行前都会先打印出来，并且在行首出现的那个提示符。</p><p>比如下面是脚本<code>test.sh</code>。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">#!/bin/bash</span></span>
<span class="line"></span>
<span class="line"><span style="color:#91CBFF;">echo</span><span style="color:#ADDCFF;"> &quot;hello world&quot;</span></span></code></pre></div><p>使用<code>-x</code>参数执行这个脚本。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FFB757;">$</span><span style="color:#ADDCFF;"> bash</span><span style="color:#91CBFF;"> -x</span><span style="color:#ADDCFF;"> test.sh</span></span>
<span class="line"><span style="color:#FFB757;">+</span><span style="color:#ADDCFF;"> echo</span><span style="color:#ADDCFF;"> &#39;hello world&#39;</span></span>
<span class="line"><span style="color:#FFB757;">	hello</span><span style="color:#ADDCFF;"> world</span></span></code></pre></div><p>上面例子中，输出的第一行前面有一个<code>+</code>，这就是变量<code>PS4</code>定义的。</p><h2 id="linux命令的执行过程" tabindex="-1"><a class="header-anchor" href="#linux命令的执行过程"><span>Linux命令的执行过程</span></a></h2><p>Linux 命令的执行过程分为如下 4 个步骤：</p><h3 id="_1-判断路径" tabindex="-1"><a class="header-anchor" href="#_1-判断路径"><span>1. 判断路径</span></a></h3><p>判断用户是否以绝对路径或相对路径的方式输入命令（如<code>/bin/ls</code>），如果是的话直接执行。</p><h3 id="_2-检查别名" tabindex="-1"><a class="header-anchor" href="#_2-检查别名"><span>2. 检查别名</span></a></h3><p>Linux 系统会检查用户输入的命令是否为“别名命令”。要知道，通过<code>alias</code>命令是可以给现有命令自定义别名的，即用一个自定义的命令名称来替换原本的命令名称。</p><p>例如，我们经常使用的<code>rm</code>命令，其实就是<code>rm -i</code>这个整体的别名：</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# alias rm</span></span>
<span class="line"><span style="color:#FF9492;">alias</span><span style="color:#F0F3F6;"> rm</span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;">&#39;rm -i&#39;</span></span></code></pre></div><p>这使得当使用<code>rm</code>命令删除指定文件时，Linux 系统会要求我们再次确认是否执行删除操作。</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# rm a.txt </span><span style="color:#FF9492;">&lt;</span><span style="color:#F0F3F6;">-- 假定当前目录中已经存在 a.txt 文件</span></span>
<span class="line"><span style="color:#FFB757;">rm:</span><span style="color:#ADDCFF;"> remove</span><span style="color:#ADDCFF;"> regular</span><span style="color:#ADDCFF;"> file</span><span style="color:#ADDCFF;"> &#39;a.txt&#39;?</span><span style="color:#ADDCFF;"> y</span><span style="color:#FF9492;"> &lt;</span><span style="color:#ADDCFF;">--</span><span style="color:#ADDCFF;"> 手动输入</span><span style="color:#ADDCFF;"> y，即确定删除</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]#</span></span></code></pre></div><p>这里可以使用<code>unalias</code>命令，将 Linux 系统设置的<code>rm</code>别名删除掉：</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# alias rm</span></span>
<span class="line"><span style="color:#FF9492;">alias</span><span style="color:#F0F3F6;"> rm</span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;">&#39;rm -i&#39;</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# unalias rm</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# rm a.txt</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# </span><span style="color:#FF9492;">&lt;</span><span style="color:#F0F3F6;">--直接删除，不再询问</span></span></code></pre></div><h3 id="_3-判断是内部命令还是外部命令" tabindex="-1"><a class="header-anchor" href="#_3-判断是内部命令还是外部命令"><span>3. 判断是内部命令还是外部命令</span></a></h3><p>shell 会判断用户输入的命令是内部命令还是外部命令。内部命令会被直接执行；而外部命令交给步骤四继续处理。</p><p>内部命令由 Shell 自带，会随着系统启动，可以直接从内存中读取；而外部命令仅是在系统中有对应的可执行文件，执行时需要读取该文件。</p><p>判断一个命令属于内部命令还是外部命令，可以使用<code>type</code>命令实现。</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# type pwd</span></span>
<span class="line"><span style="color:#91CBFF;">pwd</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> a</span><span style="color:#ADDCFF;"> shell</span><span style="color:#ADDCFF;"> builtin</span><span style="color:#FF9492;"> &lt;</span><span style="color:#ADDCFF;">--</span><span style="color:#ADDCFF;"> pwd是内部命令</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# type top</span></span>
<span class="line"><span style="color:#FFB757;">top</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> /usr/bin/top</span><span style="color:#FF9492;"> &lt;</span><span style="color:#ADDCFF;">--</span><span style="color:#ADDCFF;"> top是外部命令</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# type type</span></span>
<span class="line"><span style="color:#91CBFF;">type</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> a</span><span style="color:#ADDCFF;"> shell</span><span style="color:#ADDCFF;"> builtin</span><span style="color:#FF9492;"> &lt;</span><span style="color:#ADDCFF;">--</span><span style="color:#ADDCFF;"> type本身也是内置命令</span></span></code></pre></div><p>如果要查看一个命令的所有定义，可以使用<code>type -a</code>。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# type -a echo</span></span>
<span class="line"><span style="color:#91CBFF;">echo</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> shell</span><span style="color:#ADDCFF;"> builtin</span></span>
<span class="line"><span style="color:#91CBFF;">echo</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> /usr/bin/echo</span></span></code></pre></div><p>上面代码表示，<code>echo</code>命令既是内置命令，也有对应的外部程序。</p><p><code>type -t</code>可以返回一个命令的类型：别名（<code>alias</code>），关键词（<code>keyword</code>），函数（<code>function</code>），内置命令（<code>builtin</code>）和文件（<code>file</code>）。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# type -t bash</span></span>
<span class="line"><span style="color:#FFB757;">file</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# type -t </span><span style="color:#FF9492;">if</span></span>
<span class="line"><span style="color:#FFB757;">keyword</span></span></code></pre></div><p>上面例子中，<code>bash</code>是文件，<code>if</code>是关键词。</p><h3 id="_4-查找外部命令对应的可执行文件" tabindex="-1"><a class="header-anchor" href="#_4-查找外部命令对应的可执行文件"><span>4. 查找外部命令对应的可执行文件</span></a></h3><p>当用户执行的是外部命令时，系统会在指定的多个路径中查找该命令的可执行文件，而定义这些路径的变量，就称为<code>PATH</code>环境变量，其作用就是告诉 Shell 待执行命令的可执行文件可能存放的位置，也就是说，Shell 会在<code>PATH</code>变量包含的多个路径中逐个查找，直到找到为止（如果找不到，Shell 会提供用户“找不到此命令”）。</p><h2 id="行操作" tabindex="-1"><a class="header-anchor" href="#行操作"><span>行操作</span></a></h2><p>Bash 内置了 Readline 库，具有这个库提供的很多“行操作”功能，比如命令的自动补全，可以大大加快操作速度。</p><p>这个库默认采用 Emacs 快捷键，也可以改成 Vi 快捷键。</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FFB757;">$</span><span style="color:#ADDCFF;"> set</span><span style="color:#91CBFF;"> -o</span><span style="color:#ADDCFF;"> vi</span></span></code></pre></div><p>下面的命令可以改回 Emacs 快捷键。</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FFB757;">$</span><span style="color:#ADDCFF;"> set</span><span style="color:#91CBFF;"> -o</span><span style="color:#ADDCFF;"> emacs</span></span></code></pre></div><p>如果想永久性更改编辑模式（Emacs/Vi），可以将命令写在<code>~/.inputrc</code>文件，这个文件是 Readline 的配置文件。</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#91CBFF;">set</span><span style="color:#ADDCFF;"> editing-mode</span><span style="color:#ADDCFF;"> vi</span></span></code></pre></div><p>Bash 默认开启这个库，但是允许关闭。</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FFB757;">$</span><span style="color:#ADDCFF;"> bash</span><span style="color:#91CBFF;"> --noediting</span></span></code></pre></div><p>上面命令中，<code>--noediting</code>参数关闭了 Readline 库，启动的 Bash 就不带有行操作功能。</p><h3 id="常用快捷键" tabindex="-1"><a class="header-anchor" href="#常用快捷键"><span>常用快捷键</span></a></h3><p>Readline 提供的快捷键：</p><table><thead><tr><th>快捷键</th><th>说明</th></tr></thead><tbody><tr><td><code>Ctrl + a</code></td><td>移到行首</td></tr><tr><td><code>Ctrl + b</code></td><td>向行首移动一个字符，与左箭头作用相同</td></tr><tr><td><code>Ctrl + e</code></td><td>移到行尾</td></tr><tr><td><code>Ctrl + f</code></td><td>向行尾移动一个字符，与右箭头作用相同</td></tr><tr><td><code>Alt + f</code></td><td>移动到当前单词的词尾</td></tr><tr><td><code>Alt + b</code></td><td>移动到当前单词的词首</td></tr><tr><td><code>Ctrl + l</code></td><td>清除屏幕，即将当前行移到屏幕的第一行，与<code>clear</code>命令作用相同</td></tr><tr><td><code>Ctrl + d</code></td><td>删除光标位置的字符（<code>delete</code>）</td></tr><tr><td><code>Ctrl + w</code></td><td>删除光标前一个单词</td></tr><tr><td><code>Ctrl + t</code></td><td>光标位置的字符与它前面一位的字符交换位置（<code>transpose</code>）</td></tr><tr><td><code>Alt + t</code></td><td>光标位置的词与它前面一位的词交换位置（<code>transpose</code>）</td></tr><tr><td><code>Alt + l</code></td><td>将光标位置至词尾转为小写（<code>lowercase</code>）</td></tr><tr><td><code>Alt + u</code></td><td>将光标位置至词尾转为大写（<code>uppercase</code>）</td></tr><tr><td><code>Ctrl + k</code></td><td>剪切光标位置到行尾的文本</td></tr><tr><td><code>Ctrl + u</code></td><td>剪切光标位置到行首的文本</td></tr><tr><td><code>Alt + d</code></td><td>剪切光标位置到词尾的文本</td></tr><tr><td><code>Alt + Backspace</code></td><td>剪切光标位置到词首的文本</td></tr><tr><td><code>Ctrl + y</code></td><td>在光标位置粘贴文本</td></tr><tr><td><code>Ctrl + c</code></td><td>终止当前正在执行的命令</td></tr><tr><td><code>Shift + PageUp</code></td><td>向上滚动</td></tr><tr><td><code>Shift + PageDown</code></td><td>向下滚动</td></tr></tbody></table><p>使用<code>Ctrl + d</code>的时候，如果当前行没有任何字符，会导致退出当前 Shell，所以要小心。</p><p><code>Alt</code>键可以用<code>Esc</code>键代替。</p><h3 id="自动补全" tabindex="-1"><a class="header-anchor" href="#自动补全"><span>自动补全</span></a></h3><p>命令输入到一半的时候，可以按一下<code>Tab</code>键，Readline 会自动补全命令或路径。比如，输入<code>cle</code>，再按下<code>Tab</code>键，Bash 会自动将这个命令补全为<code>clear</code>。</p><p>如果符合条件的命令或路径有多个，就需要连续按两次<code>Tab</code>键，Bash 会提示所有符合条件的命令或路径。</p><p>除了命令或路径，<code>Tab</code>还可以补全其他值。如果一个值以<code>$</code>开头，则按下<code>Tab</code>键会补全变量；如果以<code>~</code>开头，则补全用户名；如果以<code>@</code>开头，则补全主机名（<code>hostname</code>），主机名以列在<code>/etc/hosts</code>文件里面的主机为准。</p><p>自动补全相关的快捷键。</p><table><thead><tr><th>快捷键</th><th>说明</th></tr></thead><tbody><tr><td><code>Tab</code></td><td>完成自动补全。</td></tr><tr><td><code>Alt + ?</code></td><td>列出可能的补全，与连按两次 Tab 键作用相同。</td></tr><tr><td><code>Alt + /</code></td><td>尝试文件路径补全。</td></tr><tr><td><code>Ctrl + x /</code></td><td>先按<code>Ctrl + x</code>，再按/，等同于<code>Alt + ?</code>，列出可能的文件路径补全。</td></tr><tr><td><code>Alt + !</code></td><td>命令补全。</td></tr><tr><td><code>Ctrl + x !</code></td><td>先按<code>Ctrl + x</code>，再按!，等同于<code>Alt + !</code>，命令补全。</td></tr><tr><td><code>Alt + ~</code></td><td>用户名补全。</td></tr><tr><td><code>Ctrl + x ~</code></td><td>先按<code>Ctrl + x</code>，再按~，等同于<code>Alt + ~</code>，用户名补全。</td></tr><tr><td><code>Alt + $</code></td><td>变量名补全。</td></tr><tr><td><code>Ctrl + x $</code></td><td>先按<code>Ctrl + x</code>，再按$，等同于<code>Alt + $</code>，变量名补全。</td></tr><tr><td><code>Alt + @</code></td><td>主机名补全。</td></tr><tr><td><code>Ctrl + x @</code></td><td>先按<code>Ctrl + x</code>，再按@，等同于<code>Alt + @</code>，主机名补全。</td></tr><tr><td><code>Alt + *</code></td><td>在命令行一次性插入所有可能的补全。</td></tr><tr><td><code>Alt + Tab</code></td><td>尝试用<code>.bash_history</code>里面以前执行命令，进行补全。</td></tr></tbody></table><p>上面的<code>Alt</code>键也可以用<code>ESC</code>键代替。</p>`,136)]))}const r=a(e,[["render",d],["__file","Linux入门.html.vue"]]),i=JSON.parse('{"path":"/linux/linux%E5%9F%BA%E7%A1%80/Linux%E5%85%A5%E9%97%A8.html","title":"Linux入门","lang":"zh-CN","frontmatter":{"title":"Linux入门","date":"2024-02-05T00:00:00.000Z","tags":"linux基础","categories":"linux","order":1,"description":"命令格式 命令提示符 登录系统后，第一眼看到的内容是： 这就是 Linux 系统的命令提示符。 []：这是提示符的分隔符号，没有特殊含义 root：显示的是当前的登录用户 @：分隔符号，没有特殊含义 localhost：当前系统的简写主机名（完整主机名是localhost.localdomain） ~：代表用户当前所在的目录，此例中用户当前所在的目录是...","head":[["meta",{"property":"og:url","content":"https://wsq01.github.io/wsq-blog/linux/linux%E5%9F%BA%E7%A1%80/Linux%E5%85%A5%E9%97%A8.html"}],["meta",{"property":"og:title","content":"Linux入门"}],["meta",{"property":"og:description","content":"命令格式 命令提示符 登录系统后，第一眼看到的内容是： 这就是 Linux 系统的命令提示符。 []：这是提示符的分隔符号，没有特殊含义 root：显示的是当前的登录用户 @：分隔符号，没有特殊含义 localhost：当前系统的简写主机名（完整主机名是localhost.localdomain） ~：代表用户当前所在的目录，此例中用户当前所在的目录是..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-04-23T09:49:11.000Z"}],["meta",{"property":"article:published_time","content":"2024-02-05T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-04-23T09:49:11.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Linux入门\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-02-05T00:00:00.000Z\\",\\"dateModified\\":\\"2025-04-23T09:49:11.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"WSQ\\",\\"url\\":\\"https://wsq01.github.com\\"}]}"]]},"headers":[{"level":2,"title":"命令格式","slug":"命令格式","link":"#命令格式","children":[{"level":3,"title":"命令提示符","slug":"命令提示符","link":"#命令提示符","children":[]},{"level":3,"title":"环境变量 PS1","slug":"环境变量-ps1","link":"#环境变量-ps1","children":[]},{"level":3,"title":"命令的基本格式","slug":"命令的基本格式","link":"#命令的基本格式","children":[]},{"level":3,"title":"空格","slug":"空格","link":"#空格","children":[]},{"level":3,"title":"分号","slug":"分号","link":"#分号","children":[]},{"level":3,"title":"命令的组合符&&和||","slug":"命令的组合符-和","link":"#命令的组合符-和","children":[]},{"level":3,"title":"颜色","slug":"颜色","link":"#颜色","children":[]},{"level":3,"title":"环境变量 PS2，PS3，PS4","slug":"环境变量-ps2-ps3-ps4","link":"#环境变量-ps2-ps3-ps4","children":[]}]},{"level":2,"title":"Linux命令的执行过程","slug":"linux命令的执行过程","link":"#linux命令的执行过程","children":[{"level":3,"title":"1. 判断路径","slug":"_1-判断路径","link":"#_1-判断路径","children":[]},{"level":3,"title":"2. 检查别名","slug":"_2-检查别名","link":"#_2-检查别名","children":[]},{"level":3,"title":"3. 判断是内部命令还是外部命令","slug":"_3-判断是内部命令还是外部命令","link":"#_3-判断是内部命令还是外部命令","children":[]},{"level":3,"title":"4. 查找外部命令对应的可执行文件","slug":"_4-查找外部命令对应的可执行文件","link":"#_4-查找外部命令对应的可执行文件","children":[]}]},{"level":2,"title":"行操作","slug":"行操作","link":"#行操作","children":[{"level":3,"title":"常用快捷键","slug":"常用快捷键","link":"#常用快捷键","children":[]},{"level":3,"title":"自动补全","slug":"自动补全","link":"#自动补全","children":[]}]}],"git":{"createdTime":1723619297000,"updatedTime":1745401751000,"contributors":[{"name":"WSQ","email":"592786982@qq.com","commits":3}]},"readingTime":{"minutes":13.03,"words":3910},"filePathRelative":"linux/linux基础/Linux入门.md","localizedDate":"2024年2月5日","autoDesc":true}');export{r as comp,i as data};
