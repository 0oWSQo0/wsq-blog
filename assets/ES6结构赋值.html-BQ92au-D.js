import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,d as l,o}from"./app-ByvFWdWZ.js";const p={};function F(e,s){return o(),n("div",null,s[0]||(s[0]=[l(`<h2 id="数组的解构赋值" tabindex="-1"><a class="header-anchor" href="#数组的解构赋值"><span>数组的解构赋值</span></a></h2><h3 id="基本用法" tabindex="-1"><a class="header-anchor" href="#基本用法"><span>基本用法</span></a></h3><p>ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构。<br> 以前，为变量赋值，只能直接指定值。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> a </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 1</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> b </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 2</span><span style="color:#F0F3F6;">;</span></span></code></pre></div><p>ES6允许写成下面这样。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> [a, b, c] </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [</span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">3</span><span style="color:#F0F3F6;">];</span></span></code></pre></div><p>本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> [foo, [[bar], baz]] </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [</span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">, [[</span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">], </span><span style="color:#91CBFF;">3</span><span style="color:#F0F3F6;">]];</span></span>
<span class="line"><span style="color:#F0F3F6;">foo </span><span style="color:#BDC4CC;">// 1</span></span>
<span class="line"><span style="color:#F0F3F6;">bar </span><span style="color:#BDC4CC;">// 2</span></span>
<span class="line"><span style="color:#F0F3F6;">baz </span><span style="color:#BDC4CC;">// 3</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> [ , , third] </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [</span><span style="color:#ADDCFF;">&quot;foo&quot;</span><span style="color:#F0F3F6;">, </span><span style="color:#ADDCFF;">&quot;bar&quot;</span><span style="color:#F0F3F6;">, </span><span style="color:#ADDCFF;">&quot;baz&quot;</span><span style="color:#F0F3F6;">];</span></span>
<span class="line"><span style="color:#F0F3F6;">third </span><span style="color:#BDC4CC;">// &quot;baz&quot;</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> [x, , y] </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [</span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">3</span><span style="color:#F0F3F6;">];</span></span>
<span class="line"><span style="color:#F0F3F6;">x </span><span style="color:#BDC4CC;">// 1</span></span>
<span class="line"><span style="color:#F0F3F6;">y </span><span style="color:#BDC4CC;">// 3</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> [head, </span><span style="color:#FF9492;">...</span><span style="color:#F0F3F6;">tail] </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [</span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">3</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">4</span><span style="color:#F0F3F6;">];</span></span>
<span class="line"><span style="color:#F0F3F6;">head </span><span style="color:#BDC4CC;">// 1</span></span>
<span class="line"><span style="color:#F0F3F6;">tail </span><span style="color:#BDC4CC;">// [2, 3, 4]</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> [x, y, </span><span style="color:#FF9492;">...</span><span style="color:#F0F3F6;">z] </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [</span><span style="color:#ADDCFF;">&#39;a&#39;</span><span style="color:#F0F3F6;">];</span></span>
<span class="line"><span style="color:#F0F3F6;">x </span><span style="color:#BDC4CC;">// &quot;a&quot;</span></span>
<span class="line"><span style="color:#F0F3F6;">y </span><span style="color:#BDC4CC;">// undefined</span></span>
<span class="line"><span style="color:#F0F3F6;">z </span><span style="color:#BDC4CC;">// []</span></span></code></pre></div><p>如果解构不成功，变量的值就等于<code>undefined</code>。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> [foo] </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [];  </span><span style="color:#BDC4CC;">//foo undefined</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> [bar, foo] </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [</span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">]; </span><span style="color:#BDC4CC;">// foo undefined</span></span></code></pre></div><p>另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> [x, y] </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [</span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">3</span><span style="color:#F0F3F6;">];</span></span>
<span class="line"><span style="color:#F0F3F6;">x </span><span style="color:#BDC4CC;">// 1</span></span>
<span class="line"><span style="color:#F0F3F6;">y </span><span style="color:#BDC4CC;">// 2</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> [a, [b], d] </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [</span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">, [</span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">3</span><span style="color:#F0F3F6;">], </span><span style="color:#91CBFF;">4</span><span style="color:#F0F3F6;">];</span></span>
<span class="line"><span style="color:#F0F3F6;">a </span><span style="color:#BDC4CC;">// 1</span></span>
<span class="line"><span style="color:#F0F3F6;">b </span><span style="color:#BDC4CC;">// 2</span></span>
<span class="line"><span style="color:#F0F3F6;">d </span><span style="color:#BDC4CC;">// 4</span></span></code></pre></div><p>如果等号的右边不是数组（或不是可遍历的结构），那么将会报错。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">// 报错</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> [foo] </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 1</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> [foo] </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> false</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> [foo] </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> NaN</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> [foo] </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> undefined</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> [foo] </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> null</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> [foo] </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> {};</span></span></code></pre></div><p>解构赋值不仅适用于<code>var</code>命令，也适用于<code>let</code>和<code>const</code>命令。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> [v1, v2, ..., vN ] </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> array;</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> [v1, v2, ..., vN ] </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> array;</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#F0F3F6;"> [</span><span style="color:#91CBFF;">v1</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">v2</span><span style="color:#F0F3F6;">, ..., </span><span style="color:#91CBFF;">vN</span><span style="color:#F0F3F6;"> ] </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> array;</span></span></code></pre></div><p>对于<code>Set</code>结构，也可以使用数组的解构赋值。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> [x, y, z] </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> Set</span><span style="color:#F0F3F6;">([</span><span style="color:#ADDCFF;">&quot;a&quot;</span><span style="color:#F0F3F6;">, </span><span style="color:#ADDCFF;">&quot;b&quot;</span><span style="color:#F0F3F6;">, </span><span style="color:#ADDCFF;">&quot;c&quot;</span><span style="color:#F0F3F6;">]);</span></span>
<span class="line"><span style="color:#F0F3F6;">x </span><span style="color:#BDC4CC;">// &quot;a&quot;</span></span></code></pre></div><p>事实上，只要某种数据结构具有<code>Iterator</code>接口，都可以采用数组形式的解构赋值。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">function*</span><span style="color:#DBB7FF;"> fibs</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#FF9492;">  var</span><span style="color:#F0F3F6;"> a </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 0</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">  var</span><span style="color:#F0F3F6;"> b </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 1</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">  while</span><span style="color:#F0F3F6;"> (</span><span style="color:#91CBFF;">true</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#FF9492;">    yield</span><span style="color:#F0F3F6;"> a;</span></span>
<span class="line"><span style="color:#F0F3F6;">    [a, b] </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [b, a </span><span style="color:#FF9492;">+</span><span style="color:#F0F3F6;"> b];</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> [first, second, third, fourth, fifth, sixth] </span><span style="color:#FF9492;">=</span><span style="color:#DBB7FF;"> fibs</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#F0F3F6;">sixth </span><span style="color:#BDC4CC;">// 5</span></span></code></pre></div><p>上面代码中，<code>fibs</code>是一个<code>Generator</code>函数，原生具有<code>Iterator</code>接口。解构赋值会依次从这个接口获取值。</p><h3 id="默认值" tabindex="-1"><a class="header-anchor" href="#默认值"><span>默认值</span></a></h3><p>解构赋值允许指定默认值。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> [foo </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> true</span><span style="color:#F0F3F6;">] </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [];   foo </span><span style="color:#BDC4CC;">// true</span></span>
<span class="line"><span style="color:#F0F3F6;">[x, y </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &#39;b&#39;</span><span style="color:#F0F3F6;">] </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [</span><span style="color:#ADDCFF;">&#39;a&#39;</span><span style="color:#F0F3F6;">]; </span><span style="color:#BDC4CC;">// x=&#39;a&#39;, y=&#39;b&#39;</span></span>
<span class="line"><span style="color:#F0F3F6;">[x, y </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &#39;b&#39;</span><span style="color:#F0F3F6;">] </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [</span><span style="color:#ADDCFF;">&#39;a&#39;</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">undefined</span><span style="color:#F0F3F6;">]; </span><span style="color:#BDC4CC;">// x=&#39;a&#39;, y=&#39;b&#39;</span></span></code></pre></div><p>注意，ES6内部使用严格相等运算符（===），判断一个位置是否有值。所以，如果一个数组成员不严格等于<code>undefined</code>，默认值是不会生效的。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> [x </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 1</span><span style="color:#F0F3F6;">] </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [</span><span style="color:#91CBFF;">undefined</span><span style="color:#F0F3F6;">];</span></span>
<span class="line"><span style="color:#F0F3F6;">x </span><span style="color:#BDC4CC;">// 1</span></span>
<span class="line"><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> [x </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 1</span><span style="color:#F0F3F6;">] </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [</span><span style="color:#91CBFF;">null</span><span style="color:#F0F3F6;">];</span></span>
<span class="line"><span style="color:#F0F3F6;">x </span><span style="color:#BDC4CC;">// null</span></span></code></pre></div><p>上面代码中，如果一个数组成员是<code>null</code>，默认值就不会生效，因为<code>null</code>不严格等于<code>undefined</code>。<br> 如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">function</span><span style="color:#DBB7FF;"> f</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#F0F3F6;">  console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;aaa&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> [x </span><span style="color:#FF9492;">=</span><span style="color:#DBB7FF;"> f</span><span style="color:#F0F3F6;">()] </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [</span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">];</span></span></code></pre></div><p>上面代码中，因为<code>x</code>能取到值，所以函数<code>f</code>根本不会执行。上面的代码其实等价于下面的代码。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> x;</span></span>
<span class="line"><span style="color:#FF9492;">if</span><span style="color:#F0F3F6;"> ([</span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">][</span><span style="color:#91CBFF;">0</span><span style="color:#F0F3F6;">] </span><span style="color:#FF9492;">===</span><span style="color:#91CBFF;"> undefined</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#F0F3F6;">  x </span><span style="color:#FF9492;">=</span><span style="color:#DBB7FF;"> f</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#F0F3F6;">} </span><span style="color:#FF9492;">else</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">  x </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [</span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">][</span><span style="color:#91CBFF;">0</span><span style="color:#F0F3F6;">];</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>默认值可以引用解构赋值的其他变量，但该变量必须已经声明。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> [x </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 1</span><span style="color:#F0F3F6;">, y </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> x] </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [];     </span><span style="color:#BDC4CC;">// x=1; y=1</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> [x </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 1</span><span style="color:#F0F3F6;">, y </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> x] </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [</span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">];    </span><span style="color:#BDC4CC;">// x=2; y=2</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> [x </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 1</span><span style="color:#F0F3F6;">, y </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> x] </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [</span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">]; </span><span style="color:#BDC4CC;">// x=1; y=2</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> [x </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> y, y </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 1</span><span style="color:#F0F3F6;">] </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [];     </span><span style="color:#BDC4CC;">// ReferenceError</span></span></code></pre></div><p>上面最后一个表达式之所以会报错，是因为<code>x</code>用到默认值<code>y</code>时，<code>y</code>还没有声明。</p><h2 id="对象的解构赋值" tabindex="-1"><a class="header-anchor" href="#对象的解构赋值"><span>对象的解构赋值</span></a></h2><p>解构不仅可以用于数组，还可以用于对象。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> { foo, bar } </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> { foo: </span><span style="color:#ADDCFF;">&quot;aaa&quot;</span><span style="color:#F0F3F6;">, bar: </span><span style="color:#ADDCFF;">&quot;bbb&quot;</span><span style="color:#F0F3F6;"> };</span></span>
<span class="line"><span style="color:#F0F3F6;">foo </span><span style="color:#BDC4CC;">// &quot;aaa&quot;</span></span>
<span class="line"><span style="color:#F0F3F6;">bar </span><span style="color:#BDC4CC;">// &quot;bbb&quot;</span></span></code></pre></div><p>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> { bar, foo } </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> { foo: </span><span style="color:#ADDCFF;">&quot;aaa&quot;</span><span style="color:#F0F3F6;">, bar: </span><span style="color:#ADDCFF;">&quot;bbb&quot;</span><span style="color:#F0F3F6;"> };</span></span>
<span class="line"><span style="color:#F0F3F6;">foo </span><span style="color:#BDC4CC;">// &quot;aaa&quot;</span></span>
<span class="line"><span style="color:#F0F3F6;">bar </span><span style="color:#BDC4CC;">// &quot;bbb&quot;</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> { baz } </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> { foo: </span><span style="color:#ADDCFF;">&quot;aaa&quot;</span><span style="color:#F0F3F6;">, bar: </span><span style="color:#ADDCFF;">&quot;bbb&quot;</span><span style="color:#F0F3F6;"> };</span></span>
<span class="line"><span style="color:#F0F3F6;">baz </span><span style="color:#BDC4CC;">// undefined</span></span></code></pre></div><p>如果变量名与属性名不一致，必须写成下面这样。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> { </span><span style="color:#FFB757;">foo</span><span style="color:#F0F3F6;">: baz } </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> { foo: </span><span style="color:#ADDCFF;">&#39;aaa&#39;</span><span style="color:#F0F3F6;">, bar: </span><span style="color:#ADDCFF;">&#39;bbb&#39;</span><span style="color:#F0F3F6;"> };</span></span>
<span class="line"><span style="color:#F0F3F6;">baz </span><span style="color:#BDC4CC;">// &quot;aaa&quot;</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> obj </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> { first: </span><span style="color:#ADDCFF;">&#39;hello&#39;</span><span style="color:#F0F3F6;">, last: </span><span style="color:#ADDCFF;">&#39;world&#39;</span><span style="color:#F0F3F6;"> };</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> { </span><span style="color:#FFB757;">first</span><span style="color:#F0F3F6;">: f, </span><span style="color:#FFB757;">last</span><span style="color:#F0F3F6;">: l } </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> obj;</span></span>
<span class="line"><span style="color:#F0F3F6;">f </span><span style="color:#BDC4CC;">// &#39;hello&#39;</span></span>
<span class="line"><span style="color:#F0F3F6;">l </span><span style="color:#BDC4CC;">// &#39;world&#39;</span></span></code></pre></div><p>这实际上说明，对象的解构赋值是下面形式的简写。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> { </span><span style="color:#FFB757;">foo</span><span style="color:#F0F3F6;">: foo, </span><span style="color:#FFB757;">bar</span><span style="color:#F0F3F6;">: bar } </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> { foo: </span><span style="color:#ADDCFF;">&quot;aaa&quot;</span><span style="color:#F0F3F6;">, bar: </span><span style="color:#ADDCFF;">&quot;bbb&quot;</span><span style="color:#F0F3F6;"> };</span></span></code></pre></div><p>也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> { </span><span style="color:#FFB757;">foo</span><span style="color:#F0F3F6;">: baz } </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> { foo: </span><span style="color:#ADDCFF;">&quot;aaa&quot;</span><span style="color:#F0F3F6;">, bar: </span><span style="color:#ADDCFF;">&quot;bbb&quot;</span><span style="color:#F0F3F6;"> };</span></span>
<span class="line"><span style="color:#F0F3F6;">baz </span><span style="color:#BDC4CC;">// &quot;aaa&quot;</span></span>
<span class="line"><span style="color:#F0F3F6;">foo </span><span style="color:#BDC4CC;">// error: foo is not defined</span></span></code></pre></div><p>上面代码中，<code>foo</code>是匹配的模式，<code>baz</code>才是变量。真正被赋值的是变量<code>baz</code>，而不是模式<code>foo</code>。<br> 与数组一样，解构也可以用于嵌套结构的对象。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> obj </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">  p: [</span></span>
<span class="line"><span style="color:#ADDCFF;">    &#39;Hello&#39;</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#F0F3F6;">    { y: </span><span style="color:#ADDCFF;">&#39;World&#39;</span><span style="color:#F0F3F6;"> }</span></span>
<span class="line"><span style="color:#F0F3F6;">  ]</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> { </span><span style="color:#FFB757;">p</span><span style="color:#F0F3F6;">: [x, { y }] } </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> obj;</span></span>
<span class="line"><span style="color:#F0F3F6;">x </span><span style="color:#BDC4CC;">// &quot;Hello&quot;</span></span>
<span class="line"><span style="color:#F0F3F6;">y </span><span style="color:#BDC4CC;">// &quot;World&quot;</span></span></code></pre></div><p>注意，这时<code>p</code>是模式，不是变量，因此不会被赋值。如果<code>p</code>也要作为变量赋值，可以写成下面这样。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> obj </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">  p: [</span></span>
<span class="line"><span style="color:#ADDCFF;">    &#39;Hello&#39;</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#F0F3F6;">    { y: </span><span style="color:#ADDCFF;">&#39;World&#39;</span><span style="color:#F0F3F6;"> }</span></span>
<span class="line"><span style="color:#F0F3F6;">  ]</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> { p, </span><span style="color:#FFB757;">p</span><span style="color:#F0F3F6;">: [x, { y }] } </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> obj;</span></span>
<span class="line"><span style="color:#F0F3F6;">x </span><span style="color:#BDC4CC;">// &quot;Hello&quot;</span></span>
<span class="line"><span style="color:#F0F3F6;">y </span><span style="color:#BDC4CC;">// &quot;World&quot;</span></span>
<span class="line"><span style="color:#F0F3F6;">p </span><span style="color:#BDC4CC;">// [&quot;Hello&quot;, {y: &quot;World&quot;}]</span></span></code></pre></div><p>下面是另一个例子。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> node </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">  loc: {</span></span>
<span class="line"><span style="color:#F0F3F6;">    start: {</span></span>
<span class="line"><span style="color:#F0F3F6;">      line: </span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#F0F3F6;">      column: </span><span style="color:#91CBFF;">5</span></span>
<span class="line"><span style="color:#F0F3F6;">    }</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span>
<span class="line"><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> { loc, </span><span style="color:#FFB757;">loc</span><span style="color:#F0F3F6;">: { start }, </span><span style="color:#FFB757;">loc</span><span style="color:#F0F3F6;">: { </span><span style="color:#FFB757;">start</span><span style="color:#F0F3F6;">: { line }} } </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> node;</span></span>
<span class="line"><span style="color:#F0F3F6;">line </span><span style="color:#BDC4CC;">// 1</span></span>
<span class="line"><span style="color:#F0F3F6;">loc  </span><span style="color:#BDC4CC;">// Object {start: Object}</span></span>
<span class="line"><span style="color:#F0F3F6;">start </span><span style="color:#BDC4CC;">// Object {line: 1, column: 5}</span></span></code></pre></div><p>上面代码有三次解构赋值，分别是对<code>loc</code>、<code>start</code>、<code>line</code>三个属性的解构赋值。注意，最后一次对<code>line</code>属性的解构赋值之中，只有<code>line</code>是变量，<code>loc</code>和<code>start</code>都是模式，不是变量。<br> 下面是嵌套赋值的例子。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> obj </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> {};</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> arr </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [];</span></span>
<span class="line"><span style="color:#F0F3F6;">({ foo: obj.prop, bar: arr[</span><span style="color:#91CBFF;">0</span><span style="color:#F0F3F6;">] } </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> { foo: </span><span style="color:#91CBFF;">123</span><span style="color:#F0F3F6;">, bar: </span><span style="color:#91CBFF;">true</span><span style="color:#F0F3F6;"> });</span></span>
<span class="line"><span style="color:#F0F3F6;">obj </span><span style="color:#BDC4CC;">// {prop:123}</span></span>
<span class="line"><span style="color:#F0F3F6;">arr </span><span style="color:#BDC4CC;">// [true]</span></span></code></pre></div><p>对象的解构也可以指定默认值。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> {x </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 3</span><span style="color:#F0F3F6;">} </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> {};</span></span>
<span class="line"><span style="color:#F0F3F6;">x </span><span style="color:#BDC4CC;">// 3</span></span>
<span class="line"><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> {x, y </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 5</span><span style="color:#F0F3F6;">} </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> {x: </span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">};</span></span>
<span class="line"><span style="color:#F0F3F6;">x </span><span style="color:#BDC4CC;">// 1</span></span>
<span class="line"><span style="color:#F0F3F6;">y </span><span style="color:#BDC4CC;">// 5</span></span>
<span class="line"><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> {</span><span style="color:#FFB757;">x</span><span style="color:#F0F3F6;">: y </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 3</span><span style="color:#F0F3F6;">} </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> {};</span></span>
<span class="line"><span style="color:#F0F3F6;">y </span><span style="color:#BDC4CC;">// 3</span></span>
<span class="line"><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> {</span><span style="color:#FFB757;">x</span><span style="color:#F0F3F6;">: y </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 3</span><span style="color:#F0F3F6;">} </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> {x: </span><span style="color:#91CBFF;">5</span><span style="color:#F0F3F6;">};</span></span>
<span class="line"><span style="color:#F0F3F6;">y </span><span style="color:#BDC4CC;">// 5</span></span>
<span class="line"><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> { </span><span style="color:#FFB757;">message</span><span style="color:#F0F3F6;">: msg </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &#39;Something went wrong&#39;</span><span style="color:#F0F3F6;"> } </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> {};</span></span>
<span class="line"><span style="color:#F0F3F6;">msg </span><span style="color:#BDC4CC;">// &quot;Something went wrong&quot;</span></span></code></pre></div><p>默认值生效的条件是，对象的属性值严格等于<code>undefined</code>。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> {x </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 3</span><span style="color:#F0F3F6;">} </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> {x: </span><span style="color:#91CBFF;">undefined</span><span style="color:#F0F3F6;">};</span></span>
<span class="line"><span style="color:#F0F3F6;">x </span><span style="color:#BDC4CC;">// 3</span></span>
<span class="line"><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> {x </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 3</span><span style="color:#F0F3F6;">} </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> {x: </span><span style="color:#91CBFF;">null</span><span style="color:#F0F3F6;">};</span></span>
<span class="line"><span style="color:#F0F3F6;">x </span><span style="color:#BDC4CC;">// null</span></span></code></pre></div><p>上面代码中，如果<code>x</code>属性等于<code>null</code>，就不严格相等于<code>undefined</code>，导致默认值不会生效。<br> 如果解构失败，变量的值等于<code>undefined</code>。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> {foo} </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> {bar: </span><span style="color:#ADDCFF;">&#39;baz&#39;</span><span style="color:#F0F3F6;">};</span></span>
<span class="line"><span style="color:#F0F3F6;">foo </span><span style="color:#BDC4CC;">// undefined</span></span></code></pre></div><p>如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">// 报错</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> {</span><span style="color:#FFB757;">foo</span><span style="color:#F0F3F6;">: {bar}} </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> {baz: </span><span style="color:#ADDCFF;">&#39;baz&#39;</span><span style="color:#F0F3F6;">};</span></span></code></pre></div><p>上面代码中，等号左边对象的<code>foo</code>属性，对应一个子对象。该子对象的bar属性，解构时会报错。原因很简单，因为<code>foo</code>这时等于<code>undefined</code>，再取子属性就会报错，请看下面的代码。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> _tmp </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> {baz: </span><span style="color:#ADDCFF;">&#39;baz&#39;</span><span style="color:#F0F3F6;">};</span></span>
<span class="line"><span style="color:#F0F3F6;">_tmp.foo.bar </span><span style="color:#BDC4CC;">// 报错</span></span></code></pre></div><p>如果要将一个已经声明的变量用于解构赋值，必须非常小心。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">// 错误的写法</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> x;</span></span>
<span class="line"><span style="color:#F0F3F6;">{x} </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> {x: </span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">}; </span><span style="color:#BDC4CC;">// SyntaxError: syntax error</span></span></code></pre></div><p>上面代码的写法会报错，因为JavaScript引擎会将<code>{x}</code>理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免JavaScript将其解释为代码块，才能解决这个问题。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">// 正确的写法</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> x;</span></span>
<span class="line"><span style="color:#F0F3F6;">({x} </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> {x: </span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">});</span></span></code></pre></div><p>解构赋值允许等号左边的模式之中，不放置任何变量名。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">({} </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [</span><span style="color:#91CBFF;">true</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">false</span><span style="color:#F0F3F6;">]);</span></span>
<span class="line"><span style="color:#F0F3F6;">({} </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &#39;abc&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#F0F3F6;">({} </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> []);</span></span></code></pre></div><p>上面的表达式虽然毫无意义，但是语法是合法的，可以执行。<br> 对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> { log, sin, cos } </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> Math;</span></span></code></pre></div><p>上面代码将<code>Math</code>对象的对数、正弦、余弦三个方法，赋值到对应的变量上，使用起来就会方便很多。<br> 由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> arr </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [</span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">3</span><span style="color:#F0F3F6;">];</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> {</span><span style="color:#91CBFF;">0</span><span style="color:#F0F3F6;"> : first, [arr.</span><span style="color:#91CBFF;">length</span><span style="color:#FF9492;"> -</span><span style="color:#91CBFF;"> 1</span><span style="color:#F0F3F6;">] : last} </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> arr;</span></span>
<span class="line"><span style="color:#F0F3F6;">first </span><span style="color:#BDC4CC;">// 1</span></span>
<span class="line"><span style="color:#F0F3F6;">last </span><span style="color:#BDC4CC;">// 3</span></span></code></pre></div><p>上面代码对数组进行对象解构。数组<code>arr</code>的0键对应的值是1，<code>[arr.length - 1]</code>就是2键，对应的值是3。方括号这种写法，属于“属性名表达式”。</p><h2 id="字符串的解构赋值" tabindex="-1"><a class="header-anchor" href="#字符串的解构赋值"><span>字符串的解构赋值</span></a></h2><p>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#F0F3F6;"> [</span><span style="color:#91CBFF;">a</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">b</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">c</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">d</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">e</span><span style="color:#F0F3F6;">] </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &#39;hello&#39;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">a </span><span style="color:#BDC4CC;">// &quot;h&quot;</span></span>
<span class="line"><span style="color:#F0F3F6;">b </span><span style="color:#BDC4CC;">// &quot;e&quot;</span></span>
<span class="line"><span style="color:#F0F3F6;">c </span><span style="color:#BDC4CC;">// &quot;l&quot;</span></span>
<span class="line"><span style="color:#F0F3F6;">d </span><span style="color:#BDC4CC;">// &quot;l&quot;</span></span>
<span class="line"><span style="color:#F0F3F6;">e </span><span style="color:#BDC4CC;">// &quot;o&quot;</span></span></code></pre></div><p>类似数组的对象都有一个<code>length</code>属性，因此还可以对这个属性解构赋值。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> {</span><span style="color:#FFB757;">length</span><span style="color:#F0F3F6;"> : len} </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &#39;hello&#39;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">len </span><span style="color:#BDC4CC;">// 5</span></span></code></pre></div><h2 id="函数参数的解构赋值" tabindex="-1"><a class="header-anchor" href="#函数参数的解构赋值"><span>函数参数的解构赋值</span></a></h2><p>函数的参数也可以使用解构赋值。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">function</span><span style="color:#DBB7FF;"> add</span><span style="color:#F0F3F6;">([</span><span style="color:#FFB757;">x</span><span style="color:#F0F3F6;">, </span><span style="color:#FFB757;">y</span><span style="color:#F0F3F6;">]){</span></span>
<span class="line"><span style="color:#FF9492;">  return</span><span style="color:#F0F3F6;"> x </span><span style="color:#FF9492;">+</span><span style="color:#F0F3F6;"> y;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#DBB7FF;">add</span><span style="color:#F0F3F6;">([</span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">]); </span><span style="color:#BDC4CC;">// 3</span></span></code></pre></div><p>上面代码中，函数<code>add</code>的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量<code>x</code>和<code>y</code>。对于函数内部的代码来说，它们能感受到的参数就是<code>x</code>和<code>y</code>。<br> 下面是另一个例子。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[[</span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">], [</span><span style="color:#91CBFF;">3</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">4</span><span style="color:#F0F3F6;">]].</span><span style="color:#DBB7FF;">map</span><span style="color:#F0F3F6;">(([</span><span style="color:#FFB757;">a</span><span style="color:#F0F3F6;">, </span><span style="color:#FFB757;">b</span><span style="color:#F0F3F6;">]) </span><span style="color:#FF9492;">=&gt;</span><span style="color:#F0F3F6;"> a </span><span style="color:#FF9492;">+</span><span style="color:#F0F3F6;"> b); </span><span style="color:#BDC4CC;">// [ 3, 7 ]</span></span></code></pre></div><p>函数参数的解构也可以使用默认值。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">function</span><span style="color:#DBB7FF;"> move</span><span style="color:#F0F3F6;">({</span><span style="color:#FFB757;">x</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> 0</span><span style="color:#F0F3F6;">, </span><span style="color:#FFB757;">y</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> 0</span><span style="color:#F0F3F6;">} </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> {}) {</span></span>
<span class="line"><span style="color:#FF9492;">  return</span><span style="color:#F0F3F6;"> [x, y];</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#DBB7FF;">move</span><span style="color:#F0F3F6;">({x: </span><span style="color:#91CBFF;">3</span><span style="color:#F0F3F6;">, y: </span><span style="color:#91CBFF;">8</span><span style="color:#F0F3F6;">}); </span><span style="color:#BDC4CC;">// [3, 8]</span></span>
<span class="line"><span style="color:#DBB7FF;">move</span><span style="color:#F0F3F6;">({x: </span><span style="color:#91CBFF;">3</span><span style="color:#F0F3F6;">}); </span><span style="color:#BDC4CC;">// [3, 0]</span></span>
<span class="line"><span style="color:#DBB7FF;">move</span><span style="color:#F0F3F6;">({}); </span><span style="color:#BDC4CC;">// [0, 0]</span></span>
<span class="line"><span style="color:#DBB7FF;">move</span><span style="color:#F0F3F6;">(); </span><span style="color:#BDC4CC;">// [0, 0]</span></span></code></pre></div><p>上面代码中，函数<code>move</code>的参数是一个对象，通过对这个对象进行解构，得到变量<code>x</code>和<code>y</code>的值。如果解构失败，<code>x</code>和<code>y</code>等于默认值。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">function</span><span style="color:#DBB7FF;"> move</span><span style="color:#F0F3F6;">({</span><span style="color:#FFB757;">x</span><span style="color:#F0F3F6;">, </span><span style="color:#FFB757;">y</span><span style="color:#F0F3F6;">} </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> { x: </span><span style="color:#91CBFF;">0</span><span style="color:#F0F3F6;">, y: </span><span style="color:#91CBFF;">0</span><span style="color:#F0F3F6;"> }) {</span></span>
<span class="line"><span style="color:#FF9492;">  return</span><span style="color:#F0F3F6;"> [x, y];</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#DBB7FF;">move</span><span style="color:#F0F3F6;">({x: </span><span style="color:#91CBFF;">3</span><span style="color:#F0F3F6;">, y: </span><span style="color:#91CBFF;">8</span><span style="color:#F0F3F6;">}); </span><span style="color:#BDC4CC;">// [3, 8]</span></span>
<span class="line"><span style="color:#DBB7FF;">move</span><span style="color:#F0F3F6;">({x: </span><span style="color:#91CBFF;">3</span><span style="color:#F0F3F6;">}); </span><span style="color:#BDC4CC;">// [3, undefined]</span></span>
<span class="line"><span style="color:#DBB7FF;">move</span><span style="color:#F0F3F6;">({}); </span><span style="color:#BDC4CC;">// [undefined, undefined]</span></span>
<span class="line"><span style="color:#DBB7FF;">move</span><span style="color:#F0F3F6;">(); </span><span style="color:#BDC4CC;">// [0, 0]</span></span></code></pre></div><p>上面代码是为函数<code>move</code>的参数指定默认值，而不是为变量<code>x</code>和<code>y</code>指定默认值，所以会得到与前一种写法不同的结果。<br><code>undefined</code>就会触发函数参数的默认值。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[</span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">,</span><span style="color:#91CBFF;">undefined</span><span style="color:#F0F3F6;">,</span><span style="color:#91CBFF;">3</span><span style="color:#F0F3F6;">].</span><span style="color:#DBB7FF;">map</span><span style="color:#F0F3F6;">((</span><span style="color:#FFB757;">x</span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;">&#39;yes&#39;</span><span style="color:#F0F3F6;">)</span><span style="color:#FF9492;">=&gt;</span><span style="color:#F0F3F6;">x); </span><span style="color:#BDC4CC;">// [1,&#39;yes&#39;,3 ]</span></span></code></pre></div><h2 id="圆括号问题" tabindex="-1"><a class="header-anchor" href="#圆括号问题"><span>圆括号问题</span></a></h2><p>解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。<br> 由此带来的问题是，如果模式中出现圆括号怎么处理。ES6的规则是，只要有可能导致解构的歧义，就不得使用圆括号。<br> 但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号。</p><h3 id="不能使用圆括号的情况" tabindex="-1"><a class="header-anchor" href="#不能使用圆括号的情况"><span>不能使用圆括号的情况</span></a></h3><p>以下三种解构赋值不得使用圆括号。</p><h4 id="_1-变量声明语句" tabindex="-1"><a class="header-anchor" href="#_1-变量声明语句"><span>1.变量声明语句</span></a></h4><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">// 全部报错</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> [(a)] </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [</span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">];</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> {</span><span style="color:#FFB757;">x</span><span style="color:#F0F3F6;">: (c)} </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> {};</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> ({</span><span style="color:#FFB757;">x</span><span style="color:#F0F3F6;">: c}) </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> {};</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> {(</span><span style="color:#FFB757;">x</span><span style="color:#F0F3F6;">: c)} </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> {};</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> {(x): c} </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> {};</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> { </span><span style="color:#FFB757;">o</span><span style="color:#F0F3F6;">: ({ </span><span style="color:#FFB757;">p</span><span style="color:#F0F3F6;">: p }) } </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> { o: { p: </span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;"> } };</span></span></code></pre></div><p>上面6个语句都会报错，因为它们都是变量声明语句，模式不能使用圆括号。</p><h4 id="_2-函数参数" tabindex="-1"><a class="header-anchor" href="#_2-函数参数"><span>2.函数参数</span></a></h4><p>函数参数也属于变量声明，因此不能带有圆括号。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">// 报错</span></span>
<span class="line"><span style="color:#FF9492;">function</span><span style="color:#DBB7FF;"> f</span><span style="color:#F0F3F6;">([(</span><span style="color:#FFB757;">z</span><span style="color:#F0F3F6;">)]) { </span><span style="color:#FF9492;">return</span><span style="color:#F0F3F6;"> z; }</span></span>
<span class="line"><span style="color:#BDC4CC;">// 报错</span></span>
<span class="line"><span style="color:#FF9492;">function</span><span style="color:#DBB7FF;"> f</span><span style="color:#F0F3F6;">([</span><span style="color:#FFB757;">z</span><span style="color:#F0F3F6;">,(</span><span style="color:#FFB757;">x</span><span style="color:#F0F3F6;">)]) { </span><span style="color:#FF9492;">return</span><span style="color:#F0F3F6;"> x; }</span></span></code></pre></div><h4 id="_3-赋值语句的模式" tabindex="-1"><a class="header-anchor" href="#_3-赋值语句的模式"><span>3.赋值语句的模式</span></a></h4><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">// 全部报错</span></span>
<span class="line"><span style="color:#F0F3F6;">({ p: a }) </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> { p: </span><span style="color:#91CBFF;">42</span><span style="color:#F0F3F6;"> };</span></span>
<span class="line"><span style="color:#F0F3F6;">([a]) </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [</span><span style="color:#91CBFF;">5</span><span style="color:#F0F3F6;">];</span></span></code></pre></div><p>上面代码将整个模式放在圆括号之中，导致报错。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">// 报错</span></span>
<span class="line"><span style="color:#F0F3F6;">[({ p: a }), { x: c }] </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [{}, {}];</span></span></code></pre></div><p>上面代码将一部分模式放在圆括号之中，导致报错。</p><h3 id="可以使用圆括号的情况" tabindex="-1"><a class="header-anchor" href="#可以使用圆括号的情况"><span>可以使用圆括号的情况</span></a></h3><p>可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[(b)] </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [</span><span style="color:#91CBFF;">3</span><span style="color:#F0F3F6;">]; </span><span style="color:#BDC4CC;">// 正确</span></span>
<span class="line"><span style="color:#F0F3F6;">({ p: (d) } </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> {}); </span><span style="color:#BDC4CC;">// 正确</span></span>
<span class="line"><span style="color:#F0F3F6;">[(parseInt.prop)] </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [</span><span style="color:#91CBFF;">3</span><span style="color:#F0F3F6;">]; </span><span style="color:#BDC4CC;">// 正确</span></span></code></pre></div><p>上面三行语句都可以正确执行，因为首先它们都是赋值语句，而不是声明语句；其次它们的圆括号都不属于模式的一部分。第一行语句中，模式是取数组的第一个成员，跟圆括号无关；第二行语句中，模式是<code>p</code>，而不是<code>d</code>；第三行语句与第一行语句的性质一致。</p><h2 id="用途" tabindex="-1"><a class="header-anchor" href="#用途"><span>用途</span></a></h2><p>变量的解构赋值用途很多。</p><h3 id="_1-交换变量的值" tabindex="-1"><a class="header-anchor" href="#_1-交换变量的值"><span>1.交换变量的值</span></a></h3><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>let x = 1;</span></span>
<span class="line"><span>let y = 2;</span></span>
<span class="line"><span>[x, y] = [y, x];</span></span></code></pre></div><h3 id="_2-从函数返回多个值" tabindex="-1"><a class="header-anchor" href="#_2-从函数返回多个值"><span>2.从函数返回多个值</span></a></h3><p>函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">// 返回一个数组</span></span>
<span class="line"><span style="color:#FF9492;">function</span><span style="color:#DBB7FF;"> example</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#FF9492;">  return</span><span style="color:#F0F3F6;"> [</span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">3</span><span style="color:#F0F3F6;">];</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> [a, b, c] </span><span style="color:#FF9492;">=</span><span style="color:#DBB7FF;"> example</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#BDC4CC;">// 返回一个对象</span></span>
<span class="line"><span style="color:#FF9492;">function</span><span style="color:#DBB7FF;"> example</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#FF9492;">  return</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">    foo: </span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#F0F3F6;">    bar: </span><span style="color:#91CBFF;">2</span></span>
<span class="line"><span style="color:#F0F3F6;">  };</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> { foo, bar } </span><span style="color:#FF9492;">=</span><span style="color:#DBB7FF;"> example</span><span style="color:#F0F3F6;">();</span></span></code></pre></div><h3 id="_3-函数参数的定义" tabindex="-1"><a class="header-anchor" href="#_3-函数参数的定义"><span>3.函数参数的定义</span></a></h3><p>解构赋值可以方便地将一组参数与变量名对应起来。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">// 参数是一组有次序的值</span></span>
<span class="line"><span style="color:#FF9492;">function</span><span style="color:#DBB7FF;"> f</span><span style="color:#F0F3F6;">([</span><span style="color:#FFB757;">x</span><span style="color:#F0F3F6;">, </span><span style="color:#FFB757;">y</span><span style="color:#F0F3F6;">, </span><span style="color:#FFB757;">z</span><span style="color:#F0F3F6;">]) { </span><span style="color:#FF9492;">...</span><span style="color:#F0F3F6;"> }</span></span>
<span class="line"><span style="color:#DBB7FF;">f</span><span style="color:#F0F3F6;">([</span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">3</span><span style="color:#F0F3F6;">]);</span></span>
<span class="line"><span style="color:#BDC4CC;">// 参数是一组无次序的值</span></span>
<span class="line"><span style="color:#FF9492;">function</span><span style="color:#DBB7FF;"> f</span><span style="color:#F0F3F6;">({</span><span style="color:#FFB757;">x</span><span style="color:#F0F3F6;">, </span><span style="color:#FFB757;">y</span><span style="color:#F0F3F6;">, </span><span style="color:#FFB757;">z</span><span style="color:#F0F3F6;">}) { </span><span style="color:#FF9492;">...</span><span style="color:#F0F3F6;"> }</span></span>
<span class="line"><span style="color:#DBB7FF;">f</span><span style="color:#F0F3F6;">({z: </span><span style="color:#91CBFF;">3</span><span style="color:#F0F3F6;">, y: </span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">, x: </span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">});</span></span></code></pre></div><h3 id="_4-提取json数据" tabindex="-1"><a class="header-anchor" href="#_4-提取json数据"><span>4.提取JSON数据</span></a></h3><p>解构赋值对提取JSON对象中的数据，尤其有用。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> jsonData </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">  id: </span><span style="color:#91CBFF;">42</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#F0F3F6;">  status: </span><span style="color:#ADDCFF;">&quot;OK&quot;</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#F0F3F6;">  data: [</span><span style="color:#91CBFF;">867</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">5309</span><span style="color:#F0F3F6;">]</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> { id, status, </span><span style="color:#FFB757;">data</span><span style="color:#F0F3F6;">: number } </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> jsonData;</span></span>
<span class="line"><span style="color:#F0F3F6;">console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(id,status,number); </span><span style="color:#BDC4CC;">// 42, &quot;OK&quot;,[867,5309]</span></span></code></pre></div><h3 id="_5-函数参数的默认值" tabindex="-1"><a class="header-anchor" href="#_5-函数参数的默认值"><span>5.函数参数的默认值</span></a></h3><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">jQuery.</span><span style="color:#DBB7FF;">ajax</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> function</span><span style="color:#F0F3F6;"> (</span><span style="color:#FFB757;">url</span><span style="color:#F0F3F6;">, {</span></span>
<span class="line"><span style="color:#FFB757;">  async</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> true</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#FFB757;">  beforeSend</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> function</span><span style="color:#F0F3F6;"> () {},</span></span>
<span class="line"><span style="color:#FFB757;">  cache</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> true</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#FFB757;">  complete</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> function</span><span style="color:#F0F3F6;"> () {},</span></span>
<span class="line"><span style="color:#FFB757;">  crossDomain</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> false</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#FFB757;">  global</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> true</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#BDC4CC;">  // ... more config</span></span>
<span class="line"><span style="color:#F0F3F6;">} </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> {}) {</span></span>
<span class="line"><span style="color:#BDC4CC;">  // ... do stuff</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span></code></pre></div><p>指定参数的默认值，就避免了在函数体内部再写<code>var foo = config.foo||&#39;default foo&#39;;</code>这样的语句。</p><h3 id="_6-遍历map结构" tabindex="-1"><a class="header-anchor" href="#_6-遍历map结构"><span>6.遍历Map结构</span></a></h3><p>任何部署了<code>Iterator</code>接口的对象，都可以用<code>for...of</code>循环遍历。<code>Map</code>结构原生支持<code>Iterator</code>接口，配合变量的解构赋值，获取键名和键值就非常方便。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> map</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> Map</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#F0F3F6;">map.</span><span style="color:#DBB7FF;">set</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;first&#39;</span><span style="color:#F0F3F6;">, </span><span style="color:#ADDCFF;">&#39;hello&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#F0F3F6;">map.</span><span style="color:#DBB7FF;">set</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;second&#39;</span><span style="color:#F0F3F6;">, </span><span style="color:#ADDCFF;">&#39;world&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#FF9492;">for</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> [key, value] </span><span style="color:#FF9492;">of</span><span style="color:#F0F3F6;"> map) {</span></span>
<span class="line"><span style="color:#F0F3F6;">  console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(key </span><span style="color:#FF9492;">+</span><span style="color:#ADDCFF;"> &quot; is &quot;</span><span style="color:#FF9492;"> +</span><span style="color:#F0F3F6;"> value);</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#BDC4CC;">// first is hello</span></span>
<span class="line"><span style="color:#BDC4CC;">// second is world</span></span></code></pre></div><p>如果只想获取键名，或者只想获取键值，可以写成下面这样。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">// 获取键名</span></span>
<span class="line"><span style="color:#FF9492;">for</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> [key] </span><span style="color:#FF9492;">of</span><span style="color:#F0F3F6;"> map) {</span></span>
<span class="line"><span style="color:#BDC4CC;">  // ...</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#BDC4CC;">// 获取键值</span></span>
<span class="line"><span style="color:#FF9492;">for</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> [,value] </span><span style="color:#FF9492;">of</span><span style="color:#F0F3F6;"> map) {</span></span>
<span class="line"><span style="color:#BDC4CC;">  // ...</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><h3 id="_7-输入模块的指定方法" tabindex="-1"><a class="header-anchor" href="#_7-输入模块的指定方法"><span>7.输入模块的指定方法</span></a></h3><p>加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#F0F3F6;"> {</span><span style="color:#91CBFF;">SourceMapConsumer</span><span style="color:#F0F3F6;">,</span><span style="color:#91CBFF;">SourceNode</span><span style="color:#F0F3F6;">}</span><span style="color:#FF9492;">=</span><span style="color:#DBB7FF;">require</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;source-map&quot;</span><span style="color:#F0F3F6;">);</span></span></code></pre></div>`,132)]))}const r=a(p,[["render",F],["__file","ES6结构赋值.html.vue"]]),y=JSON.parse('{"path":"/js/es6/ES6%E7%BB%93%E6%9E%84%E8%B5%8B%E5%80%BC.html","title":"ES6解构赋值","lang":"zh-CN","frontmatter":{"title":"ES6解构赋值","date":"2023-01-10T00:00:00.000Z","tags":"es6","categories":"前端","order":2,"description":"数组的解构赋值 基本用法 ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构。 以前，为变量赋值，只能直接指定值。 ES6允许写成下面这样。 本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。 如果解构不成功，变量的值就等于undefined。 另一种情况是不完全解构，即等号左边的模式，只匹...","head":[["meta",{"property":"og:url","content":"https://0oWSQo0.github.io/wsq-blog/js/es6/ES6%E7%BB%93%E6%9E%84%E8%B5%8B%E5%80%BC.html"}],["meta",{"property":"og:title","content":"ES6解构赋值"}],["meta",{"property":"og:description","content":"数组的解构赋值 基本用法 ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构。 以前，为变量赋值，只能直接指定值。 ES6允许写成下面这样。 本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。 如果解构不成功，变量的值就等于undefined。 另一种情况是不完全解构，即等号左边的模式，只匹..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-09-11T05:57:00.000Z"}],["meta",{"property":"article:published_time","content":"2023-01-10T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-09-11T05:57:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"ES6解构赋值\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-01-10T00:00:00.000Z\\",\\"dateModified\\":\\"2024-09-11T05:57:00.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"WSQ\\",\\"url\\":\\"https://0oWSQo0.github.com\\"}]}"]]},"headers":[{"level":2,"title":"数组的解构赋值","slug":"数组的解构赋值","link":"#数组的解构赋值","children":[{"level":3,"title":"基本用法","slug":"基本用法","link":"#基本用法","children":[]},{"level":3,"title":"默认值","slug":"默认值","link":"#默认值","children":[]}]},{"level":2,"title":"对象的解构赋值","slug":"对象的解构赋值","link":"#对象的解构赋值","children":[]},{"level":2,"title":"字符串的解构赋值","slug":"字符串的解构赋值","link":"#字符串的解构赋值","children":[]},{"level":2,"title":"函数参数的解构赋值","slug":"函数参数的解构赋值","link":"#函数参数的解构赋值","children":[]},{"level":2,"title":"圆括号问题","slug":"圆括号问题","link":"#圆括号问题","children":[{"level":3,"title":"不能使用圆括号的情况","slug":"不能使用圆括号的情况","link":"#不能使用圆括号的情况","children":[]},{"level":3,"title":"可以使用圆括号的情况","slug":"可以使用圆括号的情况","link":"#可以使用圆括号的情况","children":[]}]},{"level":2,"title":"用途","slug":"用途","link":"#用途","children":[{"level":3,"title":"1.交换变量的值","slug":"_1-交换变量的值","link":"#_1-交换变量的值","children":[]},{"level":3,"title":"2.从函数返回多个值","slug":"_2-从函数返回多个值","link":"#_2-从函数返回多个值","children":[]},{"level":3,"title":"3.函数参数的定义","slug":"_3-函数参数的定义","link":"#_3-函数参数的定义","children":[]},{"level":3,"title":"4.提取JSON数据","slug":"_4-提取json数据","link":"#_4-提取json数据","children":[]},{"level":3,"title":"5.函数参数的默认值","slug":"_5-函数参数的默认值","link":"#_5-函数参数的默认值","children":[]},{"level":3,"title":"6.遍历Map结构","slug":"_6-遍历map结构","link":"#_6-遍历map结构","children":[]},{"level":3,"title":"7.输入模块的指定方法","slug":"_7-输入模块的指定方法","link":"#_7-输入模块的指定方法","children":[]}]}],"git":{"createdTime":1726034220000,"updatedTime":1726034220000,"contributors":[{"name":"WSQ","email":"592786982@qq.com","commits":1}]},"readingTime":{"minutes":11.45,"words":3436},"filePathRelative":"js/es6/ES6结构赋值.md","localizedDate":"2023年1月10日","autoDesc":true}');export{r as comp,y as data};
