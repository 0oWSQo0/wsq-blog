import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,d as l,o}from"./app-ByvFWdWZ.js";const p={};function e(F,s){return o(),n("div",null,s[0]||(s[0]=[l(`<h2 id="iterator-遍历器-的概念" tabindex="-1"><a class="header-anchor" href="#iterator-遍历器-的概念"><span>Iterator（遍历器）的概念</span></a></h2><p>JavaScript 原有的表示“集合”的数据结构，主要是数组和对象，ES6 又添加了<code>Map</code>和<code>Set</code>。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是<code>Map</code>，<code>Map</code>的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。</p><p>遍历器（<code>Iterator</code>）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署<code>Iterator</code>接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。</p><p><code>Iterator</code>的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是 ES6 创造了一种新的遍历命令<code>for...of</code>循环，<code>Iterator</code>接口主要供<code>for...of</code>消费。</p><p><code>Iterator</code>的遍历过程是这样的。</p><ul><li>创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</li><li>第一次调用指针对象的<code>next</code>方法，可以将指针指向数据结构的第一个成员。</li><li>第二次调用指针对象的<code>next</code>方法，指针就指向数据结构的第二个成员。</li><li>不断调用指针对象的<code>next</code>方法，直到它指向数据结构的结束位置。</li></ul><p>每一次调用<code>next</code>方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含<code>value</code>和<code>done</code>两个属性的对象。其中，<code>value</code>属性是当前成员的值，<code>done</code>属性是一个布尔值，表示遍历是否结束。</p><p>下面是一个模拟<code>next</code>方法返回值的例子。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> it </span><span style="color:#FF9492;">=</span><span style="color:#DBB7FF;"> makeIterator</span><span style="color:#F0F3F6;">([</span><span style="color:#ADDCFF;">&#39;a&#39;</span><span style="color:#F0F3F6;">, </span><span style="color:#ADDCFF;">&#39;b&#39;</span><span style="color:#F0F3F6;">]);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">it.</span><span style="color:#DBB7FF;">next</span><span style="color:#F0F3F6;">() </span><span style="color:#BDC4CC;">// { value: &quot;a&quot;, done: false }</span></span>
<span class="line"><span style="color:#F0F3F6;">it.</span><span style="color:#DBB7FF;">next</span><span style="color:#F0F3F6;">() </span><span style="color:#BDC4CC;">// { value: &quot;b&quot;, done: false }</span></span>
<span class="line"><span style="color:#F0F3F6;">it.</span><span style="color:#DBB7FF;">next</span><span style="color:#F0F3F6;">() </span><span style="color:#BDC4CC;">// { value: undefined, done: true }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">function</span><span style="color:#DBB7FF;"> makeIterator</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">array</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#FF9492;">  var</span><span style="color:#F0F3F6;"> nextIndex </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 0</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">  return</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#DBB7FF;">    next</span><span style="color:#F0F3F6;">: </span><span style="color:#FF9492;">function</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#FF9492;">      return</span><span style="color:#F0F3F6;"> nextIndex </span><span style="color:#FF9492;">&lt;</span><span style="color:#F0F3F6;"> array.</span><span style="color:#91CBFF;">length</span><span style="color:#FF9492;"> ?</span></span>
<span class="line"><span style="color:#F0F3F6;">        {value: array[nextIndex</span><span style="color:#FF9492;">++</span><span style="color:#F0F3F6;">], done: </span><span style="color:#91CBFF;">false</span><span style="color:#F0F3F6;">} </span><span style="color:#FF9492;">:</span></span>
<span class="line"><span style="color:#F0F3F6;">        {</span><span style="color:#FFB757;">value</span><span style="color:#F0F3F6;">: </span><span style="color:#91CBFF;">undefined</span><span style="color:#F0F3F6;">, </span><span style="color:#FFB757;">done</span><span style="color:#F0F3F6;">: </span><span style="color:#91CBFF;">true</span><span style="color:#F0F3F6;">};</span></span>
<span class="line"><span style="color:#F0F3F6;">    }</span></span>
<span class="line"><span style="color:#F0F3F6;">  };</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面代码定义了一个<code>makeIterator</code>函数，它是一个遍历器生成函数，作用就是返回一个遍历器对象。对数组<code>[&#39;a&#39;, &#39;b&#39;]</code>执行这个函数，就会返回该数组的遍历器对象（即指针对象）<code>it</code>。</p><p>指针对象的<code>next</code>方法，用来移动指针。开始时，指针指向数组的开始位置。然后，每次调用<code>next</code>方法，指针就会指向数组的下一个成员。第一次调用，指向<code>a</code>；第二次调用，指向<code>b</code>。</p><p><code>next</code>方法返回一个对象，表示当前数据成员的信息。这个对象具有<code>value</code>和<code>done</code>两个属性，<code>value</code>属性返回当前位置的成员，<code>done</code>属性是一个布尔值，表示遍历是否结束，即是否还有必要再一次调用<code>next</code>方法。</p><p>总之，调用指针对象的<code>next</code>方法，就可以遍历事先给定的数据结构。</p><p>对于遍历器对象来说，<code>done: false</code>和<code>value: undefined</code>属性都是可以省略的，因此上面的<code>makeIterator</code>函数可以简写成下面的形式。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">function</span><span style="color:#DBB7FF;"> makeIterator</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">array</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#FF9492;">  var</span><span style="color:#F0F3F6;"> nextIndex </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 0</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">  return</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#DBB7FF;">    next</span><span style="color:#F0F3F6;">: </span><span style="color:#FF9492;">function</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#FF9492;">      return</span><span style="color:#F0F3F6;"> nextIndex </span><span style="color:#FF9492;">&lt;</span><span style="color:#F0F3F6;"> array.</span><span style="color:#91CBFF;">length</span><span style="color:#FF9492;"> ?</span></span>
<span class="line"><span style="color:#F0F3F6;">        {value: array[nextIndex</span><span style="color:#FF9492;">++</span><span style="color:#F0F3F6;">]} </span><span style="color:#FF9492;">:</span></span>
<span class="line"><span style="color:#F0F3F6;">        {</span><span style="color:#FFB757;">done</span><span style="color:#F0F3F6;">: </span><span style="color:#91CBFF;">true</span><span style="color:#F0F3F6;">};</span></span>
<span class="line"><span style="color:#F0F3F6;">    }</span></span>
<span class="line"><span style="color:#F0F3F6;">  };</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>由于<code>Iterator</code>只是把接口规格加到数据结构之上，所以，遍历器与它所遍历的那个数据结构，实际上是分开的，完全可以写出没有对应数据结构的遍历器对象，或者说用遍历器对象模拟出数据结构。下面是一个无限运行的遍历器对象的例子。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> it </span><span style="color:#FF9492;">=</span><span style="color:#DBB7FF;"> idMaker</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">it.</span><span style="color:#DBB7FF;">next</span><span style="color:#F0F3F6;">().value </span><span style="color:#BDC4CC;">// 0</span></span>
<span class="line"><span style="color:#F0F3F6;">it.</span><span style="color:#DBB7FF;">next</span><span style="color:#F0F3F6;">().value </span><span style="color:#BDC4CC;">// 1</span></span>
<span class="line"><span style="color:#F0F3F6;">it.</span><span style="color:#DBB7FF;">next</span><span style="color:#F0F3F6;">().value </span><span style="color:#BDC4CC;">// 2</span></span>
<span class="line"><span style="color:#BDC4CC;">// ...</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">function</span><span style="color:#DBB7FF;"> idMaker</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#FF9492;">  var</span><span style="color:#F0F3F6;"> index </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 0</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">  return</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#DBB7FF;">    next</span><span style="color:#F0F3F6;">: </span><span style="color:#FF9492;">function</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#FF9492;">      return</span><span style="color:#F0F3F6;"> {value: index</span><span style="color:#FF9492;">++</span><span style="color:#F0F3F6;">, done: </span><span style="color:#91CBFF;">false</span><span style="color:#F0F3F6;">};</span></span>
<span class="line"><span style="color:#F0F3F6;">    }</span></span>
<span class="line"><span style="color:#F0F3F6;">  };</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面的例子中，遍历器生成函数<code>idMaker</code>，返回一个遍历器对象（即指针对象）。但是并没有对应的数据结构，或者说，遍历器对象自己描述了一个数据结构出来。</p><p>如果使用 TypeScript 的写法，遍历器接口（<code>Iterable</code>）、指针对象（<code>Iterator</code>）和<code>next</code>方法返回值的规格可以描述如下。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">interface</span><span style="color:#FFB757;"> Iterable</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">  [Symbol.iterator]() </span><span style="color:#FF9492;">:</span><span style="color:#FFB757;"> Iterator</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">interface</span><span style="color:#FFB757;"> Iterator</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#DBB7FF;">  next</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">value</span><span style="color:#FF9492;">?:</span><span style="color:#91CBFF;"> any</span><span style="color:#F0F3F6;">) </span><span style="color:#FF9492;">:</span><span style="color:#FFB757;"> IterationResult</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">interface</span><span style="color:#FFB757;"> IterationResult</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FFB757;">  value</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> any</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#FFB757;">  done</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> boolean</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><h2 id="默认-iterator-接口" tabindex="-1"><a class="header-anchor" href="#默认-iterator-接口"><span>默认 Iterator 接口</span></a></h2><p><code>Iterator</code>接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即<code>for...of</code>循环。当使用<code>for...of</code>循环遍历某种数据结构时，该循环会自动去寻找<code>Iterator</code>接口。</p><p>一种数据结构只要部署了<code>Iterator</code>接口，我们就称这种数据结构是“可遍历的”（<code>iterable</code>）。</p><p>ES6 规定，默认的<code>Iterator</code>接口部署在数据结构的<code>Symbol.iterator</code>属性，或者说，一个数据结构只要具有<code>Symbol.iterator</code>属性，就可以认为是“可遍历的”（<code>iterable</code>）。<code>Symbol.iterator</code>属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。至于属性名<code>Symbol.iterator</code>，它是一个表达式，返回<code>Symbol</code>对象的<code>iterator</code>属性，这是一个预定义好的、类型为<code>Symbol</code>的特殊值，所以要放在方括号内。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> obj</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">  [Symbol.iterator] : </span><span style="color:#FF9492;">function</span><span style="color:#F0F3F6;"> () {</span></span>
<span class="line"><span style="color:#FF9492;">    return</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#DBB7FF;">      next</span><span style="color:#F0F3F6;">: </span><span style="color:#FF9492;">function</span><span style="color:#F0F3F6;"> () {</span></span>
<span class="line"><span style="color:#FF9492;">        return</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">          value: </span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#F0F3F6;">          done: </span><span style="color:#91CBFF;">true</span></span>
<span class="line"><span style="color:#F0F3F6;">        };</span></span>
<span class="line"><span style="color:#F0F3F6;">      }</span></span>
<span class="line"><span style="color:#F0F3F6;">    };</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span></code></pre></div><p>上面代码中，对象<code>obj</code>是可遍历的（<code>iterable</code>），因为具有<code>Symbol.iterator</code>属性。执行这个属性，会返回一个遍历器对象。该对象的根本特征就是具有<code>next</code>方法。每次调用<code>next</code>方法，都会返回一个代表当前成员的信息对象，具有<code>value</code>和<code>done</code>两个属性。</p><p>ES6 的有些数据结构原生具备<code>Iterator</code>接口（比如数组），即不用任何处理，就可以被<code>for...of</code>循环遍历。原因在于，这些数据结构原生部署了<code>Symbol.iterator</code>属性，另外一些数据结构没有（比如对象）。凡是部署了<code>Symbol.iterator</code>属性的数据结构，就称为部署了遍历器接口。调用这个接口，就会返回一个遍历器对象。</p><p>原生具备<code>Iterator</code>接口的数据结构如下。</p><ul><li><code>Array</code></li><li><code>Map</code></li><li><code>Set</code></li><li><code>String</code></li><li><code>TypedArray</code></li><li>函数的<code>arguments</code>对象</li><li><code>NodeList</code>对象</li></ul><p>下面的例子是数组的<code>Symbol.iterator</code>属性。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> arr </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [</span><span style="color:#ADDCFF;">&#39;a&#39;</span><span style="color:#F0F3F6;">, </span><span style="color:#ADDCFF;">&#39;b&#39;</span><span style="color:#F0F3F6;">, </span><span style="color:#ADDCFF;">&#39;c&#39;</span><span style="color:#F0F3F6;">];</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> iter </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> arr[Symbol.iterator]();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">iter.</span><span style="color:#DBB7FF;">next</span><span style="color:#F0F3F6;">() </span><span style="color:#BDC4CC;">// { value: &#39;a&#39;, done: false }</span></span>
<span class="line"><span style="color:#F0F3F6;">iter.</span><span style="color:#DBB7FF;">next</span><span style="color:#F0F3F6;">() </span><span style="color:#BDC4CC;">// { value: &#39;b&#39;, done: false }</span></span>
<span class="line"><span style="color:#F0F3F6;">iter.</span><span style="color:#DBB7FF;">next</span><span style="color:#F0F3F6;">() </span><span style="color:#BDC4CC;">// { value: &#39;c&#39;, done: false }</span></span>
<span class="line"><span style="color:#F0F3F6;">iter.</span><span style="color:#DBB7FF;">next</span><span style="color:#F0F3F6;">() </span><span style="color:#BDC4CC;">// { value: undefined, done: true }</span></span></code></pre></div><p>上面代码中，变量<code>arr</code>是一个数组，原生就具有遍历器接口，部署在<code>arr</code>的<code>Symbol.iterator</code>属性上面。所以，调用这个属性，就得到遍历器对象。</p><p>对于原生部署<code>Iterator</code>接口的数据结构，不用自己写遍历器生成函数，<code>for...of</code>循环会自动遍历它们。除此之外，其他数据结构（主要是对象）的<code>Iterator</code>接口，都需要自己在<code>Symbol.iterator</code>属性上面部署，这样才会被<code>for...of</code>循环遍历。</p><p>对象（<code>Object</code>）之所以没有默认部署<code>Iterator</code>接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定。本质上，遍历器是一种线性处理，对于任何非线性的数据结构，部署遍历器接口，就等于部署一种线性转换。不过，严格地说，对象部署遍历器接口并不是很必要，因为这时对象实际上被当作<code>Map</code>结构使用，ES5 没有<code>Map</code>结构，而 ES6 原生提供了。</p><p>一个对象如果要具备可被<code>for...of</code>循环调用的<code>Iterator</code>接口，就必须在<code>Symbol.iterator</code>的属性上部署遍历器生成方法（原型链上的对象具有该方法也可）。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> RangeIterator</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  constructor</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">start</span><span style="color:#F0F3F6;">, </span><span style="color:#FFB757;">stop</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#91CBFF;">    this</span><span style="color:#F0F3F6;">.value </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> start;</span></span>
<span class="line"><span style="color:#91CBFF;">    this</span><span style="color:#F0F3F6;">.stop </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> stop;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">  [Symbol.iterator]() { </span><span style="color:#FF9492;">return</span><span style="color:#91CBFF;"> this</span><span style="color:#F0F3F6;">; }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#DBB7FF;">  next</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#FF9492;">    var</span><span style="color:#F0F3F6;"> value </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> this</span><span style="color:#F0F3F6;">.value;</span></span>
<span class="line"><span style="color:#FF9492;">    if</span><span style="color:#F0F3F6;"> (value </span><span style="color:#FF9492;">&lt;</span><span style="color:#91CBFF;"> this</span><span style="color:#F0F3F6;">.stop) {</span></span>
<span class="line"><span style="color:#91CBFF;">      this</span><span style="color:#F0F3F6;">.value</span><span style="color:#FF9492;">++</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">      return</span><span style="color:#F0F3F6;"> {done: </span><span style="color:#91CBFF;">false</span><span style="color:#F0F3F6;">, value: value};</span></span>
<span class="line"><span style="color:#F0F3F6;">    }</span></span>
<span class="line"><span style="color:#FF9492;">    return</span><span style="color:#F0F3F6;"> {done: </span><span style="color:#91CBFF;">true</span><span style="color:#F0F3F6;">, value: </span><span style="color:#91CBFF;">undefined</span><span style="color:#F0F3F6;">};</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">function</span><span style="color:#DBB7FF;"> range</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">start</span><span style="color:#F0F3F6;">, </span><span style="color:#FFB757;">stop</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#FF9492;">  return</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> RangeIterator</span><span style="color:#F0F3F6;">(start, stop);</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">for</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> value </span><span style="color:#FF9492;">of</span><span style="color:#DBB7FF;"> range</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">0</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">3</span><span style="color:#F0F3F6;">)) {</span></span>
<span class="line"><span style="color:#F0F3F6;">  console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(value); </span><span style="color:#BDC4CC;">// 0, 1, 2</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面代码是一个类部署<code>Iterator</code>接口的写法。<code>Symbol.iterator</code>属性对应一个函数，执行后返回当前对象的遍历器对象。</p><p>下面是通过遍历器实现“链表”结构的例子。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">function</span><span style="color:#DBB7FF;"> Obj</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">value</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#91CBFF;">  this</span><span style="color:#F0F3F6;">.value </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> value;</span></span>
<span class="line"><span style="color:#91CBFF;">  this</span><span style="color:#F0F3F6;">.next </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> null</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#91CBFF;">Obj</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">prototype</span><span style="color:#F0F3F6;">[Symbol.iterator] </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> function</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#FF9492;">  var</span><span style="color:#F0F3F6;"> iterator </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> { next: next };</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">  var</span><span style="color:#F0F3F6;"> current </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> this</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">  function</span><span style="color:#DBB7FF;"> next</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#FF9492;">    if</span><span style="color:#F0F3F6;"> (current) {</span></span>
<span class="line"><span style="color:#FF9492;">      var</span><span style="color:#F0F3F6;"> value </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> current.value;</span></span>
<span class="line"><span style="color:#F0F3F6;">      current </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> current.next;</span></span>
<span class="line"><span style="color:#FF9492;">      return</span><span style="color:#F0F3F6;"> { done: </span><span style="color:#91CBFF;">false</span><span style="color:#F0F3F6;">, value: value };</span></span>
<span class="line"><span style="color:#F0F3F6;">    }</span></span>
<span class="line"><span style="color:#FF9492;">    return</span><span style="color:#F0F3F6;"> { done: </span><span style="color:#91CBFF;">true</span><span style="color:#F0F3F6;"> };</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#FF9492;">  return</span><span style="color:#F0F3F6;"> iterator;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> one </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> Obj</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> two </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> Obj</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> three </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> Obj</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">3</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">one.next </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> two;</span></span>
<span class="line"><span style="color:#F0F3F6;">two.next </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> three;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">for</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> i </span><span style="color:#FF9492;">of</span><span style="color:#F0F3F6;"> one){</span></span>
<span class="line"><span style="color:#F0F3F6;">  console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(i); </span><span style="color:#BDC4CC;">// 1, 2, 3</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面代码首先在构造函数的原型链上部署<code>Symbol.iterator</code>方法，调用该方法会返回遍历器对象<code>iterator</code>，调用该对象的<code>next</code>方法，在返回一个值的同时，自动将内部指针移到下一个实例。</p><p>下面是另一个为对象添加<code>Iterator</code>接口的例子。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> obj </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">  data: [ </span><span style="color:#ADDCFF;">&#39;hello&#39;</span><span style="color:#F0F3F6;">, </span><span style="color:#ADDCFF;">&#39;world&#39;</span><span style="color:#F0F3F6;"> ],</span></span>
<span class="line"><span style="color:#F0F3F6;">  [Symbol.iterator]() {</span></span>
<span class="line"><span style="color:#FF9492;">    const</span><span style="color:#91CBFF;"> self</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> this</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">    let</span><span style="color:#F0F3F6;"> index </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 0</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">    return</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#DBB7FF;">      next</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#FF9492;">        if</span><span style="color:#F0F3F6;"> (index </span><span style="color:#FF9492;">&lt;</span><span style="color:#F0F3F6;"> self.data.</span><span style="color:#91CBFF;">length</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#FF9492;">          return</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">            value: self.data[index</span><span style="color:#FF9492;">++</span><span style="color:#F0F3F6;">],</span></span>
<span class="line"><span style="color:#F0F3F6;">            done: </span><span style="color:#91CBFF;">false</span></span>
<span class="line"><span style="color:#F0F3F6;">          };</span></span>
<span class="line"><span style="color:#F0F3F6;">        }</span></span>
<span class="line"><span style="color:#FF9492;">        return</span><span style="color:#F0F3F6;"> { value: </span><span style="color:#91CBFF;">undefined</span><span style="color:#F0F3F6;">, done: </span><span style="color:#91CBFF;">true</span><span style="color:#F0F3F6;"> };</span></span>
<span class="line"><span style="color:#F0F3F6;">      }</span></span>
<span class="line"><span style="color:#F0F3F6;">    };</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span></code></pre></div><p>对于类似数组的对象（存在数值键名和<code>length</code>属性），部署<code>Iterator</code>接口，有一个简便方法，就是<code>Symbol.iterator</code>方法直接引用数组的<code>Iterator</code>接口。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#91CBFF;">NodeList</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">prototype</span><span style="color:#F0F3F6;">[Symbol.iterator] </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> Array</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">prototype</span><span style="color:#F0F3F6;">[Symbol.iterator];</span></span>
<span class="line"><span style="color:#BDC4CC;">// 或者</span></span>
<span class="line"><span style="color:#91CBFF;">NodeList</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">prototype</span><span style="color:#F0F3F6;">[Symbol.iterator] </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [][Symbol.iterator];</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">[</span><span style="color:#FF9492;">...</span><span style="color:#F0F3F6;">document.</span><span style="color:#DBB7FF;">querySelectorAll</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;div&#39;</span><span style="color:#F0F3F6;">)] </span><span style="color:#BDC4CC;">// 可以执行了</span></span></code></pre></div><p><code>NodeList</code>对象是类似数组的对象，本来就具有遍历接口，可以直接遍历。上面代码中，我们将它的遍历接口改成数组的<code>Symbol.iterator</code>属性，可以看到没有任何影响。</p><p>下面是另一个类似数组的对象调用数组的<code>Symbol.iterator</code>方法的例子。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> iterable </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#91CBFF;">  0</span><span style="color:#F0F3F6;">: </span><span style="color:#ADDCFF;">&#39;a&#39;</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#91CBFF;">  1</span><span style="color:#F0F3F6;">: </span><span style="color:#ADDCFF;">&#39;b&#39;</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#91CBFF;">  2</span><span style="color:#F0F3F6;">: </span><span style="color:#ADDCFF;">&#39;c&#39;</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#F0F3F6;">  length: </span><span style="color:#91CBFF;">3</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#F0F3F6;">  [Symbol.iterator]: </span><span style="color:#91CBFF;">Array</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">prototype</span><span style="color:#F0F3F6;">[Symbol.iterator]</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span>
<span class="line"><span style="color:#FF9492;">for</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> item </span><span style="color:#FF9492;">of</span><span style="color:#F0F3F6;"> iterable) {</span></span>
<span class="line"><span style="color:#F0F3F6;">  console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(item); </span><span style="color:#BDC4CC;">// &#39;a&#39;, &#39;b&#39;, &#39;c&#39;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>注意，普通对象部署数组的<code>Symbol.iterator</code>方法，并无效果。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> iterable </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">  a: </span><span style="color:#ADDCFF;">&#39;a&#39;</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#F0F3F6;">  b: </span><span style="color:#ADDCFF;">&#39;b&#39;</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#F0F3F6;">  c: </span><span style="color:#ADDCFF;">&#39;c&#39;</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#F0F3F6;">  length: </span><span style="color:#91CBFF;">3</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#F0F3F6;">  [Symbol.iterator]: </span><span style="color:#91CBFF;">Array</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">prototype</span><span style="color:#F0F3F6;">[Symbol.iterator]</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span>
<span class="line"><span style="color:#FF9492;">for</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> item </span><span style="color:#FF9492;">of</span><span style="color:#F0F3F6;"> iterable) {</span></span>
<span class="line"><span style="color:#F0F3F6;">  console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(item); </span><span style="color:#BDC4CC;">// undefined, undefined, undefined</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>如果<code>Symbol.iterator</code>方法对应的不是遍历器生成函数（即会返回一个遍历器对象），解释引擎将会报错。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> obj </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> {};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">obj[Symbol.iterator] </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> () </span><span style="color:#FF9492;">=&gt;</span><span style="color:#91CBFF;"> 1</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">[</span><span style="color:#FF9492;">...</span><span style="color:#F0F3F6;">obj] </span><span style="color:#BDC4CC;">// TypeError: [] is not a function</span></span></code></pre></div><p>上面代码中，变量<code>obj</code>的<code>Symbol.iterator</code>方法对应的不是遍历器生成函数，因此报错。</p><p>有了遍历器接口，数据结构就可以用<code>for...of</code>循环遍历，也可以使用<code>while</code>循环遍历。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> $iterator </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> ITERABLE</span><span style="color:#F0F3F6;">[Symbol.iterator]();</span></span>
<span class="line"><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> $result </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> $iterator.</span><span style="color:#DBB7FF;">next</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#FF9492;">while</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">!</span><span style="color:#F0F3F6;">$result.done) {</span></span>
<span class="line"><span style="color:#FF9492;">  var</span><span style="color:#F0F3F6;"> x </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> $result.value;</span></span>
<span class="line"><span style="color:#BDC4CC;">  // ...</span></span>
<span class="line"><span style="color:#F0F3F6;">  $result </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> $iterator.</span><span style="color:#DBB7FF;">next</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面代码中，<code>ITERABLE</code>代表某种可遍历的数据结构，<code>$iterator</code>是它的遍历器对象。遍历器对象每次移动指针（<code>next</code>方法），都检查一下返回值的<code>done</code>属性，如果遍历还没结束，就移动遍历器对象的指针到下一步（<code>next</code>方法），不断循环。</p><h2 id="调用-iterator-接口的场合" tabindex="-1"><a class="header-anchor" href="#调用-iterator-接口的场合"><span>调用 Iterator 接口的场合</span></a></h2><p>有一些场合会默认调用<code>Iterator</code>接口（即<code>Symbol.iterator</code>方法），除了<code>for...of</code>循环，还有几个别的场合。</p><h3 id="解构赋值" tabindex="-1"><a class="header-anchor" href="#解构赋值"><span>解构赋值</span></a></h3><p>对数组和<code>Set</code>结构进行解构赋值时，会默认调用<code>Symbol.iterator</code>方法。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> set </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> Set</span><span style="color:#F0F3F6;">().</span><span style="color:#DBB7FF;">add</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;a&#39;</span><span style="color:#F0F3F6;">).</span><span style="color:#DBB7FF;">add</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;b&#39;</span><span style="color:#F0F3F6;">).</span><span style="color:#DBB7FF;">add</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;c&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> [x,y] </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> set;</span></span>
<span class="line"><span style="color:#BDC4CC;">// x=&#39;a&#39;; y=&#39;b&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> [first, </span><span style="color:#FF9492;">...</span><span style="color:#F0F3F6;">rest] </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> set;</span></span>
<span class="line"><span style="color:#BDC4CC;">// first=&#39;a&#39;; rest=[&#39;b&#39;,&#39;c&#39;];</span></span></code></pre></div><h3 id="扩展运算符" tabindex="-1"><a class="header-anchor" href="#扩展运算符"><span>扩展运算符</span></a></h3><p>扩展运算符（<code>...</code>）也会调用默认的<code>Iterator</code>接口。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">// 例一</span></span>
<span class="line"><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> str </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &#39;hello&#39;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">[</span><span style="color:#FF9492;">...</span><span style="color:#F0F3F6;">str] </span><span style="color:#BDC4CC;">//  [&#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;]</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;">// 例二</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> arr </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [</span><span style="color:#ADDCFF;">&#39;b&#39;</span><span style="color:#F0F3F6;">, </span><span style="color:#ADDCFF;">&#39;c&#39;</span><span style="color:#F0F3F6;">];</span></span>
<span class="line"><span style="color:#F0F3F6;">[</span><span style="color:#ADDCFF;">&#39;a&#39;</span><span style="color:#F0F3F6;">, </span><span style="color:#FF9492;">...</span><span style="color:#F0F3F6;">arr, </span><span style="color:#ADDCFF;">&#39;d&#39;</span><span style="color:#F0F3F6;">]</span></span>
<span class="line"><span style="color:#BDC4CC;">// [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]</span></span></code></pre></div><p>上面代码的扩展运算符内部就调用<code>Iterator</code>接口。</p><p>实际上，这提供了一种简便机制，可以将任何部署了<code>Iterator</code>接口的数据结构，转为数组。也就是说，只要某个数据结构部署了<code>Iterator</code>接口，就可以对它使用扩展运算符，将其转为数组。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> arr </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [</span><span style="color:#FF9492;">...</span><span style="color:#F0F3F6;">iterable];</span></span></code></pre></div><h3 id="yield" tabindex="-1"><a class="header-anchor" href="#yield"><span>yield*</span></a></h3><p><code>yield*</code>后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#DBB7FF;"> generator</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> function*</span><span style="color:#F0F3F6;"> () {</span></span>
<span class="line"><span style="color:#FF9492;">  yield</span><span style="color:#91CBFF;"> 1</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">  yield*</span><span style="color:#F0F3F6;"> [</span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">,</span><span style="color:#91CBFF;">3</span><span style="color:#F0F3F6;">,</span><span style="color:#91CBFF;">4</span><span style="color:#F0F3F6;">];</span></span>
<span class="line"><span style="color:#FF9492;">  yield</span><span style="color:#91CBFF;"> 5</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> iterator </span><span style="color:#FF9492;">=</span><span style="color:#DBB7FF;"> generator</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">iterator.</span><span style="color:#DBB7FF;">next</span><span style="color:#F0F3F6;">() </span><span style="color:#BDC4CC;">// { value: 1, done: false }</span></span>
<span class="line"><span style="color:#F0F3F6;">iterator.</span><span style="color:#DBB7FF;">next</span><span style="color:#F0F3F6;">() </span><span style="color:#BDC4CC;">// { value: 2, done: false }</span></span>
<span class="line"><span style="color:#F0F3F6;">iterator.</span><span style="color:#DBB7FF;">next</span><span style="color:#F0F3F6;">() </span><span style="color:#BDC4CC;">// { value: 3, done: false }</span></span>
<span class="line"><span style="color:#F0F3F6;">iterator.</span><span style="color:#DBB7FF;">next</span><span style="color:#F0F3F6;">() </span><span style="color:#BDC4CC;">// { value: 4, done: false }</span></span>
<span class="line"><span style="color:#F0F3F6;">iterator.</span><span style="color:#DBB7FF;">next</span><span style="color:#F0F3F6;">() </span><span style="color:#BDC4CC;">// { value: 5, done: false }</span></span>
<span class="line"><span style="color:#F0F3F6;">iterator.</span><span style="color:#DBB7FF;">next</span><span style="color:#F0F3F6;">() </span><span style="color:#BDC4CC;">// { value: undefined, done: true }</span></span></code></pre></div><h3 id="其他场合" tabindex="-1"><a class="header-anchor" href="#其他场合"><span>其他场合</span></a></h3><p>由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。下面是一些例子。</p><ul><li><code>for...of</code></li><li><code>Array.from()</code></li><li><code>Map(), Set(), WeakMap(), WeakSet()（比如new Map([[&#39;a&#39;,1],[&#39;b&#39;,2]])）</code></li><li><code>Promise.all()</code></li><li><code>Promise.race()</code></li></ul><h2 id="字符串的-iterator-接口" tabindex="-1"><a class="header-anchor" href="#字符串的-iterator-接口"><span>字符串的 Iterator 接口</span></a></h2><p>字符串是一个类似数组的对象，也原生具有<code>Iterator</code>接口。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> someString </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &quot;hi&quot;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">typeof</span><span style="color:#F0F3F6;"> someString[Symbol.iterator]</span></span>
<span class="line"><span style="color:#BDC4CC;">// &quot;function&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> iterator </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> someString[Symbol.iterator]();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">iterator.</span><span style="color:#DBB7FF;">next</span><span style="color:#F0F3F6;">()  </span><span style="color:#BDC4CC;">// { value: &quot;h&quot;, done: false }</span></span>
<span class="line"><span style="color:#F0F3F6;">iterator.</span><span style="color:#DBB7FF;">next</span><span style="color:#F0F3F6;">()  </span><span style="color:#BDC4CC;">// { value: &quot;i&quot;, done: false }</span></span>
<span class="line"><span style="color:#F0F3F6;">iterator.</span><span style="color:#DBB7FF;">next</span><span style="color:#F0F3F6;">()  </span><span style="color:#BDC4CC;">// { value: undefined, done: true }</span></span></code></pre></div><p>上面代码中，调用<code>Symbol.iterator</code>方法返回一个遍历器对象，在这个遍历器上可以调用<code>next</code>方法，实现对于字符串的遍历。</p><p>可以覆盖原生的<code>Symbol.iterator</code>方法，达到修改遍历器行为的目的。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> str </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> String</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;hi&quot;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">[</span><span style="color:#FF9492;">...</span><span style="color:#F0F3F6;">str] </span><span style="color:#BDC4CC;">// [&quot;h&quot;, &quot;i&quot;]</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">str[Symbol.iterator] </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> function</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#FF9492;">  return</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#DBB7FF;">    next</span><span style="color:#F0F3F6;">: </span><span style="color:#FF9492;">function</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#FF9492;">      if</span><span style="color:#F0F3F6;"> (</span><span style="color:#91CBFF;">this</span><span style="color:#F0F3F6;">._first) {</span></span>
<span class="line"><span style="color:#91CBFF;">        this</span><span style="color:#F0F3F6;">._first </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> false</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">        return</span><span style="color:#F0F3F6;"> { value: </span><span style="color:#ADDCFF;">&quot;bye&quot;</span><span style="color:#F0F3F6;">, done: </span><span style="color:#91CBFF;">false</span><span style="color:#F0F3F6;"> };</span></span>
<span class="line"><span style="color:#F0F3F6;">      } </span><span style="color:#FF9492;">else</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">        return</span><span style="color:#F0F3F6;"> { done: </span><span style="color:#91CBFF;">true</span><span style="color:#F0F3F6;"> };</span></span>
<span class="line"><span style="color:#F0F3F6;">      }</span></span>
<span class="line"><span style="color:#F0F3F6;">    },</span></span>
<span class="line"><span style="color:#F0F3F6;">    _first: </span><span style="color:#91CBFF;">true</span></span>
<span class="line"><span style="color:#F0F3F6;">  };</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">[</span><span style="color:#FF9492;">...</span><span style="color:#F0F3F6;">str] </span><span style="color:#BDC4CC;">// [&quot;bye&quot;]</span></span>
<span class="line"><span style="color:#F0F3F6;">str </span><span style="color:#BDC4CC;">// &quot;hi&quot;</span></span></code></pre></div><p>上面代码中，字符串<code>str</code>的<code>Symbol.iterator</code>方法被修改了，所以扩展运算符（<code>...</code>）返回的值变成了<code>bye</code>，而字符串本身还是<code>hi</code>。</p><h2 id="iterator-接口与-generator-函数" tabindex="-1"><a class="header-anchor" href="#iterator-接口与-generator-函数"><span>Iterator 接口与 Generator 函数</span></a></h2><p><code>Symbol.iterator()</code>方法的最简单实现，还是使用<code>Generator</code>函数。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> myIterable </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">  [Symbol.iterator]: </span><span style="color:#FF9492;">function*</span><span style="color:#F0F3F6;"> () {</span></span>
<span class="line"><span style="color:#FF9492;">    yield</span><span style="color:#91CBFF;"> 1</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">    yield</span><span style="color:#91CBFF;"> 2</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">    yield</span><span style="color:#91CBFF;"> 3</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span>
<span class="line"><span style="color:#F0F3F6;">[</span><span style="color:#FF9492;">...</span><span style="color:#F0F3F6;">myIterable] </span><span style="color:#BDC4CC;">// [1, 2, 3]</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;">// 或者采用下面的简洁写法</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> obj </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  *</span><span style="color:#F0F3F6;"> [Symbol.iterator]() {</span></span>
<span class="line"><span style="color:#FF9492;">    yield</span><span style="color:#ADDCFF;"> &#39;hello&#39;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">    yield</span><span style="color:#ADDCFF;"> &#39;world&#39;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">for</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> x </span><span style="color:#FF9492;">of</span><span style="color:#F0F3F6;"> obj) {</span></span>
<span class="line"><span style="color:#F0F3F6;">  console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(x);</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#BDC4CC;">// &quot;hello&quot;</span></span>
<span class="line"><span style="color:#BDC4CC;">// &quot;world&quot;</span></span></code></pre></div><p>上面代码中，<code>Symbol.iterator()</code>方法几乎不用部署任何代码，只要用<code>yield</code>命令给出每一步的返回值即可。</p><h2 id="遍历器对象的-return-throw" tabindex="-1"><a class="header-anchor" href="#遍历器对象的-return-throw"><span>遍历器对象的 return()，throw()</span></a></h2><p>遍历器对象除了具有<code>next()</code>方法，还可以具有<code>return()</code>方法和<code>throw()</code>方法。如果你自己写遍历器对象生成函数，那么<code>next()</code>方法是必须部署的，<code>return()</code>方法和<code>throw()</code>方法是否部署是可选的。</p><p><code>return()</code>方法的使用场合是，如果<code>for...of</code>循环提前退出（通常是因为出错，或者有<code>break</code>语句），就会调用<code>return()</code>方法。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署<code>return()</code>方法。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">function</span><span style="color:#DBB7FF;"> readLinesSync</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">file</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#FF9492;">    return</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">        [Symbol.iterator]() {</span></span>
<span class="line"><span style="color:#FF9492;">            return</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#DBB7FF;">                next</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#FF9492;">                    return</span><span style="color:#F0F3F6;"> { done: </span><span style="color:#91CBFF;">false</span><span style="color:#F0F3F6;"> };</span></span>
<span class="line"><span style="color:#F0F3F6;">                },</span></span>
<span class="line"><span style="color:#DBB7FF;">                return</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#F0F3F6;">                    file.</span><span style="color:#DBB7FF;">close</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#FF9492;">                    return</span><span style="color:#F0F3F6;"> { done: </span><span style="color:#91CBFF;">true</span><span style="color:#F0F3F6;"> };</span></span>
<span class="line"><span style="color:#F0F3F6;">                }</span></span>
<span class="line"><span style="color:#F0F3F6;">            };</span></span>
<span class="line"><span style="color:#F0F3F6;">        },</span></span>
<span class="line"><span style="color:#F0F3F6;">    };</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面代码中，函数<code>readLinesSync</code>接受一个文件对象作为参数，返回一个遍历器对象，其中除了<code>next()</code>方法，还部署了<code>return()</code>方法。下面的两种情况，都会触发执行<code>return()</code>方法。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">// 情况一</span></span>
<span class="line"><span style="color:#FF9492;">for</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> line </span><span style="color:#FF9492;">of</span><span style="color:#DBB7FF;"> readLinesSync</span><span style="color:#F0F3F6;">(fileName)) {</span></span>
<span class="line"><span style="color:#F0F3F6;">  console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(line);</span></span>
<span class="line"><span style="color:#FF9492;">  break</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;">// 情况二</span></span>
<span class="line"><span style="color:#FF9492;">for</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> line </span><span style="color:#FF9492;">of</span><span style="color:#DBB7FF;"> readLinesSync</span><span style="color:#F0F3F6;">(fileName)) {</span></span>
<span class="line"><span style="color:#F0F3F6;">  console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(line);</span></span>
<span class="line"><span style="color:#FF9492;">  throw</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> Error</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面代码中，情况一输出文件的第一行以后，就会执行<code>return()</code>方法，关闭这个文件；情况二会在执行<code>return()</code>方法关闭文件之后，再抛出错误。</p><p>注意，<code>return()</code>方法必须返回一个对象，这是<code>Generator</code>语法决定的。</p><p><code>throw()</code>方法主要是配合<code>Generator</code>函数使用，一般的遍历器对象用不到这个方法。</p><h2 id="for-of-循环" tabindex="-1"><a class="header-anchor" href="#for-of-循环"><span>for...of 循环</span></a></h2><p>ES6 借鉴 C++、Java、C# 和 Python 语言，引入了<code>for...of</code>循环，作为遍历所有数据结构的统一的方法。</p><p>一个数据结构只要部署了<code>Symbol.iterator</code>属性，就被视为具有<code>iterator</code>接口，就可以用<code>for...of</code>循环遍历它的成员。也就是说，<code>for...of</code>循环内部调用的是数据结构的<code>Symbol.iterator</code>方法。</p><p><code>for...of</code>循环可以使用的范围包括数组、<code>Set</code>和<code>Map</code>结构、某些类似数组的对象（比如<code>arguments</code>对象、DOM <code>NodeList</code>对象）、<code>Generator</code>对象，以及字符串。</p><h3 id="数组" tabindex="-1"><a class="header-anchor" href="#数组"><span>数组</span></a></h3><p>数组原生具备<code>iterator</code>接口（即默认部署了<code>Symbol.iterator</code>属性），<code>for...of</code>循环本质上就是调用这个接口产生的遍历器，可以用下面的代码证明。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> arr</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> [</span><span style="color:#ADDCFF;">&#39;red&#39;</span><span style="color:#F0F3F6;">, </span><span style="color:#ADDCFF;">&#39;green&#39;</span><span style="color:#F0F3F6;">, </span><span style="color:#ADDCFF;">&#39;blue&#39;</span><span style="color:#F0F3F6;">];</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">for</span><span style="color:#F0F3F6;">(</span><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> v </span><span style="color:#FF9492;">of</span><span style="color:#F0F3F6;"> arr) {</span></span>
<span class="line"><span style="color:#F0F3F6;">  console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(v); </span><span style="color:#BDC4CC;">// red green blue</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> obj</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> {};</span></span>
<span class="line"><span style="color:#F0F3F6;">obj[Symbol.iterator] </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> arr[Symbol.iterator].</span><span style="color:#DBB7FF;">bind</span><span style="color:#F0F3F6;">(arr);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">for</span><span style="color:#F0F3F6;">(</span><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> v </span><span style="color:#FF9492;">of</span><span style="color:#F0F3F6;"> obj) {</span></span>
<span class="line"><span style="color:#F0F3F6;">  console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(v); </span><span style="color:#BDC4CC;">// red green blue</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面代码中，空对象<code>obj</code>部署了数组<code>arr</code>的<code>Symbol.iterator</code>属性，结果<code>obj</code>的<code>for...of</code>循环，产生了与<code>arr</code>完全一样的结果。</p><p><code>for...of</code>循环可以代替数组实例的<code>forEach</code>方法。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> arr</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> [</span><span style="color:#ADDCFF;">&#39;red&#39;</span><span style="color:#F0F3F6;">, </span><span style="color:#ADDCFF;">&#39;green&#39;</span><span style="color:#F0F3F6;">, </span><span style="color:#ADDCFF;">&#39;blue&#39;</span><span style="color:#F0F3F6;">];</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">arr.</span><span style="color:#DBB7FF;">forEach</span><span style="color:#F0F3F6;">(</span><span style="color:#FF9492;">function</span><span style="color:#F0F3F6;"> (</span><span style="color:#FFB757;">element</span><span style="color:#F0F3F6;">, </span><span style="color:#FFB757;">index</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#F0F3F6;">  console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(element); </span><span style="color:#BDC4CC;">// red green blue</span></span>
<span class="line"><span style="color:#F0F3F6;">  console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(index);   </span><span style="color:#BDC4CC;">// 0 1 2</span></span>
<span class="line"><span style="color:#F0F3F6;">});</span></span></code></pre></div><p>JavaScript 原有的<code>for...in</code>循环，只能获得对象的键名，不能直接获取键值。ES6 提供<code>for...of</code>循环，允许遍历获得键值。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> arr </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [</span><span style="color:#ADDCFF;">&#39;a&#39;</span><span style="color:#F0F3F6;">, </span><span style="color:#ADDCFF;">&#39;b&#39;</span><span style="color:#F0F3F6;">, </span><span style="color:#ADDCFF;">&#39;c&#39;</span><span style="color:#F0F3F6;">, </span><span style="color:#ADDCFF;">&#39;d&#39;</span><span style="color:#F0F3F6;">];</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">for</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> a </span><span style="color:#FF9492;">in</span><span style="color:#F0F3F6;"> arr) {</span></span>
<span class="line"><span style="color:#F0F3F6;">  console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(a); </span><span style="color:#BDC4CC;">// 0 1 2 3</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">for</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> a </span><span style="color:#FF9492;">of</span><span style="color:#F0F3F6;"> arr) {</span></span>
<span class="line"><span style="color:#F0F3F6;">  console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(a); </span><span style="color:#BDC4CC;">// a b c d</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面代码表明，<code>for...in</code>循环读取键名，<code>for...of</code>循环读取键值。如果要通过<code>for...of</code>循环，获取数组的索引，可以借助数组实例的<code>entries</code>方法和<code>keys</code>方法。</p><p><code>for...of</code>循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性。这一点跟<code>for...in</code>循环也不一样。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> arr </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [</span><span style="color:#91CBFF;">3</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">5</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">7</span><span style="color:#F0F3F6;">];</span></span>
<span class="line"><span style="color:#F0F3F6;">arr.foo </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &#39;hello&#39;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">for</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> i </span><span style="color:#FF9492;">in</span><span style="color:#F0F3F6;"> arr) {</span></span>
<span class="line"><span style="color:#F0F3F6;">  console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(i); </span><span style="color:#BDC4CC;">// &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;foo&quot;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">for</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> i </span><span style="color:#FF9492;">of</span><span style="color:#F0F3F6;"> arr) {</span></span>
<span class="line"><span style="color:#F0F3F6;">  console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(i); </span><span style="color:#BDC4CC;">//  &quot;3&quot;, &quot;5&quot;, &quot;7&quot;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面代码中，<code>for...of</code>循环不会返回数组<code>arr</code>的<code>foo</code>属性。</p><h3 id="set-和-map-结构" tabindex="-1"><a class="header-anchor" href="#set-和-map-结构"><span>Set 和 Map 结构</span></a></h3><p><code>Set</code>和<code>Map</code>结构也原生具有<code>Iterator</code>接口，可以直接使用<code>for...of</code>循环。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> engines </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> Set</span><span style="color:#F0F3F6;">([</span><span style="color:#ADDCFF;">&quot;Gecko&quot;</span><span style="color:#F0F3F6;">, </span><span style="color:#ADDCFF;">&quot;Trident&quot;</span><span style="color:#F0F3F6;">, </span><span style="color:#ADDCFF;">&quot;Webkit&quot;</span><span style="color:#F0F3F6;">, </span><span style="color:#ADDCFF;">&quot;Webkit&quot;</span><span style="color:#F0F3F6;">]);</span></span>
<span class="line"><span style="color:#FF9492;">for</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> e </span><span style="color:#FF9492;">of</span><span style="color:#F0F3F6;"> engines) {</span></span>
<span class="line"><span style="color:#F0F3F6;">  console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(e);</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#BDC4CC;">// Gecko</span></span>
<span class="line"><span style="color:#BDC4CC;">// Trident</span></span>
<span class="line"><span style="color:#BDC4CC;">// Webkit</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> es6 </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> Map</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#F0F3F6;">es6.</span><span style="color:#DBB7FF;">set</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;edition&quot;</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">6</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#F0F3F6;">es6.</span><span style="color:#DBB7FF;">set</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;committee&quot;</span><span style="color:#F0F3F6;">, </span><span style="color:#ADDCFF;">&quot;TC39&quot;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#F0F3F6;">es6.</span><span style="color:#DBB7FF;">set</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;standard&quot;</span><span style="color:#F0F3F6;">, </span><span style="color:#ADDCFF;">&quot;ECMA-262&quot;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#FF9492;">for</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> [name, value] </span><span style="color:#FF9492;">of</span><span style="color:#F0F3F6;"> es6) {</span></span>
<span class="line"><span style="color:#F0F3F6;">  console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(name </span><span style="color:#FF9492;">+</span><span style="color:#ADDCFF;"> &quot;: &quot;</span><span style="color:#FF9492;"> +</span><span style="color:#F0F3F6;"> value);</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#BDC4CC;">// edition: 6</span></span>
<span class="line"><span style="color:#BDC4CC;">// committee: TC39</span></span>
<span class="line"><span style="color:#BDC4CC;">// standard: ECMA-262</span></span></code></pre></div><p>上面代码演示了如何遍历<code>Set</code>结构和<code>Map</code>结构。值得注意的地方有两个，首先，遍历的顺序是按照各个成员被添加进数据结构的顺序。其次，<code>Set</code>结构遍历时，返回的是一个值，而<code>Map</code>结构遍历时，返回的是一个数组，该数组的两个成员分别为当前<code>Map</code>成员的键名和键值。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> map </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> Map</span><span style="color:#F0F3F6;">().</span><span style="color:#DBB7FF;">set</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;a&#39;</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">).</span><span style="color:#DBB7FF;">set</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;b&#39;</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#FF9492;">for</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> pair </span><span style="color:#FF9492;">of</span><span style="color:#F0F3F6;"> map) {</span></span>
<span class="line"><span style="color:#F0F3F6;">  console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(pair);</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#BDC4CC;">// [&#39;a&#39;, 1]</span></span>
<span class="line"><span style="color:#BDC4CC;">// [&#39;b&#39;, 2]</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">for</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> [key, value] </span><span style="color:#FF9492;">of</span><span style="color:#F0F3F6;"> map) {</span></span>
<span class="line"><span style="color:#F0F3F6;">  console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(key </span><span style="color:#FF9492;">+</span><span style="color:#ADDCFF;"> &#39; : &#39;</span><span style="color:#FF9492;"> +</span><span style="color:#F0F3F6;"> value);</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#BDC4CC;">// a : 1</span></span>
<span class="line"><span style="color:#BDC4CC;">// b : 2</span></span></code></pre></div><h3 id="计算生成的数据结构" tabindex="-1"><a class="header-anchor" href="#计算生成的数据结构"><span>计算生成的数据结构</span></a></h3><p>有些数据结构是在现有数据结构的基础上，计算生成的。比如，ES6 的数组、<code>Set、Map</code>都部署了以下三个方法，调用后都返回遍历器对象。</p><ul><li><code>entries()</code>返回一个遍历器对象，用来遍历<code>[键名, 键值]</code>组成的数组。对于数组，键名就是索引值；对于<code>Set</code>，键名与键值相同。<code>Map</code>结构的<code>Iterator</code>接口，默认就是调用<code>entries</code>方法。</li><li><code>keys()</code>返回一个遍历器对象，用来遍历所有的键名。</li><li><code>values()</code>返回一个遍历器对象，用来遍历所有的键值。</li></ul><p>这三个方法调用后生成的遍历器对象，所遍历的都是计算生成的数据结构。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> arr </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [</span><span style="color:#ADDCFF;">&#39;a&#39;</span><span style="color:#F0F3F6;">, </span><span style="color:#ADDCFF;">&#39;b&#39;</span><span style="color:#F0F3F6;">, </span><span style="color:#ADDCFF;">&#39;c&#39;</span><span style="color:#F0F3F6;">];</span></span>
<span class="line"><span style="color:#FF9492;">for</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> pair </span><span style="color:#FF9492;">of</span><span style="color:#F0F3F6;"> arr.</span><span style="color:#DBB7FF;">entries</span><span style="color:#F0F3F6;">()) {</span></span>
<span class="line"><span style="color:#F0F3F6;">  console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(pair);</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#BDC4CC;">// [0, &#39;a&#39;]</span></span>
<span class="line"><span style="color:#BDC4CC;">// [1, &#39;b&#39;]</span></span>
<span class="line"><span style="color:#BDC4CC;">// [2, &#39;c&#39;]</span></span></code></pre></div><h3 id="类似数组的对象" tabindex="-1"><a class="header-anchor" href="#类似数组的对象"><span>类似数组的对象</span></a></h3><p>类似数组的对象包括好几类。下面是<code>for...of</code>循环用于字符串、DOM <code>NodeList</code>对象、<code>arguments</code>对象的例子。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">// 字符串</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> str </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &quot;hello&quot;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">for</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> s </span><span style="color:#FF9492;">of</span><span style="color:#F0F3F6;"> str) {</span></span>
<span class="line"><span style="color:#F0F3F6;">  console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(s); </span><span style="color:#BDC4CC;">// h e l l o</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;">// DOM NodeList对象</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> paras </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> document.</span><span style="color:#DBB7FF;">querySelectorAll</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;p&quot;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">for</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> p </span><span style="color:#FF9492;">of</span><span style="color:#F0F3F6;"> paras) {</span></span>
<span class="line"><span style="color:#F0F3F6;">  p.classList.</span><span style="color:#DBB7FF;">add</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;test&quot;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;">// arguments对象</span></span>
<span class="line"><span style="color:#FF9492;">function</span><span style="color:#DBB7FF;"> printArgs</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#FF9492;">  for</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> x </span><span style="color:#FF9492;">of</span><span style="color:#91CBFF;"> arguments</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#F0F3F6;">    console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(x);</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#DBB7FF;">printArgs</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;a&#39;</span><span style="color:#F0F3F6;">, </span><span style="color:#ADDCFF;">&#39;b&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#BDC4CC;">// &#39;a&#39;</span></span>
<span class="line"><span style="color:#BDC4CC;">// &#39;b&#39;</span></span></code></pre></div><p>对于字符串来说，<code>for...of</code>循环还有一个特点，就是会正确识别 32 位 UTF-16 字符。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">for</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> x </span><span style="color:#FF9492;">of</span><span style="color:#ADDCFF;"> &#39;a</span><span style="color:#FF9492;">\\uD83D\\uDC0A</span><span style="color:#ADDCFF;">&#39;</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#F0F3F6;">  console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(x);</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#BDC4CC;">// &#39;a&#39;</span></span>
<span class="line"><span style="color:#BDC4CC;">// &#39;\\uD83D\\uDC0A&#39;</span></span></code></pre></div><p>并不是所有类似数组的对象都具有<code>Iterator</code>接口，一个简便的解决方法，就是使用<code>Array.from</code>方法将其转为数组。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> arrayLike </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> { length: </span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">0</span><span style="color:#F0F3F6;">: </span><span style="color:#ADDCFF;">&#39;a&#39;</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">: </span><span style="color:#ADDCFF;">&#39;b&#39;</span><span style="color:#F0F3F6;"> };</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;">// 报错</span></span>
<span class="line"><span style="color:#FF9492;">for</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> x </span><span style="color:#FF9492;">of</span><span style="color:#F0F3F6;"> arrayLike) {</span></span>
<span class="line"><span style="color:#F0F3F6;">  console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(x);</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;">// 正确</span></span>
<span class="line"><span style="color:#FF9492;">for</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> x </span><span style="color:#FF9492;">of</span><span style="color:#F0F3F6;"> Array.</span><span style="color:#DBB7FF;">from</span><span style="color:#F0F3F6;">(arrayLike)) {</span></span>
<span class="line"><span style="color:#F0F3F6;">  console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(x);</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><h3 id="对象" tabindex="-1"><a class="header-anchor" href="#对象"><span>对象</span></a></h3><p>对于普通的对象，<code>for...of</code>结构不能直接使用，会报错，必须部署了<code>Iterator</code>接口后才能使用。但是，这样情况下，<code>for...in</code>循环依然可以用来遍历键名。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> es6 </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">  edition: </span><span style="color:#91CBFF;">6</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#F0F3F6;">  committee: </span><span style="color:#ADDCFF;">&quot;TC39&quot;</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#F0F3F6;">  standard: </span><span style="color:#ADDCFF;">&quot;ECMA-262&quot;</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">for</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> e </span><span style="color:#FF9492;">in</span><span style="color:#F0F3F6;"> es6) {</span></span>
<span class="line"><span style="color:#F0F3F6;">  console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(e);</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#BDC4CC;">// edition</span></span>
<span class="line"><span style="color:#BDC4CC;">// committee</span></span>
<span class="line"><span style="color:#BDC4CC;">// standard</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">for</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> e </span><span style="color:#FF9492;">of</span><span style="color:#F0F3F6;"> es6) {</span></span>
<span class="line"><span style="color:#F0F3F6;">  console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(e);</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#BDC4CC;">// TypeError: es6[Symbol.iterator] is not a function</span></span></code></pre></div><p>上面代码表示，对于普通的对象，<code>for...in</code>循环可以遍历键名，<code>for...of</code>循环会报错。</p><p>一种解决方法是，使用<code>Object.keys</code>方法将对象的键名生成一个数组，然后遍历这个数组。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">for</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> key </span><span style="color:#FF9492;">of</span><span style="color:#F0F3F6;"> Object.</span><span style="color:#DBB7FF;">keys</span><span style="color:#F0F3F6;">(someObject)) {</span></span>
<span class="line"><span style="color:#F0F3F6;">  console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(key </span><span style="color:#FF9492;">+</span><span style="color:#ADDCFF;"> &#39;: &#39;</span><span style="color:#FF9492;"> +</span><span style="color:#F0F3F6;"> someObject[key]);</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>另一个方法是使用<code>Generator</code>函数将对象重新包装一下。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> obj</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> { a: </span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">, b: </span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">, c: </span><span style="color:#91CBFF;">3</span><span style="color:#F0F3F6;"> }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">function*</span><span style="color:#DBB7FF;"> entries</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">obj</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#FF9492;">  for</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> key </span><span style="color:#FF9492;">of</span><span style="color:#F0F3F6;"> Object.</span><span style="color:#DBB7FF;">keys</span><span style="color:#F0F3F6;">(obj)) {</span></span>
<span class="line"><span style="color:#FF9492;">    yield</span><span style="color:#F0F3F6;"> [key, obj[key]];</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">for</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> [key, value] </span><span style="color:#FF9492;">of</span><span style="color:#DBB7FF;"> entries</span><span style="color:#F0F3F6;">(obj)) {</span></span>
<span class="line"><span style="color:#F0F3F6;">  console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(key, </span><span style="color:#ADDCFF;">&#39;-&gt;&#39;</span><span style="color:#F0F3F6;">, value);</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#BDC4CC;">// a -&gt; 1</span></span>
<span class="line"><span style="color:#BDC4CC;">// b -&gt; 2</span></span>
<span class="line"><span style="color:#BDC4CC;">// c -&gt; 3</span></span></code></pre></div><h3 id="与其他遍历语法的比较" tabindex="-1"><a class="header-anchor" href="#与其他遍历语法的比较"><span>与其他遍历语法的比较</span></a></h3><p>以数组为例，JavaScript 提供多种遍历语法。最原始的写法就是<code>for</code>循环。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">for</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> index </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 0</span><span style="color:#F0F3F6;">; index </span><span style="color:#FF9492;">&lt;</span><span style="color:#F0F3F6;"> myArray.</span><span style="color:#91CBFF;">length</span><span style="color:#F0F3F6;">; index</span><span style="color:#FF9492;">++</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#F0F3F6;">	console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(myArray[index]);</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>这种写法比较麻烦，因此数组提供内置的<code>forEach</code>方法。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">myArray.</span><span style="color:#DBB7FF;">forEach</span><span style="color:#F0F3F6;">(</span><span style="color:#FF9492;">function</span><span style="color:#F0F3F6;"> (</span><span style="color:#FFB757;">value</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#F0F3F6;">	console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(value);</span></span>
<span class="line"><span style="color:#F0F3F6;">});</span></span></code></pre></div><p>这种写法的问题在于，无法中途跳出<code>forEach</code>循环，<code>break</code>命令或<code>return</code>命令都不能奏效。</p><p><code>for...in</code>循环可以遍历数组的键名。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">for</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> index </span><span style="color:#FF9492;">in</span><span style="color:#F0F3F6;"> myArray) {</span></span>
<span class="line"><span style="color:#F0F3F6;">	console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(myArray[index]);</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p><code>for...in</code>循环有几个缺点。</p><ul><li>数组的键名是数字，但是<code>for...in</code>循环是以字符串作为键名“0”、“1”、“2”等等。</li><li><code>for...in</code>循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。</li><li>某些情况下，<code>for...in</code>循环会以任意顺序遍历键名。</li></ul><p>总之，<code>for...in</code>循环主要是为遍历对象而设计的，不适用于遍历数组。</p><p><code>for...of</code>循环相比上面几种做法，有一些显著的优点。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">for</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> value </span><span style="color:#FF9492;">of</span><span style="color:#F0F3F6;"> myArray) {</span></span>
<span class="line"><span style="color:#F0F3F6;">	console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(value);</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><ul><li>有着同<code>for...in</code>一样的简洁语法，但是没有<code>for...in</code>那些缺点。</li><li>不同于<code>forEach</code>方法，它可以与<code>break、continue</code>和<code>return</code>配合使用。</li><li>提供了遍历所有数据结构的统一操作接口。</li></ul><p>下面是一个使用<code>break</code>语句，跳出<code>for...of</code>循环的例子。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">for</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> n </span><span style="color:#FF9492;">of</span><span style="color:#F0F3F6;"> fibonacci) {</span></span>
<span class="line"><span style="color:#FF9492;">  if</span><span style="color:#F0F3F6;"> (n </span><span style="color:#FF9492;">&gt;</span><span style="color:#91CBFF;"> 1000</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#FF9492;">    break</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">  console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(n);</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面的例子，会输出斐波纳契数列小于等于 1000 的项。如果当前项大于 1000，就会使用<code>break</code>语句跳出<code>for...of</code>循环。</p>`,150)]))}const r=a(p,[["render",e],["__file","ES6Iterator和forof循环.html.vue"]]),y=JSON.parse('{"path":"/js/es6/ES6Iterator%E5%92%8Cforof%E5%BE%AA%E7%8E%AF.html","title":"","lang":"zh-CN","frontmatter":{"description":"Iterator（遍历器）的概念 JavaScript 原有的表示“集合”的数据结构，主要是数组和对象，ES6 又添加了Map和Set。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是Map，Map的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。 遍历器（Iterator）就是这样一种机制。它是...","head":[["meta",{"property":"og:url","content":"https://0oWSQo0.github.io/wsq-blog/js/es6/ES6Iterator%E5%92%8Cforof%E5%BE%AA%E7%8E%AF.html"}],["meta",{"property":"og:description","content":"Iterator（遍历器）的概念 JavaScript 原有的表示“集合”的数据结构，主要是数组和对象，ES6 又添加了Map和Set。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是Map，Map的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。 遍历器（Iterator）就是这样一种机制。它是..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-11-01T01:55:29.000Z"}],["meta",{"property":"article:modified_time","content":"2024-11-01T01:55:29.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-11-01T01:55:29.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"WSQ\\",\\"url\\":\\"https://0oWSQo0.github.com\\"}]}"]]},"headers":[{"level":2,"title":"Iterator（遍历器）的概念","slug":"iterator-遍历器-的概念","link":"#iterator-遍历器-的概念","children":[]},{"level":2,"title":"默认 Iterator 接口","slug":"默认-iterator-接口","link":"#默认-iterator-接口","children":[]},{"level":2,"title":"调用 Iterator 接口的场合","slug":"调用-iterator-接口的场合","link":"#调用-iterator-接口的场合","children":[{"level":3,"title":"解构赋值","slug":"解构赋值","link":"#解构赋值","children":[]},{"level":3,"title":"扩展运算符","slug":"扩展运算符","link":"#扩展运算符","children":[]},{"level":3,"title":"yield*","slug":"yield","link":"#yield","children":[]},{"level":3,"title":"其他场合","slug":"其他场合","link":"#其他场合","children":[]}]},{"level":2,"title":"字符串的 Iterator 接口","slug":"字符串的-iterator-接口","link":"#字符串的-iterator-接口","children":[]},{"level":2,"title":"Iterator 接口与 Generator 函数","slug":"iterator-接口与-generator-函数","link":"#iterator-接口与-generator-函数","children":[]},{"level":2,"title":"遍历器对象的 return()，throw()","slug":"遍历器对象的-return-throw","link":"#遍历器对象的-return-throw","children":[]},{"level":2,"title":"for...of 循环","slug":"for-of-循环","link":"#for-of-循环","children":[{"level":3,"title":"数组","slug":"数组","link":"#数组","children":[]},{"level":3,"title":"Set 和 Map 结构","slug":"set-和-map-结构","link":"#set-和-map-结构","children":[]},{"level":3,"title":"计算生成的数据结构","slug":"计算生成的数据结构","link":"#计算生成的数据结构","children":[]},{"level":3,"title":"类似数组的对象","slug":"类似数组的对象","link":"#类似数组的对象","children":[]},{"level":3,"title":"对象","slug":"对象","link":"#对象","children":[]},{"level":3,"title":"与其他遍历语法的比较","slug":"与其他遍历语法的比较","link":"#与其他遍历语法的比较","children":[]}]}],"git":{"createdTime":1730426129000,"updatedTime":1730426129000,"contributors":[{"name":"WSQ","email":"592786982@qq.com","commits":1}]},"readingTime":{"minutes":18.05,"words":5414},"filePathRelative":"js/es6/ES6Iterator和forof循环.md","localizedDate":"2024年11月1日","autoDesc":true}');export{r as comp,y as data};
