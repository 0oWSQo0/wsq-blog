import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as l,d as n,o as e}from"./app-CRBxQhNH.js";const o={};function p(c,s){return e(),l("div",null,s[0]||(s[0]=[n(`<h2 id="shift-命令" tabindex="-1"><a class="header-anchor" href="#shift-命令"><span>shift 命令</span></a></h2><p><code>shift</code>命令可以改变脚本参数，每次执行都会移除脚本当前的第一个参数（<code>$1</code>），使得后面的参数向前一位，即<code>$2</code>变成<code>$1、$3</code>变成<code>$2、$4</code>变成<code>$3</code>，以此类推。</p><p><code>while</code>循环结合<code>shift</code>命令，也可以读取每一个参数。</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">#!/bin/bash</span></span>
<span class="line"></span>
<span class="line"><span style="color:#91CBFF;">echo</span><span style="color:#ADDCFF;"> &quot;一共输入了 </span><span style="color:#91CBFF;">$#</span><span style="color:#ADDCFF;"> 个参数&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">while</span><span style="color:#F0F3F6;"> [ </span><span style="color:#ADDCFF;">&quot;</span><span style="color:#91CBFF;">$1</span><span style="color:#ADDCFF;">&quot;</span><span style="color:#FF9492;"> !=</span><span style="color:#ADDCFF;"> &quot;&quot;</span><span style="color:#F0F3F6;"> ]; </span><span style="color:#FF9492;">do</span></span>
<span class="line"><span style="color:#91CBFF;">  echo</span><span style="color:#ADDCFF;"> &quot;剩下 </span><span style="color:#91CBFF;">$#</span><span style="color:#ADDCFF;"> 个参数&quot;</span></span>
<span class="line"><span style="color:#91CBFF;">  echo</span><span style="color:#ADDCFF;"> &quot;参数：</span><span style="color:#91CBFF;">$1</span><span style="color:#ADDCFF;">&quot;</span></span>
<span class="line"><span style="color:#91CBFF;">  shift</span></span>
<span class="line"><span style="color:#FF9492;">done</span></span></code></pre></div><p>上面例子中，<code>shift</code>命令每次移除当前第一个参数，从而通过<code>while</code>循环遍历所有参数。</p><p><code>shift</code>命令可以接受一个整数作为参数，指定所要移除的参数个数，默认为 1。</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>shift 3</span></span></code></pre></div><p>上面的命令移除前三个参数，原来的<code>$4</code>变成<code>$1</code>。</p><h2 id="getopts-命令" tabindex="-1"><a class="header-anchor" href="#getopts-命令"><span>getopts 命令</span></a></h2><p><code>getopts</code>命令用在脚本内部，可以解析复杂的脚本命令行参数，通常与<code>while</code>循环一起使用，取出脚本所有的带有前置连词线（-）的参数。</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#91CBFF;">getopts</span><span style="color:#ADDCFF;"> optstring</span><span style="color:#ADDCFF;"> name</span></span></code></pre></div><p>它带有两个参数。第一个参数<code>optstring</code>是字符串，给出脚本所有的连词线参数。比如，某个脚本可以有三个配置项参数<code>-l、-h、-a</code>，其中只有<code>-a</code>可以带有参数值，而<code>-l</code>和<code>-h</code>是开关参数，那么<code>getopts</code>的第一个参数写成<code>lha:</code>，顺序不重要。注意，<code>a</code>后面有一个冒号，表示该参数带有参数值，getopts规定带有参数值的配置项参数，后面必须带有一个冒号（:）。<code>getopts</code>的第二个参数<code>name</code>是一个变量名，用来保存当前取到的配置项参数，即<code>l、h</code>或<code>a</code>。</p><p>下面是一个例子。</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">while</span><span style="color:#91CBFF;"> getopts</span><span style="color:#ADDCFF;"> &#39;lha:&#39;</span><span style="color:#ADDCFF;"> OPTION</span><span style="color:#F0F3F6;">; </span><span style="color:#FF9492;">do</span></span>
<span class="line"><span style="color:#FF9492;">  case</span><span style="color:#ADDCFF;"> &quot;</span><span style="color:#F0F3F6;">$OPTION</span><span style="color:#ADDCFF;">&quot;</span><span style="color:#FF9492;"> in</span></span>
<span class="line"><span style="color:#ADDCFF;">    l</span><span style="color:#FF9492;">)</span></span>
<span class="line"><span style="color:#91CBFF;">      echo</span><span style="color:#ADDCFF;"> &quot;linuxconfig&quot;</span></span>
<span class="line"><span style="color:#F0F3F6;">      ;;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ADDCFF;">    h</span><span style="color:#FF9492;">)</span></span>
<span class="line"><span style="color:#91CBFF;">      echo</span><span style="color:#ADDCFF;"> &quot;h stands for h&quot;</span></span>
<span class="line"><span style="color:#F0F3F6;">      ;;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ADDCFF;">    a</span><span style="color:#FF9492;">)</span></span>
<span class="line"><span style="color:#F0F3F6;">      avalue</span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;">&quot;</span><span style="color:#F0F3F6;">$OPTARG</span><span style="color:#ADDCFF;">&quot;</span></span>
<span class="line"><span style="color:#91CBFF;">      echo</span><span style="color:#ADDCFF;"> &quot;The value provided is </span><span style="color:#F0F3F6;">$OPTARG</span><span style="color:#ADDCFF;">&quot;</span></span>
<span class="line"><span style="color:#F0F3F6;">      ;;</span></span>
<span class="line"><span style="color:#FF9492;">    ?</span><span style="color:#FF9492;">)</span></span>
<span class="line"><span style="color:#91CBFF;">      echo</span><span style="color:#ADDCFF;"> &quot;script usage: $(</span><span style="color:#FFB757;">basename</span><span style="color:#91CBFF;"> $0</span><span style="color:#ADDCFF;">) [-l] [-h] [-a somevalue]&quot;</span><span style="color:#FF9492;"> &gt;&amp;2</span></span>
<span class="line"><span style="color:#91CBFF;">      exit</span><span style="color:#91CBFF;"> 1</span></span>
<span class="line"><span style="color:#F0F3F6;">      ;;</span></span>
<span class="line"><span style="color:#FF9492;">  esac</span></span>
<span class="line"><span style="color:#FF9492;">done</span></span>
<span class="line"><span style="color:#91CBFF;">shift</span><span style="color:#ADDCFF;"> &quot;$((</span><span style="color:#F0F3F6;">$OPTIND</span><span style="color:#ADDCFF;"> - 1))&quot;</span></span></code></pre></div><p>上面例子中，<code>while</code>循环不断执行<code>getopts &#39;lha:&#39; OPTION</code>命令，每次执行就会读取一个连词线参数（以及对应的参数值），然后进入循环体。变量<code>OPTION</code>保存的是，当前处理的那一个连词线参数（即<code>l、h</code>或<code>a</code>）。如果用户输入了没有指定的参数（比如<code>-x</code>），那么<code>OPTION</code>等于<code>?</code>。循环体内使用<code>case</code>判断，处理这四种不同的情况。</p><p>如果某个连词线参数带有参数值，比如<code>-a foo</code>，那么处理<code>a</code>参数的时候，环境变量<code>$OPTARG</code>保存的就是参数值。</p><p>注意，只要遇到不带连词线的参数，<code>getopts</code>就会执行失败，从而退出<code>while</code>循环。比如，<code>getopts</code>可以解析<code>command -l foo</code>，但不可以解析<code>command foo -l</code>。另外，多个连词线参数写在一起的形式，比如<code>command -lh</code>，<code>getopts</code>也可以正确处理。</p><p>变量<code>$OPTIND</code>在<code>getopts</code>开始执行前是 1，然后每次执行就会加 1。等到退出<code>while</code>循环，就意味着连词线参数全部处理完毕。这时，<code>$OPTIND - 1</code>就是已经处理的连词线参数个数，使用<code>shift</code>命令将这些参数移除，保证后面的代码可以用<code>$1、$2</code>等处理命令的主参数。</p><h2 id="exit-命令" tabindex="-1"><a class="header-anchor" href="#exit-命令"><span>exit 命令</span></a></h2><p><code>exit</code>命令用于终止当前脚本的执行，并向 Shell 返回一个退出值。</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>[root@localhost ~]# exit</span></span></code></pre></div><p>上面命令中止当前脚本，将最后一条命令的退出状态，作为整个脚本的退出状态。</p><p><code>exit</code>命令后面可以跟参数，该参数就是退出状态。</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;"># 退出值为0（成功）</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# exit 0</span></span>
<span class="line"><span style="color:#BDC4CC;"># 退出值为1（失败）</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# exit 1</span></span></code></pre></div><p>退出时，脚本会返回一个退出值。脚本的退出值是一个介于 0~255 之间的整数，一般而言，0 表示正常，1 表示发生错误，2 表示用法不对，126 表示不是可执行脚本，127 表示命令没有发现。如果脚本被信号 N 终止，则退出值为 128 + N。如果不指定，默认状态值是 0。简单来说，只要退出值非 0，就认为执行出错。</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">if</span><span style="color:#F0F3F6;"> [ $(</span><span style="color:#FFB757;">id</span><span style="color:#91CBFF;"> -u</span><span style="color:#F0F3F6;">) </span><span style="color:#FF9492;">!=</span><span style="color:#ADDCFF;"> &quot;0&quot;</span><span style="color:#F0F3F6;"> ]; </span><span style="color:#FF9492;">then</span></span>
<span class="line"><span style="color:#91CBFF;">  echo</span><span style="color:#ADDCFF;"> &quot;根用户才能执行当前脚本&quot;</span></span>
<span class="line"><span style="color:#91CBFF;">  exit</span><span style="color:#91CBFF;"> 1</span></span>
<span class="line"><span style="color:#FF9492;">fi</span></span></code></pre></div><p>上面的例子中，<code>id -u</code>命令返回用户的 ID，一旦用户的 ID 不等于 0（根用户的 ID），脚本就会退出，并且退出码为 1，表示运行失败。</p><p><code>exit</code>与<code>return</code>命令的差别是，<code>return</code>命令是函数的退出，并返回一个值给调用者，脚本依然执行。<code>exit</code>是整个脚本的退出，如果在函数之中调用<code>exit</code>，则退出函数，并终止脚本执行。</p><h2 id="source-命令" tabindex="-1"><a class="header-anchor" href="#source-命令"><span>source 命令</span></a></h2><p><code>source</code>命令用于执行一个脚本，通常用于重新加载一个配置文件。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# source .bashrc</span></span></code></pre></div><p><code>source</code>命令最大的特点是在当前 Shell 执行脚本，不像直接执行脚本时，会新建一个子 Shell。所以，<code>source</code>命令执行脚本时，不需要<code>export</code>变量。</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">#!/bin/bash</span></span>
<span class="line"><span style="color:#BDC4CC;"># test.sh</span></span>
<span class="line"><span style="color:#91CBFF;">echo</span><span style="color:#F0F3F6;"> $foo</span></span></code></pre></div><p>上面脚本输出<code>$foo</code>变量的值。</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;"># 当前 Shell 新建一个变量 foo</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# foo</span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;">1</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;"># 打印输出 1</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# source test.sh</span></span>
<span class="line"><span style="color:#FFB757;">1</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;"># 打印输出空字符串</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# bash test.sh</span></span></code></pre></div><p>上面例子中，当前 Shell 的变量<code>foo</code>并没有<code>export</code>，所以直接执行无法读取，但是<code>source</code>执行可以读取。</p><p><code>source</code>命令的另一个用途，是在脚本内部加载外部库。</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">#!/bin/bash</span></span>
<span class="line"></span>
<span class="line"><span style="color:#91CBFF;">source</span><span style="color:#ADDCFF;"> ./lib.sh</span></span>
<span class="line"><span style="color:#FFB757;">function_from_lib</span></span></code></pre></div><p>上面脚本在内部使用<code>source</code>命令加载了一个外部库，然后就可以在脚本里面，使用这个外部库定义的函数。</p><p><code>source</code>有一个简写形式，可以使用一个点（.）来表示。</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>[root@localhost ~]# . .bashrc</span></span></code></pre></div><h2 id="别名-alias-命令" tabindex="-1"><a class="header-anchor" href="#别名-alias-命令"><span>别名，alias 命令</span></a></h2><p><code>alias</code>命令用来为一个命令指定别名，这样更便于记忆。</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>alias NAME=DEFINITION</span></span></code></pre></div><p>上面命令中，<code>NAME</code>是别名的名称，<code>DEFINITION</code>是别名对应的原始命令。注意，等号两侧不能有空格，否则会报错。</p><p>一个常见的例子是为<code>grep</code>命令起一个<code>search</code>的别名。</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">alias</span><span style="color:#F0F3F6;"> search</span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;">grep</span></span></code></pre></div><p><code>alias</code>也可以用来为长命令指定一个更短的别名。下面是通过别名定义一个<code>today</code>的命令。</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# </span><span style="color:#FF9492;">alias</span><span style="color:#F0F3F6;"> today</span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;">&#39;date +&quot;%A, %B %-d, %Y&quot;&#39;</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# today</span></span>
<span class="line"><span style="color:#FFB757;">星期一,</span><span style="color:#ADDCFF;"> 一月</span><span style="color:#ADDCFF;"> 6,</span><span style="color:#91CBFF;"> 2020</span></span></code></pre></div><p><code>alias</code>定义的别名也可以接受参数，参数会直接传入原始命令。</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# </span><span style="color:#FF9492;">alias</span><span style="color:#F0F3F6;"> echo</span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;">&#39;echo It says: &#39;</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# echo hello world</span></span>
<span class="line"><span style="color:#FFB757;">It</span><span style="color:#ADDCFF;"> says:</span><span style="color:#ADDCFF;"> hello</span><span style="color:#ADDCFF;"> world</span></span></code></pre></div><p>上面例子中，别名定义了<code>echo</code>命令的前两个参数，等同于修改了<code>echo</code>命令的默认行为。</p><p>指定别名以后，就可以像使用其他命令一样使用别名。一般来说，都会把常用的别名写在<code>~/.bashrc</code>的末尾。另外，只能为命令定义别名，为其他部分（比如很长的路径）定义别名是无效的。</p><p>直接调用<code>alias</code>命令，可以显示所有别名。</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# alias</span></span></code></pre></div><p><code>unalias</code>命令可以解除别名。</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# unalias lt</span></span></code></pre></div><h2 id="echo-命令" tabindex="-1"><a class="header-anchor" href="#echo-命令"><span>echo 命令</span></a></h2><p><code>echo</code>命令用于在终端输出字符串或变量。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# echo [字符串 </span><span style="color:#FF9492;">|</span><span style="color:#F0F3F6;"> 变量]</span></span></code></pre></div><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# echo hello world</span></span>
<span class="line"><span style="color:#FFB757;">hello</span><span style="color:#ADDCFF;"> world</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# echo $SHELL</span></span>
<span class="line"><span style="color:#FFB757;">/bin/bash</span></span></code></pre></div><p>如果想要输出的是多行文本，即包括换行符。这时就需要把多行文本放在引号里面。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# echo </span><span style="color:#ADDCFF;">&quot;&lt;HTML&gt;</span></span>
<span class="line"><span style="color:#ADDCFF;">  &lt;HEAD&gt;</span></span>
<span class="line"><span style="color:#ADDCFF;">    &lt;TITLE&gt;Page Title&lt;/TITLE&gt;</span></span>
<span class="line"><span style="color:#ADDCFF;">  &lt;/HEAD&gt;</span></span>
<span class="line"><span style="color:#ADDCFF;">  &lt;BODY&gt;</span></span>
<span class="line"><span style="color:#ADDCFF;">    Page body.</span></span>
<span class="line"><span style="color:#ADDCFF;">  &lt;/BODY&gt;</span></span>
<span class="line"><span style="color:#ADDCFF;">&lt;/HTML&gt;&quot;</span></span></code></pre></div><h4 id="n-参数" tabindex="-1"><a class="header-anchor" href="#n-参数"><span>-n 参数</span></a></h4><p>默认情况下，<code>echo</code>输出的文本末尾会有一个回车符。<code>-n</code>参数可以取消末尾的回车符，使得下一个提示符紧跟在输出内容的后面。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# echo -n hello world</span></span>
<span class="line"><span style="color:#FFB757;">hello</span><span style="color:#ADDCFF;"> world[root@localhost</span><span style="color:#ADDCFF;"> ~]#</span></span></code></pre></div><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# echo a;</span><span style="color:#91CBFF;">echo</span><span style="color:#ADDCFF;"> b</span></span>
<span class="line"><span style="color:#FFB757;">a</span></span>
<span class="line"><span style="color:#FFB757;">b</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# echo -n a;</span><span style="color:#91CBFF;">echo</span><span style="color:#ADDCFF;"> b</span></span>
<span class="line"><span style="color:#FFB757;">ab</span></span></code></pre></div><h4 id="e-参数" tabindex="-1"><a class="header-anchor" href="#e-参数"><span>-e 参数</span></a></h4><p><code>-e</code>参数会解释引号（双引号和单引号）里面的特殊字符（比如换行符<code>\\n</code>）。如果不使用<code>-e</code>参数，即默认情况下，引号会让特殊字符变成普通字符，<code>echo</code>不解释它们，原样输出。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# echo </span><span style="color:#ADDCFF;">&quot;Hello\\nWorld&quot;</span></span>
<span class="line"><span style="color:#FFB757;">Hello\\nWorld</span></span>
<span class="line"><span style="color:#BDC4CC;"># 双引号的情况</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# echo -e </span><span style="color:#ADDCFF;">&quot;Hello\\nWorld&quot;</span></span>
<span class="line"><span style="color:#FFB757;">Hello</span></span>
<span class="line"><span style="color:#FFB757;">World</span></span>
<span class="line"><span style="color:#BDC4CC;"># 单引号的情况</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# echo -e </span><span style="color:#ADDCFF;">&#39;Hello\\nWorld&#39;</span></span>
<span class="line"><span style="color:#FFB757;">Hello</span></span>
<span class="line"><span style="color:#FFB757;">World</span></span></code></pre></div><p>上面代码中，<code>-e</code>参数使得<code>\\n</code>解释为换行符，导致输出内容里面出现换行。</p><h2 id="here-文档" tabindex="-1"><a class="header-anchor" href="#here-文档"><span>Here 文档</span></a></h2><p>Here 文档是一种输入多行字符串的方法，格式如下。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">&lt;&lt;</span><span style="color:#F0F3F6;"> token</span></span>
<span class="line"><span style="color:#ADDCFF;">text</span></span>
<span class="line"><span style="color:#F0F3F6;">token</span></span></code></pre></div><p>它的格式分成开始标记（<code>&lt;&lt; token</code>）和结束标记（<code>token</code>）。开始标记是两个小于号<code>+ Here</code>文档的名称，名称可以随意取，后面必须是一个换行符；结束标记是单独一行顶格写的 Here 文档名称，如果不是顶格，结束标记不起作用。两者之间就是多行字符串的内容。</p><p>下面是一个通过 Here 文档输出 HTML 代码的例子。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# cat </span><span style="color:#FF9492;">&lt;&lt;</span><span style="color:#F0F3F6;"> _EOF_</span></span>
<span class="line"><span style="color:#ADDCFF;">&lt;html&gt;</span></span>
<span class="line"><span style="color:#ADDCFF;">&lt;head&gt;</span></span>
<span class="line"><span style="color:#ADDCFF;">    &lt;title&gt;</span></span>
<span class="line"><span style="color:#ADDCFF;">    The title of your page</span></span>
<span class="line"><span style="color:#ADDCFF;">    &lt;/title&gt;</span></span>
<span class="line"><span style="color:#ADDCFF;">&lt;/head&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ADDCFF;">&lt;body&gt;</span></span>
<span class="line"><span style="color:#ADDCFF;">    Your page content goes here.</span></span>
<span class="line"><span style="color:#ADDCFF;">&lt;/body&gt;</span></span>
<span class="line"><span style="color:#ADDCFF;">&lt;/html&gt;</span></span>
<span class="line"><span style="color:#F0F3F6;">_EOF_</span></span></code></pre></div><p>Here 文档内部会发生变量替换，同时支持反斜杠转义，但是不支持通配符扩展，双引号和单引号也失去语法作用，变成了普通字符。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# foo</span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;">&#39;hello world&#39;</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# cat </span><span style="color:#FF9492;">&lt;&lt;</span><span style="color:#F0F3F6;"> _example_</span></span>
<span class="line"><span style="color:#F0F3F6;">$foo</span></span>
<span class="line"><span style="color:#ADDCFF;">&quot;</span><span style="color:#F0F3F6;">$foo</span><span style="color:#ADDCFF;">&quot;</span></span>
<span class="line"><span style="color:#ADDCFF;">&#39;</span><span style="color:#F0F3F6;">$foo</span><span style="color:#ADDCFF;">&#39;</span></span>
<span class="line"><span style="color:#F0F3F6;">_example_</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FFB757;">hello</span><span style="color:#ADDCFF;"> world</span></span>
<span class="line"><span style="color:#FFB757;">&quot;hello world&quot;</span></span>
<span class="line"><span style="color:#FFB757;">&#39;hello world&#39;</span></span></code></pre></div><p>上面例子中，变量<code>$foo</code>发生了替换，但是双引号和单引号都原样输出了，表明它们已经失去了引用的功能。</p><p>如果不希望发生变量替换，可以把 Here 文档的开始标记放在单引号之中。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# foo</span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;">&#39;hello world&#39;</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# cat </span><span style="color:#FF9492;">&lt;&lt;</span><span style="color:#F0F3F6;"> &#39;_example_&#39;</span></span>
<span class="line"><span style="color:#ADDCFF;">$foo</span></span>
<span class="line"><span style="color:#ADDCFF;">&quot;$foo&quot;</span></span>
<span class="line"><span style="color:#ADDCFF;">&#39;$foo&#39;</span></span>
<span class="line"><span style="color:#F0F3F6;">_example_</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">$foo</span></span>
<span class="line"><span style="color:#FFB757;">&quot;</span><span style="color:#F0F3F6;">$foo</span><span style="color:#FFB757;">&quot;</span></span>
<span class="line"><span style="color:#FFB757;">&#39;$foo&#39;</span></span></code></pre></div><p>上面例子中，Here 文档的开始标记（<code>_example_</code>）放在单引号之中，导致变量替换失效了。</p><p>Here 文档的本质是重定向，它将字符串重定向输出给某个命令，相当于包含了<code>echo</code>命令。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# command </span><span style="color:#FF9492;">&lt;&lt;</span><span style="color:#F0F3F6;"> token</span></span>
<span class="line"><span style="color:#ADDCFF;">  string</span></span>
<span class="line"><span style="color:#F0F3F6;">token</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;"># 等同于</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# echo string </span><span style="color:#FF9492;">|</span><span style="color:#91CBFF;"> command</span></span></code></pre></div><p>上面代码中，Here 文档相当于<code>echo</code>命令的重定向。</p><p>所以，Here 字符串只适合那些可以接受标准输入作为参数的命令，对于其他命令无效，比如<code>echo</code>命令就不能用 Here 文档作为参数。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# echo </span><span style="color:#FF9492;">&lt;&lt;</span><span style="color:#F0F3F6;"> _example_</span></span>
<span class="line"><span style="color:#ADDCFF;">hello</span></span>
<span class="line"><span style="color:#F0F3F6;">_example_</span></span></code></pre></div><p>上面例子不会有任何输出，因为 Here 文档对于<code>echo</code>命令无效。</p><p>此外，Here 文档也不能作为变量的值，只能用于命令的参数。</p><h2 id="here-字符串" tabindex="-1"><a class="header-anchor" href="#here-字符串"><span>Here 字符串</span></a></h2><p>Here 文档还有一个变体，叫做 Here 字符串，使用三个小于号（<code>&lt;&lt;&lt;</code>）表示。</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>&lt;&lt;&lt; string</span></span></code></pre></div><p>它的作用是将字符串通过标准输入，传递给命令。</p><p>有些命令直接接受给定的参数，与通过标准输入接受参数，结果是不一样的。所以才有了这个语法，使得将字符串通过标准输入传递给命令更方便，比如cat命令只接受标准输入传入的字符串。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# cat </span><span style="color:#FF9492;">&lt;&lt;&lt;</span><span style="color:#ADDCFF;"> &#39;hi there&#39;</span></span>
<span class="line"><span style="color:#BDC4CC;"># 等同于</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# echo </span><span style="color:#ADDCFF;">&#39;hi there&#39;</span><span style="color:#FF9492;"> |</span><span style="color:#FFB757;"> cat</span></span></code></pre></div><p>上面的第一种语法使用了 Here 字符串，要比第二种语法看上去语义更好，也更简洁。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# md5sum </span><span style="color:#FF9492;">&lt;&lt;&lt;</span><span style="color:#ADDCFF;"> &#39;ddd&#39;</span></span>
<span class="line"><span style="color:#BDC4CC;"># 等同于</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# echo </span><span style="color:#ADDCFF;">&#39;ddd&#39;</span><span style="color:#FF9492;"> |</span><span style="color:#FFB757;"> md5sum</span></span></code></pre></div><p>上面例子中，<code>md5sum</code>命令只能接受标准输入作为参数，不能直接将字符串放在命令后面，会被当作文件名，即<code>md5sum ddd</code>里面的<code>ddd</code>会被解释成文件名。这时就可以用 Here 字符串，将字符串传给<code>md5sum</code>命令。</p><h2 id="set-命令" tabindex="-1"><a class="header-anchor" href="#set-命令"><span>set 命令</span></a></h2><p>Bash 执行脚本时，会创建一个子 Shell。</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FFB757;">$</span><span style="color:#ADDCFF;"> bash</span><span style="color:#ADDCFF;"> script.sh</span></span></code></pre></div><p>上面代码中，<code>script.sh</code>是在一个子 Shell 里面执行。这个子 Shell 就是脚本的执行环境，Bash 默认给定了这个环境的各种参数。</p><p><code>set</code>命令用来修改子 Shell 环境的运行参数，即定制环境。</p><p>如果命令行下不带任何参数，直接运行<code>set</code>，会显示所有的环境变量和 Shell 函数。</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# set</span></span>
<span class="line"><span style="color:#F0F3F6;">BASH</span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;">/bin/bash</span></span>
<span class="line"><span style="color:#F0F3F6;">BASHOPTS</span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;">checkwinsize:cmdhist:complete_fullquote:expand_aliases:extquote:force_fignore:globasciiranges:histappend:hostcomplete:interactive_comments:login_shell:progcomp:promptvars:sourcepath</span></span>
<span class="line"><span style="color:#F0F3F6;">BASHRCSOURCED</span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;">Y</span></span>
<span class="line"><span style="color:#F0F3F6;">BASH_ALIASES</span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;">()</span></span>
<span class="line"><span style="color:#F0F3F6;">BASH_ARGC</span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;">([</span><span style="color:#91CBFF;">0</span><span style="color:#F0F3F6;">]=</span><span style="color:#ADDCFF;">&quot;0&quot;</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#F0F3F6;">BASH_ARGV</span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;">()</span></span>
<span class="line"><span style="color:#91CBFF;">......</span></span></code></pre></div><h3 id="set-u" tabindex="-1"><a class="header-anchor" href="#set-u"><span>set -u</span></a></h3><p>执行脚本时，如果遇到不存在的变量，Bash 默认忽略它。</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">#!/usr/bin/env bash</span></span>
<span class="line"></span>
<span class="line"><span style="color:#91CBFF;">echo</span><span style="color:#F0F3F6;"> $a</span></span>
<span class="line"><span style="color:#91CBFF;">echo</span><span style="color:#ADDCFF;"> bar</span></span></code></pre></div><p>上面代码中，<code>$a</code>是一个不存在的变量。</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# ./test.sh </span></span>
<span class="line"></span>
<span class="line"><span style="color:#FFB757;">bar</span></span></code></pre></div><p>可以看到，<code>echo $a</code>输出了一个空行，Bash 忽略了不存在的<code>$a</code>，然后继续执行<code>echo bar</code>。大多数情况下，这不是开发者想要的行为，遇到变量不存在，脚本应该报错，而不是一声不响地往下执行。</p><p><code>set -u</code>就用来改变这种行为。脚本在头部加上它，遇到不存在的变量就会报错，并停止执行。</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">#!/usr/bin/env bash</span></span>
<span class="line"><span style="color:#91CBFF;">set</span><span style="color:#91CBFF;"> -u</span></span>
<span class="line"></span>
<span class="line"><span style="color:#91CBFF;">echo</span><span style="color:#F0F3F6;"> $a</span></span>
<span class="line"><span style="color:#91CBFF;">echo</span><span style="color:#ADDCFF;"> bar</span></span></code></pre></div><p>运行结果如下。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# ./test.sh </span></span>
<span class="line"><span style="color:#FFB757;">./test.sh:行5:</span><span style="color:#ADDCFF;"> a：未绑定的变量</span></span></code></pre></div><p>可以看到，脚本报错了，并且不再执行后面的语句。</p><p><code>-u</code>还有另一种写法<code>-o nounset</code>，两者是等价的。</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>set -o nounset</span></span></code></pre></div><h3 id="set-x" tabindex="-1"><a class="header-anchor" href="#set-x"><span>set -x</span></a></h3><p>默认情况下，脚本执行后，只输出运行结果，没有其他内容。如果多个命令连续执行，它们的运行结果就会连续输出。有时会分不清，某一段内容是什么命令产生的。</p><p><code>set -x</code>用来在运行结果之前，先输出执行的那一行命令。</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">#!/usr/bin/env bash</span></span>
<span class="line"><span style="color:#91CBFF;">set</span><span style="color:#91CBFF;"> -x</span></span>
<span class="line"></span>
<span class="line"><span style="color:#91CBFF;">echo</span><span style="color:#ADDCFF;"> bar</span></span></code></pre></div><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# ./test.sh</span></span>
<span class="line"><span style="color:#FFB757;">+</span><span style="color:#ADDCFF;"> echo</span><span style="color:#ADDCFF;"> bar</span></span>
<span class="line"><span style="color:#FFB757;">bar</span></span></code></pre></div><p>可以看到，执行<code>echo bar</code>之前，该命令会先打印出来，行首以+表示。这对于调试复杂的脚本是很有用的。</p><p><code>-x</code>还有另一种写法<code>-o xtrace</code>。</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>set -o xtrace</span></span></code></pre></div><p>脚本当中如果要关闭命令输出，可以使用<code>set +x</code>。</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">#!/bin/bash</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">number</span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;">1</span></span>
<span class="line"></span>
<span class="line"><span style="color:#91CBFF;">set</span><span style="color:#91CBFF;"> -x</span></span>
<span class="line"><span style="color:#FF9492;">if</span><span style="color:#F0F3F6;"> [ $number </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &quot;1&quot;</span><span style="color:#F0F3F6;"> ]; </span><span style="color:#FF9492;">then</span></span>
<span class="line"><span style="color:#91CBFF;">  echo</span><span style="color:#ADDCFF;"> &quot;Number equals 1&quot;</span></span>
<span class="line"><span style="color:#FF9492;">else</span></span>
<span class="line"><span style="color:#91CBFF;">  echo</span><span style="color:#ADDCFF;"> &quot;Number does not equal 1&quot;</span></span>
<span class="line"><span style="color:#FF9492;">fi</span></span>
<span class="line"><span style="color:#91CBFF;">set</span><span style="color:#ADDCFF;"> +x</span></span></code></pre></div><p>上面的例子中，只对特定的代码段打开命令输出。</p><h3 id="bash-的错误处理" tabindex="-1"><a class="header-anchor" href="#bash-的错误处理"><span>Bash 的错误处理</span></a></h3><p>如果脚本里面有运行失败的命令（返回值非 0），Bash 默认会继续执行后面的命令。</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">#!/usr/bin/env bash</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FFB757;">foo</span></span>
<span class="line"><span style="color:#91CBFF;">echo</span><span style="color:#ADDCFF;"> bar</span></span></code></pre></div><p>上面脚本中，<code>foo</code>是一个不存在的命令，执行时会报错。但是，Bash 会忽略这个错误，继续往下执行。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# ./test.sh </span></span>
<span class="line"><span style="color:#FFB757;">./test.sh:行4:</span><span style="color:#ADDCFF;"> foo：未找到命令</span></span>
<span class="line"><span style="color:#FFB757;">bar</span></span></code></pre></div><p>这种行为很不利于脚本安全和除错。实际开发中，如果某个命令失败，往往需要脚本停止执行，防止错误累积。这时，一般采用下面的写法。</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#91CBFF;">command</span><span style="color:#FF9492;"> ||</span><span style="color:#91CBFF;"> exit</span><span style="color:#91CBFF;"> 1</span></span></code></pre></div><p>上面的写法表示只要<code>command</code>有非零返回值，脚本就会停止执行。</p><p>如果停止执行之前需要完成多个操作，就要采用下面三种写法。</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span># 写法一</span></span>
<span class="line"><span>command || { echo &quot;command failed&quot;; exit 1; }</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 写法二</span></span>
<span class="line"><span>if ! command; then echo &quot;command failed&quot;; exit 1; fi</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 写法三</span></span>
<span class="line"><span>command</span></span>
<span class="line"><span>if [ &quot;$?&quot; -ne 0 ]; then echo &quot;command failed&quot;; exit 1; fi</span></span></code></pre></div><p>另外，除了停止执行，还有一种情况。如果两个命令有继承关系，只有第一个命令成功了，才能继续执行第二个命令，那么就要采用下面的写法。</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FFB757;">command1</span><span style="color:#F0F3F6;"> &amp;&amp; </span><span style="color:#FFB757;">command2</span></span>
<span class="line"><span style="color:#91CBFF;">set</span><span style="color:#91CBFF;"> -e</span></span></code></pre></div><p>上面这些写法多少有些麻烦，容易疏忽。<code>set -e</code>从根本上解决了这个问题，它使得脚本只要发生错误，就终止执行。</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">#!/usr/bin/env bash</span></span>
<span class="line"><span style="color:#91CBFF;">set</span><span style="color:#91CBFF;"> -e</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FFB757;">foo</span></span>
<span class="line"><span style="color:#91CBFF;">echo</span><span style="color:#ADDCFF;"> bar</span></span></code></pre></div><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# ./test.sh </span></span>
<span class="line"><span style="color:#FFB757;">./test.sh:行4:</span><span style="color:#ADDCFF;"> foo：未找到命令</span></span></code></pre></div><p><code>set -e</code>根据返回值来判断，一个命令是否运行失败。但是，某些命令的非零返回值可能不表示失败，或者开发者希望在命令失败的情况下，脚本继续执行下去。这时可以暂时关闭<code>set -e</code>，该命令执行结束后，再重新打开<code>set -e</code>。</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>set +e</span></span>
<span class="line"><span>command1</span></span>
<span class="line"><span>command2</span></span>
<span class="line"><span>set -e</span></span></code></pre></div><p>上面代码中，<code>set +e</code>表示关闭<code>-e</code>选项，<code>set -e</code>表示重新打开<code>-e</code>选项。</p><p>还有一种方法是使用<code>command || true</code>，使得该命令即使执行失败，脚本也不会终止执行。</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">#!/bin/bash</span></span>
<span class="line"><span style="color:#91CBFF;">set</span><span style="color:#91CBFF;"> -e</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FFB757;">foo</span><span style="color:#FF9492;"> ||</span><span style="color:#91CBFF;"> true</span></span>
<span class="line"><span style="color:#91CBFF;">echo</span><span style="color:#ADDCFF;"> bar</span></span></code></pre></div><p>上面代码中，<code>true</code>使得这一行语句总是会执行成功，后面的<code>echo bar</code>会执行。</p><p><code>-e</code>还有另一种写法<code>-o errexit</code>。</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>set -o errexit</span></span></code></pre></div><h3 id="set-o-pipefail" tabindex="-1"><a class="header-anchor" href="#set-o-pipefail"><span>set -o pipefail</span></a></h3><p><code>set -e</code>有一个例外情况，就是不适用于管道命令。</p><p>所谓管道命令，就是多个子命令通过管道运算符（|）组合成为一个大的命令。Bash 会把最后一个子命令的返回值，作为整个命令的返回值。也就是说，只要最后一个子命令不失败，管道命令总是会执行成功，因此它后面命令依然会执行，<code>set -e</code>就失效了。</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">#!/usr/bin/env bash</span></span>
<span class="line"><span style="color:#91CBFF;">set</span><span style="color:#91CBFF;"> -e</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FFB757;">foo</span><span style="color:#FF9492;"> |</span><span style="color:#91CBFF;"> echo</span><span style="color:#ADDCFF;"> a</span></span>
<span class="line"><span style="color:#91CBFF;">echo</span><span style="color:#ADDCFF;"> bar</span></span></code></pre></div><p>执行结果如下。</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>$ bash script.sh</span></span>
<span class="line"><span>a</span></span>
<span class="line"><span>script.sh:行4: foo: 未找到命令</span></span>
<span class="line"><span>bar</span></span></code></pre></div><p>上面代码中，<code>foo</code>是一个不存在的命令，但是<code>foo | echo a</code>这个管道命令会执行成功，导致后面的<code>echo bar</code>会继续执行。</p><p><code>set -o pipefail</code>用来解决这种情况，只要一个子命令失败，整个管道命令就失败，脚本就会终止执行。</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">#!/usr/bin/env bash</span></span>
<span class="line"><span style="color:#91CBFF;">set</span><span style="color:#91CBFF;"> -eo</span><span style="color:#ADDCFF;"> pipefail</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FFB757;">foo</span><span style="color:#FF9492;"> |</span><span style="color:#91CBFF;"> echo</span><span style="color:#ADDCFF;"> a</span></span>
<span class="line"><span style="color:#91CBFF;">echo</span><span style="color:#ADDCFF;"> bar</span></span></code></pre></div><p>运行后，结果如下。</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>$ bash script.sh</span></span>
<span class="line"><span>a</span></span>
<span class="line"><span>script.sh:行4: foo: 未找到命令</span></span></code></pre></div><p>可以看到，<code>echo bar</code>没有执行。</p><h3 id="set-e" tabindex="-1"><a class="header-anchor" href="#set-e"><span>set -E</span></a></h3><p>一旦设置了<code>-e</code>参数，会导致函数内的错误不会被<code>trap</code>命令捕获。-E参数可以纠正这个行为，使得函数也能继承<code>trap</code>命令。</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>#!/bin/bash</span></span>
<span class="line"><span>set -e</span></span>
<span class="line"><span></span></span>
<span class="line"><span>trap &quot;echo ERR trap fired!&quot; ERR</span></span>
<span class="line"><span></span></span>
<span class="line"><span>myfunc()</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>  # &#39;foo&#39; 是一个不存在的命令</span></span>
<span class="line"><span>  foo</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>myfunc</span></span></code></pre></div><p>上面示例中，<code>myfunc</code>函数内部调用了一个不存在的命令<code>foo</code>，导致执行这个函数会报错。</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>$ bash test.sh</span></span>
<span class="line"><span>test.sh:行9: foo：未找到命令</span></span></code></pre></div><p>但是，由于设置了<code>set -e</code>，函数内部的报错并没有被<code>trap</code>命令捕获，需要加上<code>-E</code>参数才可以。</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>#!/bin/bash</span></span>
<span class="line"><span>set -Eeuo pipefail</span></span>
<span class="line"><span></span></span>
<span class="line"><span>trap &quot;echo ERR trap fired!&quot; ERR</span></span>
<span class="line"><span></span></span>
<span class="line"><span>myfunc()</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>  # &#39;foo&#39; 是一个不存在的命令</span></span>
<span class="line"><span>  foo</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>myfunc</span></span></code></pre></div><p>执行上面这个脚本，就可以看到<code>trap</code>命令生效了。</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>$ bash test.sh</span></span>
<span class="line"><span>test.sh:行9: foo：未找到命令</span></span>
<span class="line"><span>ERR trap fired!</span></span></code></pre></div><h3 id="其他参数" tabindex="-1"><a class="header-anchor" href="#其他参数"><span>其他参数</span></a></h3><p><code>set</code>命令还有一些其他参数。</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>set -n <br> set -o noexec</td><td>不运行命令，只检查语法是否正确</td></tr><tr><td>set -f <br> set -o noglob</td><td>表示不对通配符进行文件名扩展</td></tr><tr><td>set -v <br> set -o verbose</td><td>表示打印 Shell 接收到的每一行输入</td></tr><tr><td>set -o noclobber</td><td>防止使用重定向运算符&gt;覆盖已经存在的文件</td></tr></tbody></table><p>上面的<code>-f</code>和<code>-v</code>参数，可以分别使用<code>set +f、set +v</code>关闭。</p><h3 id="set-命令总结" tabindex="-1"><a class="header-anchor" href="#set-命令总结"><span>set 命令总结</span></a></h3><p>上面重点介绍的set命令的几个参数，一般都放在一起使用。</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span># 写法一</span></span>
<span class="line"><span>set -Eeuxo pipefail</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 写法二</span></span>
<span class="line"><span>set -Eeux</span></span>
<span class="line"><span>set -o pipefail</span></span></code></pre></div><p>这两种写法建议放在所有 Bash 脚本的头部。</p><p>另一种办法是在执行 Bash 脚本的时候，从命令行传入这些参数。</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>$ bash -euxo pipefail script.sh</span></span></code></pre></div><h2 id="shopt-命令" tabindex="-1"><a class="header-anchor" href="#shopt-命令"><span>shopt 命令</span></a></h2><p><code>shopt</code>命令用来调整 Shell 的参数，跟<code>set</code>命令的作用很类似。之所以会有这两个类似命令的主要原因是，<code>set</code>是从 Ksh 继承的，属于 POSIX 规范的一部分，而<code>shopt</code>是 Bash 特有的。</p><p>直接输入<code>shopt</code>可以查看所有参数，以及它们各自打开和关闭的状态。</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>$ shopt</span></span></code></pre></div><p><code>shopt</code>命令后面跟着参数名，可以查询该参数是否打开。</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>$ shopt globstar</span></span>
<span class="line"><span>globstar  off</span></span></code></pre></div><p>上面例子表示<code>globstar</code>参数默认是关闭的。</p><ol><li><code>-s</code><br><code>-s</code>用来打开某个参数。</li></ol><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>$ shopt -s optionNameHere</span></span></code></pre></div><ol start="2"><li><code>-u</code><br><code>-u</code>用来关闭某个参数。</li></ol><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>$ shopt -u optionNameHere</span></span></code></pre></div><p>举例来说，<code>histappend</code>这个参数表示退出当前 Shell 时，将操作历史追加到历史文件中。这个参数默认是打开的，如果使用下面的命令将其关闭，那么当前 Shell 的操作历史将替换掉整个历史文件。</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>$ shopt -u histappend</span></span></code></pre></div><ol start="3"><li><code>-q</code><br><code>-q</code>的作用也是查询某个参数是否打开，但不是直接输出查询结果，而是通过命令的执行状态（<code>$?</code>）表示查询结果。如果状态为 0，表示该参数打开；如果为 1，表示该参数关闭。</li></ol><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>$ shopt -q globstar</span></span>
<span class="line"><span>$ echo $?</span></span>
<span class="line"><span>1</span></span></code></pre></div><p>上面命令查询<code>globstar</code>参数是否打开。返回状态为 1，表示该参数是关闭的。</p><p>这个用法主要用于脚本，供<code>if</code>条件结构使用。下面例子是如果打开了这个参数，就执行<code>if</code>结构内部的语句。</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>if (shopt -q globstar); then</span></span>
<span class="line"><span>  ...</span></span>
<span class="line"><span>fi</span></span></code></pre></div>`,202)]))}const r=a(o,[["render",p],["__file","Bash脚本—常用命令.html.vue"]]),d=JSON.parse('{"path":"/linux/linux%E5%9F%BA%E7%A1%80/Bash%E8%84%9A%E6%9C%AC%E2%80%94%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html","title":"Bash脚本——常用命令","lang":"zh-CN","frontmatter":{"title":"Bash脚本——常用命令","date":"2024-06-10T00:00:00.000Z","tags":"Bash","categories":"Linux","order":26,"description":"shift 命令 shift命令可以改变脚本参数，每次执行都会移除脚本当前的第一个参数（$1），使得后面的参数向前一位，即$2变成$1、$3变成$2、$4变成$3，以此类推。 while循环结合shift命令，也可以读取每一个参数。 上面例子中，shift命令每次移除当前第一个参数，从而通过while循环遍历所有参数。 shift命令可以接受一个整数作...","head":[["meta",{"property":"og:url","content":"https://0oWSQo0.github.io/wsq-blog/linux/linux%E5%9F%BA%E7%A1%80/Bash%E8%84%9A%E6%9C%AC%E2%80%94%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html"}],["meta",{"property":"og:title","content":"Bash脚本——常用命令"}],["meta",{"property":"og:description","content":"shift 命令 shift命令可以改变脚本参数，每次执行都会移除脚本当前的第一个参数（$1），使得后面的参数向前一位，即$2变成$1、$3变成$2、$4变成$3，以此类推。 while循环结合shift命令，也可以读取每一个参数。 上面例子中，shift命令每次移除当前第一个参数，从而通过while循环遍历所有参数。 shift命令可以接受一个整数作..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-04-23T09:49:11.000Z"}],["meta",{"property":"article:published_time","content":"2024-06-10T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-04-23T09:49:11.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Bash脚本——常用命令\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-06-10T00:00:00.000Z\\",\\"dateModified\\":\\"2025-04-23T09:49:11.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"WSQ\\",\\"url\\":\\"https://0oWSQo0.github.com\\"}]}"]]},"headers":[{"level":2,"title":"shift 命令","slug":"shift-命令","link":"#shift-命令","children":[]},{"level":2,"title":"getopts 命令","slug":"getopts-命令","link":"#getopts-命令","children":[]},{"level":2,"title":"exit 命令","slug":"exit-命令","link":"#exit-命令","children":[]},{"level":2,"title":"source 命令","slug":"source-命令","link":"#source-命令","children":[]},{"level":2,"title":"别名，alias 命令","slug":"别名-alias-命令","link":"#别名-alias-命令","children":[]},{"level":2,"title":"echo 命令","slug":"echo-命令","link":"#echo-命令","children":[]},{"level":2,"title":"Here 文档","slug":"here-文档","link":"#here-文档","children":[]},{"level":2,"title":"Here 字符串","slug":"here-字符串","link":"#here-字符串","children":[]},{"level":2,"title":"set 命令","slug":"set-命令","link":"#set-命令","children":[{"level":3,"title":"set -u","slug":"set-u","link":"#set-u","children":[]},{"level":3,"title":"set -x","slug":"set-x","link":"#set-x","children":[]},{"level":3,"title":"Bash 的错误处理","slug":"bash-的错误处理","link":"#bash-的错误处理","children":[]},{"level":3,"title":"set -o pipefail","slug":"set-o-pipefail","link":"#set-o-pipefail","children":[]},{"level":3,"title":"set -E","slug":"set-e","link":"#set-e","children":[]},{"level":3,"title":"其他参数","slug":"其他参数","link":"#其他参数","children":[]},{"level":3,"title":"set 命令总结","slug":"set-命令总结","link":"#set-命令总结","children":[]}]},{"level":2,"title":"shopt 命令","slug":"shopt-命令","link":"#shopt-命令","children":[]}],"git":{"createdTime":1726034220000,"updatedTime":1745401751000,"contributors":[{"name":"WSQ","email":"592786982@qq.com","commits":3}]},"readingTime":{"minutes":16.76,"words":5027},"filePathRelative":"linux/linux基础/Bash脚本—常用命令.md","localizedDate":"2024年6月10日","autoDesc":true}');export{r as comp,d as data};
