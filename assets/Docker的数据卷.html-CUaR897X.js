import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as o,d as n,o as l}from"./app-BAoNGAQX.js";const e={};function p(t,s){return l(),o("div",null,s[0]||(s[0]=[n(`<h2 id="数据卷" tabindex="-1"><a class="header-anchor" href="#数据卷"><span>数据卷</span></a></h2><p>数据卷的使用，类似于 Linux 下对目录或文件进行<code>mount</code>，镜像中的被指定为挂载点的目录中的文件会复制到数据卷中（仅数据卷为空时会复制）。</p><p>数据卷(<code>Data Volume</code>)是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：</p><ul><li>数据卷可以在容器之间共享和重用</li><li>对数据卷的修改会立马生效</li><li>对数据卷的更新，不会影响镜像</li><li>卷会一直存在，直到没有容器使用</li></ul><h3 id="创建一个数据卷" tabindex="-1"><a class="header-anchor" href="#创建一个数据卷"><span>创建一个数据卷</span></a></h3><p>在用<code>docker run</code>命令的时候，使用<code>-v</code>标记来创建一个数据卷并挂载到容器里。在一次<code>run</code>中多次使用可以挂载多个数据卷。</p><p>下面创建一个 web 容器，并加载一个数据卷到容器的<code>/webapp-data</code>目录。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# docker run -d -P --name web -v /webapp-data training/webapp python app.py</span></span>
<span class="line"><span style="color:#FFB757;">e331e83e59486a131919cba8698b24eaee051a947838bb1c15c03df8b3464b97</span></span></code></pre></div><p>上面的操作会在宿主机<code>/var/lib/docker/volumes</code>下创建一个数据卷目录与容器内的<code>/webapp-data</code>进行映射。</p><p>我们看下容器内部是否生成<code>/webapp-data</code>目录</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# docker exec -it web /bin/bash</span></span>
<span class="line"><span style="color:#FFB757;">root@e331e83e5948:/opt/webapp#</span><span style="color:#ADDCFF;"> cd</span><span style="color:#ADDCFF;"> /webapp-data</span></span>
<span class="line"><span style="color:#FFB757;">root@e331e83e5948:/webapp-data#</span><span style="color:#ADDCFF;"> ll</span></span>
<span class="line"><span style="color:#FFB757;">total</span><span style="color:#91CBFF;"> 8</span></span>
<span class="line"><span style="color:#FFB757;">drwxr-xr-x</span><span style="color:#91CBFF;"> 2</span><span style="color:#ADDCFF;"> root</span><span style="color:#ADDCFF;"> root</span><span style="color:#91CBFF;"> 4096</span><span style="color:#ADDCFF;"> Feb</span><span style="color:#91CBFF;"> 20</span><span style="color:#ADDCFF;"> 01:24</span><span style="color:#ADDCFF;"> ./</span></span>
<span class="line"><span style="color:#FFB757;">drwxr-xr-x</span><span style="color:#91CBFF;"> 1</span><span style="color:#ADDCFF;"> root</span><span style="color:#ADDCFF;"> root</span><span style="color:#91CBFF;"> 4096</span><span style="color:#ADDCFF;"> Feb</span><span style="color:#91CBFF;"> 20</span><span style="color:#ADDCFF;"> 01:24</span><span style="color:#ADDCFF;"> ../</span></span>
<span class="line"><span style="color:#FFB757;">root@e331e83e5948:/webapp-data#</span></span></code></pre></div><p>也可以在<code>Dockerfile</code>中使用<code>VOLUME</code>来添加一个或者多个新的卷到由该镜像创建的任意容器。</p><h3 id="挂载一个主机目录作为数据卷" tabindex="-1"><a class="header-anchor" href="#挂载一个主机目录作为数据卷"><span>挂载一个主机目录作为数据卷</span></a></h3><p>可以在创建容器的时候，将宿主机的目录与容器内的目录进行映射，这样我们就可以通过修改宿主机某个目录的文件从而去影响容器。</p><p>创建容器时使用<code>-v</code>也可以指定挂载一个本地主机的目录到容器中去，后边为宿主机目录:容器目录，例如：<code>docker run -di -v /usr/local/test:/usr/local/test --name=mycentos3 centos:7</code>。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# docker rm -f web</span></span>
<span class="line"><span style="color:#FFB757;">web</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost opt]# docker run -d --name web -v /opt/webapp-data5:/opt/webapp2 training/webapp</span></span>
<span class="line"><span style="color:#FFB757;">fce27f6ea9ce9699864644a48aed6db8b772c96be36f46bee6154d2e2c9915b9</span></span></code></pre></div><p>我们验证下：</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost opt]# docker exec -it web /bin/bash</span></span>
<span class="line"><span style="color:#FFB757;">root@fce27f6ea9ce:/opt/webapp#</span><span style="color:#ADDCFF;"> cd</span><span style="color:#ADDCFF;"> ..</span></span>
<span class="line"><span style="color:#FFB757;">root@fce27f6ea9ce:/opt#</span><span style="color:#ADDCFF;"> ls</span></span>
<span class="line"><span style="color:#FFB757;">webapp</span><span style="color:#ADDCFF;">  webapp2</span></span>
<span class="line"><span style="color:#FFB757;">root@fce27f6ea9ce:/opt#</span><span style="color:#ADDCFF;"> cd</span><span style="color:#ADDCFF;"> webapp2</span></span>
<span class="line"><span style="color:#FFB757;">root@fce27f6ea9ce:/opt/webapp2#</span><span style="color:#ADDCFF;"> mkdir</span><span style="color:#ADDCFF;"> test</span></span>
<span class="line"><span style="color:#FFB757;">root@fce27f6ea9ce:/opt/webapp2#</span><span style="color:#ADDCFF;"> exit</span></span>
<span class="line"><span style="color:#91CBFF;">exit</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost opt]# cd webapp-data5</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost webapp-data5]# ll</span></span>
<span class="line"><span style="color:#FFB757;">total</span><span style="color:#91CBFF;"> 4</span></span>
<span class="line"><span style="color:#FFB757;">drwxr-xr-x</span><span style="color:#91CBFF;"> 2</span><span style="color:#ADDCFF;"> root</span><span style="color:#ADDCFF;"> root</span><span style="color:#91CBFF;"> 4096</span><span style="color:#ADDCFF;"> Feb</span><span style="color:#91CBFF;"> 20</span><span style="color:#ADDCFF;"> 10:12</span><span style="color:#ADDCFF;"> test</span></span></code></pre></div><p>上面的命令加载主机的<code>/opt/webapp-data5</code>目录到容器的<code>/opt/webapp2</code>目录。这个功能在进行测试的时候十分方便，比如用户可以放置一些程序到本地目录中，来查看容器是否正常工作。本地目录的路径必须是绝对路径，如果目录不存在 Docker 会自动为你创建它。</p><blockquote><p>注意：如果你共享的是多级的目录，可能会出现权限不足的提示。这是因为 CentOS7 中的安全模块 selinux 把权限禁掉了，需要添加参数<code>--privileged=true</code>来解决挂载的目录没有权限的问题。</p></blockquote><p>注意：<code>Dockerfile</code>显然是不支持这种用法，这是因为<code>Dockerfile</code>是为了移植和分享用的, 因为不同操作系统的路径格式不一样，所以目前还不能支持。我们删除容器，看主机上数据是否会被删除</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost opt]# docker rm -f web</span></span>
<span class="line"><span style="color:#FFB757;">web</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost opt]# cd /opt/webapp-data5</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost webapp-data5]# ll</span></span>
<span class="line"><span style="color:#FFB757;">total</span><span style="color:#91CBFF;"> 4</span></span>
<span class="line"><span style="color:#FFB757;">drwxr-xr-x</span><span style="color:#91CBFF;"> 2</span><span style="color:#ADDCFF;"> root</span><span style="color:#ADDCFF;"> root</span><span style="color:#91CBFF;"> 4096</span><span style="color:#ADDCFF;"> Feb</span><span style="color:#91CBFF;"> 20</span><span style="color:#ADDCFF;"> 10:12</span><span style="color:#ADDCFF;"> test</span></span></code></pre></div><p>很明显，没有被删除</p><h3 id="挂载一个本地主机文件作为数据卷" tabindex="-1"><a class="header-anchor" href="#挂载一个本地主机文件作为数据卷"><span>挂载一个本地主机文件作为数据卷</span></a></h3><p><code>-v</code>标记也可以从主机挂载单个文件到容器中。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# docker run --rm -it -v </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">/.bash_history:/.bash_history ubuntu /bin/bash</span></span>
<span class="line"><span style="color:#FFB757;">root@79eca07938db:/#</span><span style="color:#ADDCFF;"> ll</span><span style="color:#FF9492;"> |</span><span style="color:#FFB757;"> grep</span><span style="color:#ADDCFF;"> .bash_history</span></span>
<span class="line"><span style="color:#FFB757;">-rw-------</span><span style="color:#91CBFF;">   1</span><span style="color:#ADDCFF;"> root</span><span style="color:#ADDCFF;"> root</span><span style="color:#91CBFF;"> 19549</span><span style="color:#ADDCFF;"> Feb</span><span style="color:#91CBFF;"> 19</span><span style="color:#ADDCFF;"> 10:28</span><span style="color:#ADDCFF;"> .bash_history</span></span>
<span class="line"><span style="color:#FFB757;">root@79eca07938db:/#</span><span style="color:#ADDCFF;"> exit</span></span>
<span class="line"><span style="color:#91CBFF;">exit</span></span></code></pre></div><p>这样就可以记录在容器输入过的命令了。</p><p>注意：如果直接挂载一个文件，很多文件编辑工具，包括 vi 或者<code>sed --in-place</code>，可能会造成文件<code>inode</code>的改变，这会导致报错误信息。所以最简单的办法就直接挂载文件的父目录。</p><h3 id="文件拷贝" tabindex="-1"><a class="header-anchor" href="#文件拷贝"><span>文件拷贝</span></a></h3><p>将 linux 宿主机中的文件拷贝到容器内可以使用命令<code>docker cp</code>：</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;"># docker cp 需要拷贝的文件或目录 容器名称:容器目录</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;"># 创建一个文件abc.txt</span></span>
<span class="line"><span style="color:#FFB757;">$</span><span style="color:#ADDCFF;"> touch</span><span style="color:#ADDCFF;"> abc.txt</span></span>
<span class="line"><span style="color:#BDC4CC;"># 复制abc.txt到mycentos2的容器的 / 目录下</span></span>
<span class="line"><span style="color:#FFB757;">$</span><span style="color:#ADDCFF;"> docker</span><span style="color:#ADDCFF;"> cp</span><span style="color:#ADDCFF;"> abc.txt</span><span style="color:#ADDCFF;"> mycentos2:/</span></span>
<span class="line"><span style="color:#BDC4CC;"># 进入mycentos2容器</span></span>
<span class="line"><span style="color:#FFB757;">$</span><span style="color:#ADDCFF;"> docker</span><span style="color:#ADDCFF;"> exec</span><span style="color:#91CBFF;"> -it</span><span style="color:#ADDCFF;"> mycentos2</span><span style="color:#ADDCFF;"> /bin/bash</span></span>
<span class="line"><span style="color:#BDC4CC;"># 查看容器 / 目录下文件</span></span>
<span class="line"><span style="color:#FFB757;">$</span><span style="color:#ADDCFF;"> ll</span></span></code></pre></div><p>将文件从容器内拷贝出来到linux宿主机使用命令：</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;"># docker cp 容器名称:容器目录 需要拷贝的文件或目录</span></span>
<span class="line"><span style="color:#BDC4CC;">#进入容器后创建文件cba.txt</span></span>
<span class="line"><span style="color:#FFB757;">touch</span><span style="color:#ADDCFF;"> cba.txt</span></span>
<span class="line"><span style="color:#BDC4CC;"># 退出容器 exit</span></span>
<span class="line"><span style="color:#BDC4CC;"># 在Linux宿主机器执行复制；将容器mycentos2的/cba.txt文件复制到 宿主机器的/root目录下</span></span>
<span class="line"><span style="color:#FFB757;">docker</span><span style="color:#ADDCFF;"> cp</span><span style="color:#ADDCFF;"> mycentos2:/cba.txt</span><span style="color:#ADDCFF;"> /root</span></span></code></pre></div><blockquote><p>注意：容器在停止状态下也可以完成文件的拷贝</p></blockquote><h3 id="删除数据卷" tabindex="-1"><a class="header-anchor" href="#删除数据卷"><span>删除数据卷</span></a></h3><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>docker volume rm my-vol</span></span></code></pre></div><p>数据卷是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除数据卷，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的数据卷。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用<code>docker rm -v</code>这个命令。</p><p>无主的数据卷可能会占据很多空间，要清理请使用以下命令。</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>docker volume prune</span></span></code></pre></div><h3 id="查看数据卷的具体信息" tabindex="-1"><a class="header-anchor" href="#查看数据卷的具体信息"><span>查看数据卷的具体信息</span></a></h3><p>在主机里使用以下命令可以查看指定数据卷的信息。</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# docker volume inspect my-vol</span></span>
<span class="line"><span style="color:#F0F3F6;">[</span></span>
<span class="line"><span style="color:#F0F3F6;">    {</span></span>
<span class="line"><span style="color:#ADDCFF;">        &quot;Driver&quot;</span><span style="color:#F0F3F6;">: </span><span style="color:#ADDCFF;">&quot;local&quot;</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#ADDCFF;">        &quot;Labels&quot;</span><span style="color:#F0F3F6;">: {},</span></span>
<span class="line"><span style="color:#ADDCFF;">        &quot;Mountpoint&quot;</span><span style="color:#F0F3F6;">: </span><span style="color:#ADDCFF;">&quot;/var/lib/docker/volumes/my-vol/_data&quot;</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#ADDCFF;">        &quot;Name&quot;</span><span style="color:#F0F3F6;">: </span><span style="color:#ADDCFF;">&quot;my-vol&quot;</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#ADDCFF;">        &quot;Options&quot;</span><span style="color:#F0F3F6;">: {},</span></span>
<span class="line"><span style="color:#ADDCFF;">        &quot;Scope&quot;</span><span style="color:#F0F3F6;">: </span><span style="color:#ADDCFF;">&quot;local&quot;</span></span>
<span class="line"><span style="color:#F0F3F6;">    }</span></span>
<span class="line"><span style="color:#F0F3F6;">]</span></span></code></pre></div><p>在主机里使用以下命令可以查看 web 容器的数据卷信息。</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# docker inspect web</span></span></code></pre></div><p>数据卷信息在<code>&quot;Mounts&quot;</code>属性下面。</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FFB757;">&quot;Mounts&quot;</span><span style="color:#91CBFF;">:</span><span style="color:#F0F3F6;"> [</span></span>
<span class="line"><span style="color:#F0F3F6;">    {</span></span>
<span class="line"><span style="color:#FFB757;">        &quot;Type&quot;</span><span style="color:#91CBFF;">:</span><span style="color:#ADDCFF;"> &quot;volume&quot;,</span></span>
<span class="line"><span style="color:#FFB757;">        &quot;Name&quot;</span><span style="color:#91CBFF;">:</span><span style="color:#ADDCFF;"> &quot;my-vol&quot;,</span></span>
<span class="line"><span style="color:#FFB757;">        &quot;Source&quot;</span><span style="color:#91CBFF;">:</span><span style="color:#ADDCFF;"> &quot;/var/lib/docker/volumes/my-vol/_data&quot;,</span></span>
<span class="line"><span style="color:#FFB757;">        &quot;Destination&quot;</span><span style="color:#91CBFF;">:</span><span style="color:#ADDCFF;"> &quot;/usr/share/nginx/html&quot;,</span></span>
<span class="line"><span style="color:#FFB757;">        &quot;Driver&quot;</span><span style="color:#91CBFF;">:</span><span style="color:#ADDCFF;"> &quot;local&quot;,</span></span>
<span class="line"><span style="color:#FFB757;">        &quot;Mode&quot;</span><span style="color:#91CBFF;">:</span><span style="color:#ADDCFF;"> &quot;&quot;,</span></span>
<span class="line"><span style="color:#FFB757;">        &quot;RW&quot;</span><span style="color:#91CBFF;">:</span><span style="color:#91CBFF;"> true</span><span style="color:#ADDCFF;">,</span></span>
<span class="line"><span style="color:#FFB757;">        &quot;Propagation&quot;</span><span style="color:#91CBFF;">:</span><span style="color:#ADDCFF;"> &quot;&quot;</span></span>
<span class="line"><span style="color:#F0F3F6;">    }</span></span>
<span class="line"><span style="color:#F0F3F6;">],</span></span></code></pre></div><h2 id="数据卷容器" tabindex="-1"><a class="header-anchor" href="#数据卷容器"><span>数据卷容器</span></a></h2><p>上面的是主机和容器之间共享数据，那么如何你有一些持续更新的数据需要在容器之间共享，最好的方法就是创建数据卷容器(<code>Data Volume Container</code>)。数据卷容器，其实就是一个正常的容器，专门用来提供数据卷供其它容器挂载的。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# docker run -d -v /dbdata --name dbdata training/postgres</span></span>
<span class="line"><span style="color:#FFB757;">70966085a85b05dd741a44a96725e2e44f146cc404b1b4e3aa3e519cd546c6b4</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# docker run -d --volumes-from dbdata --name db1 training/postgres</span></span>
<span class="line"><span style="color:#FFB757;">4c92240096d919724b233e1a5cfca94b5ceb0505e43262a7121cb83cfd8542f6</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# docker run -d --volumes-from dbdata --name db2 training/postgres</span></span>
<span class="line"><span style="color:#FFB757;">25246ebfae2f8437316b10d7eac3b34c1bd1522f50ba81651aec198bc79415a2</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# docker ps -a</span></span>
<span class="line"><span style="color:#FFB757;">CONTAINER</span><span style="color:#ADDCFF;"> ID</span><span style="color:#ADDCFF;">        IMAGE</span><span style="color:#ADDCFF;">               COMMAND</span><span style="color:#ADDCFF;">                  CREATED</span><span style="color:#ADDCFF;">              STATUS</span><span style="color:#ADDCFF;">              PORTS</span><span style="color:#ADDCFF;">               NAMES</span></span>
<span class="line"><span style="color:#FFB757;">70966085a85b</span><span style="color:#ADDCFF;">        training/postgres</span><span style="color:#ADDCFF;">   &quot;su postgres -c &#39;/us…&quot;</span><span style="color:#91CBFF;">   46</span><span style="color:#ADDCFF;"> seconds</span><span style="color:#ADDCFF;"> ago</span><span style="color:#ADDCFF;">       Up</span><span style="color:#91CBFF;"> 45</span><span style="color:#ADDCFF;"> seconds</span><span style="color:#ADDCFF;">       5432/tcp</span><span style="color:#ADDCFF;">            dbdata</span></span>
<span class="line"><span style="color:#FFB757;">25246ebfae2f</span><span style="color:#ADDCFF;">        training/postgres</span><span style="color:#ADDCFF;">   &quot;su postgres -c &#39;/us…&quot;</span><span style="color:#ADDCFF;">   About</span><span style="color:#ADDCFF;"> a</span><span style="color:#ADDCFF;"> minute</span><span style="color:#ADDCFF;"> ago</span><span style="color:#ADDCFF;">   Up</span><span style="color:#ADDCFF;"> About</span><span style="color:#ADDCFF;"> a</span><span style="color:#ADDCFF;"> minute</span><span style="color:#ADDCFF;">   5432/tcp</span><span style="color:#ADDCFF;">            db2</span></span>
<span class="line"><span style="color:#FFB757;">4c92240096d9</span><span style="color:#ADDCFF;">        training/postgres</span><span style="color:#ADDCFF;">   &quot;su postgres -c &#39;/us…&quot;</span><span style="color:#91CBFF;">   2</span><span style="color:#ADDCFF;"> minutes</span><span style="color:#ADDCFF;"> ago</span><span style="color:#ADDCFF;">        Up</span><span style="color:#91CBFF;"> 2</span><span style="color:#ADDCFF;"> minutes</span><span style="color:#ADDCFF;">        5432/tcp</span><span style="color:#ADDCFF;">            db1</span></span></code></pre></div><p><code>-volumes-from</code>可以多次使用来<code>mount</code>多个<code>conatainer</code>里的多个<code>volumes</code>。这个操作是链式的，我们在<code>db1</code>中通过<code>--volumes-from mount</code>进来的 <code>volume</code>可以继续被其他<code>container</code>使用。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# docker run -d --name db3 --volumes-from db1 training/postgres</span></span>
<span class="line"><span style="color:#FFB757;">44d0719377e86e3080b26d22adcb6055de93033dc9509ca2ecd8be2c93dc33b5</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# docker ps</span></span>
<span class="line"><span style="color:#FFB757;">CONTAINER</span><span style="color:#ADDCFF;"> ID</span><span style="color:#ADDCFF;">        IMAGE</span><span style="color:#ADDCFF;">               COMMAND</span><span style="color:#ADDCFF;">                  CREATED</span><span style="color:#ADDCFF;">             STATUS</span><span style="color:#ADDCFF;">              PORTS</span><span style="color:#ADDCFF;">               NAMES</span></span>
<span class="line"><span style="color:#FFB757;">44d0719377e8</span><span style="color:#ADDCFF;">        training/postgres</span><span style="color:#ADDCFF;">   &quot;su postgres -c &#39;/us…&quot;</span><span style="color:#91CBFF;">   3</span><span style="color:#ADDCFF;"> seconds</span><span style="color:#ADDCFF;"> ago</span><span style="color:#ADDCFF;">       Up</span><span style="color:#91CBFF;"> 2</span><span style="color:#ADDCFF;"> seconds</span><span style="color:#ADDCFF;">        5432/tcp</span><span style="color:#ADDCFF;">            db3</span></span>
<span class="line"><span style="color:#FFB757;">70966085a85b</span><span style="color:#ADDCFF;">        training/postgres</span><span style="color:#ADDCFF;">   &quot;su postgres -c &#39;/us…&quot;</span><span style="color:#91CBFF;">   3</span><span style="color:#ADDCFF;"> minutes</span><span style="color:#ADDCFF;"> ago</span><span style="color:#ADDCFF;">       Up</span><span style="color:#91CBFF;"> 3</span><span style="color:#ADDCFF;"> minutes</span><span style="color:#ADDCFF;">        5432/tcp</span><span style="color:#ADDCFF;">            dbdata</span></span>
<span class="line"><span style="color:#FFB757;">25246ebfae2f</span><span style="color:#ADDCFF;">        training/postgres</span><span style="color:#ADDCFF;">   &quot;su postgres -c &#39;/us…&quot;</span><span style="color:#91CBFF;">   4</span><span style="color:#ADDCFF;"> minutes</span><span style="color:#ADDCFF;"> ago</span><span style="color:#ADDCFF;">       Up</span><span style="color:#91CBFF;"> 4</span><span style="color:#ADDCFF;"> minutes</span><span style="color:#ADDCFF;">        5432/tcp</span><span style="color:#ADDCFF;">            db2</span></span>
<span class="line"><span style="color:#FFB757;">4c92240096d9</span><span style="color:#ADDCFF;">        training/postgres</span><span style="color:#ADDCFF;">   &quot;su postgres -c &#39;/us…&quot;</span><span style="color:#91CBFF;">   4</span><span style="color:#ADDCFF;"> minutes</span><span style="color:#ADDCFF;"> ago</span><span style="color:#ADDCFF;">       Up</span><span style="color:#91CBFF;"> 4</span><span style="color:#ADDCFF;"> minutes</span><span style="color:#ADDCFF;">        5432/tcp</span><span style="color:#ADDCFF;">            db1</span></span></code></pre></div><p>使用<code>--volumes-from</code>参数所挂载数据卷的容器自己并不需要保持在运行状态。如果删除了挂载的容器（包括<code>dbdata、db1</code>和<code>db2</code>），数据卷并不会被自动删除。如果要删除一个数据卷，必须在删除最后一个还挂载着它的容器时使用<code>docker rm -v</code>命令来指定同时删除关联的容器。 这可以让用户在容器之间升级和移动数据卷。</p><h2 id="参考文章" tabindex="-1"><a class="header-anchor" href="#参考文章"><span>参考文章</span></a></h2><p><a href="https://www.pdai.tech/md/devops/docker/docker-06-data.html" target="_blank" rel="noopener noreferrer">Docker基础 - Docker数据卷和数据管理</a><br><a href="https://vuepress.mirror.docker-practice.com/data_management/" target="_blank" rel="noopener noreferrer">Docker 数据管理</a></p>`,54)]))}const F=a(e,[["render",p],["__file","Docker的数据卷.html.vue"]]),i=JSON.parse('{"path":"/linux/docker/Docker%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8D%B7.html","title":"Docker的数据卷","lang":"zh-CN","frontmatter":{"title":"Docker的数据卷","date":"2024-01-15T00:00:00.000Z","tags":"Docker","categories":"linux","order":3,"description":"数据卷 数据卷的使用，类似于 Linux 下对目录或文件进行mount，镜像中的被指定为挂载点的目录中的文件会复制到数据卷中（仅数据卷为空时会复制）。 数据卷(Data Volume)是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性： 数据卷可以在容器之间共享和重用 对数据卷的修改会立马生效 对数据卷的更新，不会影响镜像 ...","head":[["meta",{"property":"og:url","content":"https://0oWSQo0.github.io/wsq-blog/linux/docker/Docker%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8D%B7.html"}],["meta",{"property":"og:title","content":"Docker的数据卷"}],["meta",{"property":"og:description","content":"数据卷 数据卷的使用，类似于 Linux 下对目录或文件进行mount，镜像中的被指定为挂载点的目录中的文件会复制到数据卷中（仅数据卷为空时会复制）。 数据卷(Data Volume)是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性： 数据卷可以在容器之间共享和重用 对数据卷的修改会立马生效 对数据卷的更新，不会影响镜像 ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-08-14T07:08:17.000Z"}],["meta",{"property":"article:published_time","content":"2024-01-15T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-08-14T07:08:17.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Docker的数据卷\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-01-15T00:00:00.000Z\\",\\"dateModified\\":\\"2024-08-14T07:08:17.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"WSQ\\",\\"url\\":\\"https://0oWSQo0.github.com\\"}]}"]]},"headers":[{"level":2,"title":"数据卷","slug":"数据卷","link":"#数据卷","children":[{"level":3,"title":"创建一个数据卷","slug":"创建一个数据卷","link":"#创建一个数据卷","children":[]},{"level":3,"title":"挂载一个主机目录作为数据卷","slug":"挂载一个主机目录作为数据卷","link":"#挂载一个主机目录作为数据卷","children":[]},{"level":3,"title":"挂载一个本地主机文件作为数据卷","slug":"挂载一个本地主机文件作为数据卷","link":"#挂载一个本地主机文件作为数据卷","children":[]},{"level":3,"title":"文件拷贝","slug":"文件拷贝","link":"#文件拷贝","children":[]},{"level":3,"title":"删除数据卷","slug":"删除数据卷","link":"#删除数据卷","children":[]},{"level":3,"title":"查看数据卷的具体信息","slug":"查看数据卷的具体信息","link":"#查看数据卷的具体信息","children":[]}]},{"level":2,"title":"数据卷容器","slug":"数据卷容器","link":"#数据卷容器","children":[]},{"level":2,"title":"参考文章","slug":"参考文章","link":"#参考文章","children":[]}],"git":{"createdTime":1722925047000,"updatedTime":1723619297000,"contributors":[{"name":"WSQ","email":"592786982@qq.com","commits":2}]},"readingTime":{"minutes":6.44,"words":1933},"filePathRelative":"linux/docker/Docker的数据卷.md","localizedDate":"2024年1月15日","autoDesc":true}');export{F as comp,i as data};
