import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,d as l,o as p}from"./app-Coac0FJ0.js";const o={};function e(c,s){return p(),n("div",null,s[0]||(s[0]=[l(`<h2 id="class-定义类" tabindex="-1"><a class="header-anchor" href="#class-定义类"><span>class：定义类</span></a></h2><p>定义一个类使用<code>class</code>关键字实现：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>class 类名：</span></span>
<span class="line"><span>  多个（≥0）类属性...</span></span>
<span class="line"><span>  多个（≥0）类方法...</span></span></code></pre></div><p>无论是类属性还是类方法，对于类来说，它们都不是必需的。另外，类中属性和方法所在的位置是任意的，即它们之间并没有固定的前后次序。</p><p>类属性指的就是包含在类中的变量；类方法指的是包含类中的函数。换句话说，类属性和类方法其实分别是包含类中的变量和函数的别称。</p><p>Python 类是由类头（<code>class</code>类名）和类体（统一缩进的变量和函数）构成。</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> TheFirstDemo</span><span style="color:#F0F3F6;">:</span></span>
<span class="line"><span style="color:#ADDCFF;">		&#39;&#39;&#39;这是一个学习Python定义的第一个类&#39;&#39;&#39;</span></span>
<span class="line"><span style="color:#BDC4CC;">		# 下面定义了一个类属性</span></span>
<span class="line"><span style="color:#F0F3F6;">		add </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &#39;hello&#39;</span></span>
<span class="line"><span style="color:#BDC4CC;">		# 下面定义了一个say方法</span></span>
<span class="line"><span style="color:#FF9492;">		def</span><span style="color:#DBB7FF;"> say</span><span style="color:#F0F3F6;">(self, content):</span></span>
<span class="line"><span style="color:#91CBFF;">    		print</span><span style="color:#F0F3F6;">(content)</span></span></code></pre></div><p>和函数一样，我们也可以为类定义说明文档，其要放到类头之后，类体之前的位置，如上面程序中第二行的字符串，就是<code>TheFirstDemo</code>这个类的说明文档。</p><p>更确切地说，<code>say()</code>是一个实例方法，除此之外，Python 类中还可以定义类方法和静态方法。</p><p>事实上，我们完全可以创建一个没有任何类属性和类方法的类，换句话说，Python 允许创建空类：</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Empty</span><span style="color:#F0F3F6;">:</span></span>
<span class="line"><span style="color:#FF9492;">    pass</span></span></code></pre></div><p>如果一个类没有任何类属性和类方法，那么可以直接用<code>pass</code>关键字作为类体即可。</p><h2 id="init-类构造方法" tabindex="-1"><a class="header-anchor" href="#init-类构造方法"><span><strong>init</strong>()类构造方法</span></a></h2><p>在创建类时，我们可以手动添加一个<code>__init__()</code>方法，该方法是一个特殊的类实例方法，称为构造方法（或构造函数）。</p><p>构造方法用于创建对象时使用，每当创建一个类的实例对象时，Python 解释器都会自动调用它。</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">def</span><span style="color:#91CBFF;"> __init__</span><span style="color:#F0F3F6;">(self, ...):</span></span>
<span class="line"><span style="color:#F0F3F6;">  代码块</span></span></code></pre></div><p>另外，<code>__init__()</code>方法可以包含多个参数，但必须包含一个名为<code>self</code>的参数，且必须作为第一个参数。也就是说，类的构造方法最少也要有一个<code>self</code>参数。</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> TheFirstDemo</span><span style="color:#F0F3F6;">:</span></span>
<span class="line"><span style="color:#ADDCFF;">    &#39;&#39;&#39;这是一个学习Python定义的第一个类&#39;&#39;&#39;</span></span>
<span class="line"><span style="color:#BDC4CC;">    #构造方法</span></span>
<span class="line"><span style="color:#FF9492;">    def</span><span style="color:#91CBFF;"> __init__</span><span style="color:#F0F3F6;">(self):</span></span>
<span class="line"><span style="color:#91CBFF;">        print</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;调用构造方法&quot;</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#BDC4CC;">    # 下面定义了一个类属性</span></span>
<span class="line"><span style="color:#F0F3F6;">    add </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &#39;test&#39;</span></span>
<span class="line"><span style="color:#BDC4CC;">    # 下面定义了一个say方法</span></span>
<span class="line"><span style="color:#FF9492;">    def</span><span style="color:#DBB7FF;"> say</span><span style="color:#F0F3F6;">(self, content):</span></span>
<span class="line"><span style="color:#91CBFF;">        print</span><span style="color:#F0F3F6;">(content)</span></span></code></pre></div><div class="hint-container warning"><p class="hint-container-title">注意</p><p>即便不手动为类添加任何构造方法，Python 也会自动为类添加一个仅包含<code>self</code>参数的构造方法。</p></div><p>仅包含<code>self</code>参数的<code>__init__(self)</code>构造方法，又称为类的默认构造方法。</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">zhangsan </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> TheFirstDemo()</span></span></code></pre></div><p>这行代码的含义是创建一个名为<code>zhangsan</code>的<code>TheFirstDemo</code>类对象。运行代码可看到如下结果：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>调用构造方法</span></span></code></pre></div><p>显然，在创建<code>zhangsan</code>这个对象时，隐式调用了我们手动创建的<code>__init__()</code>构造方法。</p><p>在<code>__init__()</code>构造方法中，除了<code>self</code>参数外，还可以自定义一些参数，参数之间使用逗号进行分割。</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> CLanguage</span><span style="color:#F0F3F6;">:</span></span>
<span class="line"><span style="color:#ADDCFF;">    &#39;&#39;&#39;这是一个学习Python定义的一个类&#39;&#39;&#39;</span></span>
<span class="line"><span style="color:#FF9492;">    def</span><span style="color:#91CBFF;"> __init__</span><span style="color:#F0F3F6;">(self, name, add):</span></span>
<span class="line"><span style="color:#91CBFF;">        print</span><span style="color:#F0F3F6;">(name, </span><span style="color:#ADDCFF;">&quot;的英文名为:&quot;</span><span style="color:#F0F3F6;">, add)</span></span>
<span class="line"><span style="color:#BDC4CC;">#创建 add 对象，并传递参数给构造函数</span></span>
<span class="line"><span style="color:#F0F3F6;">add </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> CLanguage(</span><span style="color:#ADDCFF;">&quot;小明&quot;</span><span style="color:#F0F3F6;">, </span><span style="color:#ADDCFF;">&quot;xiaoming&quot;</span><span style="color:#F0F3F6;">)</span></span></code></pre></div><p>可以看到，虽然构造方法中有<code>self、name、add</code>3 个参数，但实际需要传参的仅有<code>name</code>和<code>add</code>，也就是说，<code>self</code>不需要手动传递参数。</p><h2 id="类对象的创建和使用" tabindex="-1"><a class="header-anchor" href="#类对象的创建和使用"><span>类对象的创建和使用</span></a></h2><h3 id="类的实例化" tabindex="-1"><a class="header-anchor" href="#类的实例化"><span>类的实例化</span></a></h3><p>对已定义好的类进行实例化：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>类名(参数)</span></span></code></pre></div><p>定义类时，如果没有手动添加<code>__init__()</code>构造方法，又或者添加的<code>__init__()</code>中仅有一个<code>self</code>参数，则创建类对象时的参数可以省略不写。</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> CLanguage</span><span style="color:#F0F3F6;"> :</span></span>
<span class="line"><span style="color:#BDC4CC;">		# 下面定义了2个类变量</span></span>
<span class="line"><span style="color:#F0F3F6;">		name </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &quot;小明&quot;</span></span>
<span class="line"><span style="color:#F0F3F6;">		add </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &quot;xiaoming&quot;</span></span>
<span class="line"><span style="color:#FF9492;">		def</span><span style="color:#91CBFF;"> __init__</span><span style="color:#F0F3F6;">(self, name, add):</span></span>
<span class="line"><span style="color:#BDC4CC;">			  #下面定义 2 个实例变量</span></span>
<span class="line"><span style="color:#91CBFF;">			  self</span><span style="color:#F0F3F6;">.name </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> name</span></span>
<span class="line"><span style="color:#91CBFF;">			  self</span><span style="color:#F0F3F6;">.add </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> add</span></span>
<span class="line"><span style="color:#91CBFF;">			  print</span><span style="color:#F0F3F6;">(name,</span><span style="color:#ADDCFF;">&quot;的英文名为：&quot;</span><span style="color:#F0F3F6;">,add)</span></span>
<span class="line"><span style="color:#BDC4CC;">		# 下面定义了一个say实例方法</span></span>
<span class="line"><span style="color:#FF9492;">		def</span><span style="color:#DBB7FF;"> say</span><span style="color:#F0F3F6;">(self, content):</span></span>
<span class="line"><span style="color:#91CBFF;">			  print</span><span style="color:#F0F3F6;">(content)</span></span>
<span class="line"><span style="color:#BDC4CC;"># 将该CLanguage对象赋给clanguage变量</span></span>
<span class="line"><span style="color:#F0F3F6;">clanguage </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> CLanguage(</span><span style="color:#ADDCFF;">&quot;小明&quot;</span><span style="color:#F0F3F6;">,</span><span style="color:#ADDCFF;">&quot;xiaoming&quot;</span><span style="color:#F0F3F6;">)</span></span></code></pre></div><p>在上面的程序中，由于构造方法除<code>self</code>参数外，还包含 2 个参数，且这 2 个参数没有设置默认参数，因此在实例化类对象时，需要传入相应的<code>name</code>值和<code>add</code>值（<code>self</code>参数是特殊参数，不需要手动传值，Python 会自动传给它值）。</p><p>类变量和实例变量，简单地理解，定义在各个类方法之外（包含在类中）的变量为类变量（或者类属性），定义在类方法中的变量为实例变量（或者实例属性）。</p><h3 id="类对象的使用" tabindex="-1"><a class="header-anchor" href="#类对象的使用"><span>类对象的使用</span></a></h3><p>定义的类只有进行实例化，也就是使用该类创建对象之后，才能得到利用。总的来说，实例化后的类对象可以执行以下操作：</p><ul><li>访问或修改类对象具有的实例变量，甚至可以添加新的实例变量或者删除已有的实例变量；</li><li>调用类对象的方法，包括调用现有的方法，以及给类对象动态添加方法。</li></ul><h4 id="类对象访问变量或方法" tabindex="-1"><a class="header-anchor" href="#类对象访问变量或方法"><span>类对象访问变量或方法</span></a></h4><p>使用已创建好的类对象访问类中实例变量的语法格式如下：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>类对象名.变量名</span></span></code></pre></div><p>使用类对象调用类中方法的语法格式如下：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>对象名.方法名(参数)</span></span></code></pre></div><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">#输出name和add实例变量的值</span></span>
<span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(clanguage.name,clanguage.add)</span></span>
<span class="line"><span style="color:#BDC4CC;">#修改实例变量的值</span></span>
<span class="line"><span style="color:#F0F3F6;">clanguage.name</span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;">&quot;小红&quot;</span></span>
<span class="line"><span style="color:#F0F3F6;">clanguage.add</span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;">&quot;xiaohong&quot;</span></span>
<span class="line"><span style="color:#BDC4CC;">#调用clanguage的say()方法</span></span>
<span class="line"><span style="color:#F0F3F6;">clanguage.say(</span><span style="color:#ADDCFF;">&quot;人生苦短，我用Python&quot;</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#BDC4CC;">#再次输出name和add的值</span></span>
<span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(clanguage.name,clanguage.add)</span></span></code></pre></div><h4 id="给类对象动态添加-删除变量" tabindex="-1"><a class="header-anchor" href="#给类对象动态添加-删除变量"><span>给类对象动态添加/删除变量</span></a></h4><p>Python 支持为已创建好的对象动态增加实例变量：</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;"># 为clanguage对象增加一个money实例变量</span></span>
<span class="line"><span style="color:#F0F3F6;">clanguage.money</span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 159.9</span></span>
<span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(clanguage.money) </span><span style="color:#BDC4CC;"># 159.9</span></span></code></pre></div><p>动态删除使用<code>del</code>语句即可实现：</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">#删除新添加的 money 实例变量</span></span>
<span class="line"><span style="color:#FF9492;">del</span><span style="color:#F0F3F6;"> clanguage.money</span></span>
<span class="line"><span style="color:#BDC4CC;">#再次尝试输出 money，此时会报错</span></span>
<span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(clanguage.money)</span></span></code></pre></div><p>运行程序会发现，结果显示<code>AttributeError</code>错误：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>Traceback (most recent call last):</span></span>
<span class="line"><span>  File &quot;C:/Users/mengma/Desktop/1.py&quot;, line 29, in &lt;module&gt;</span></span>
<span class="line"><span>    print(clanguage.money)</span></span>
<span class="line"><span>AttributeError: &#39;CLanguage&#39; object has no attribute &#39;money&#39;</span></span></code></pre></div><h4 id="给类对象动态添加方法" tabindex="-1"><a class="header-anchor" href="#给类对象动态添加方法"><span>给类对象动态添加方法</span></a></h4><p>Python 也允许为对象动态增加方法。以<code>Clanguage</code>类为例，由于其内部只包含一个<code>say()</code>方法，因此该类实例化出的<code>clanguage</code>对象也只包含一个<code>say()</code>方法。但其实，我们还可以为<code>clanguage</code>对象动态添加其它方法。</p><p>需要注意的一点是，为<code>clanguage</code>对象动态增加的方法，Python 不会自动将调用者自动绑定到第一个参数（即使将第一个参数命名为<code>self</code>也没用）。</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;"># 先定义一个函数</span></span>
<span class="line"><span style="color:#FF9492;">def</span><span style="color:#DBB7FF;"> info</span><span style="color:#F0F3F6;">(self):</span></span>
<span class="line"><span style="color:#91CBFF;">  print</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;---info函数---&quot;</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">self</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#BDC4CC;"># 使用info对clanguage的foo方法赋值（动态绑定方法）</span></span>
<span class="line"><span style="color:#F0F3F6;">clanguage.foo </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> info</span></span>
<span class="line"><span style="color:#BDC4CC;"># Python不会自动将调用者绑定到第一个参数，</span></span>
<span class="line"><span style="color:#BDC4CC;"># 因此程序需要手动将调用者绑定为第一个参数</span></span>
<span class="line"><span style="color:#F0F3F6;">clanguage.foo(clanguage)  </span><span style="color:#BDC4CC;"># ①</span></span>
<span class="line"><span style="color:#BDC4CC;"># 使用lambda表达式为clanguage对象的bar方法赋值（动态绑定方法）</span></span>
<span class="line"><span style="color:#F0F3F6;">clanguage.bar </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> lambda</span><span style="color:#F0F3F6;"> self: </span><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;--lambda表达式--&#39;</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">self</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#F0F3F6;">clanguage.bar(clanguage) </span><span style="color:#BDC4CC;"># ②</span></span></code></pre></div><p>上面的第 8 行和第 10 行代码分别使用函数、lambda 表达式为<code>clanguage</code>对象动态增加了方法，但对于动态增加的方法，Python 不会自动将方法调用者绑定到它们的第一个参数，因此程序必须手动为第一个参数传入参数值，如上面程序中 ① 号、② 号代码所示。</p><p>有没有不用手动给<code>self</code>传值的方法呢？通过借助<code>types</code>模块下的<code>MethodType</code>可以实现：</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">def</span><span style="color:#DBB7FF;"> info</span><span style="color:#F0F3F6;">(self,content):</span></span>
<span class="line"><span style="color:#91CBFF;">  print</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;小明的英文名为：</span><span style="color:#FF9492;">%s</span><span style="color:#ADDCFF;">&quot;</span><span style="color:#FF9492;"> %</span><span style="color:#F0F3F6;"> content)</span></span>
<span class="line"><span style="color:#BDC4CC;"># 导入MethodType</span></span>
<span class="line"><span style="color:#FF9492;">from</span><span style="color:#F0F3F6;"> types </span><span style="color:#FF9492;">import</span><span style="color:#F0F3F6;"> MethodType</span></span>
<span class="line"><span style="color:#F0F3F6;">clanguage.info </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> MethodType(info, clanguage)</span></span>
<span class="line"><span style="color:#BDC4CC;"># 第一个参数已经绑定了，无需传入</span></span>
<span class="line"><span style="color:#F0F3F6;">clanguage.info(</span><span style="color:#ADDCFF;">&quot;xiaoming&quot;</span><span style="color:#F0F3F6;">)</span></span></code></pre></div><p>可以看到，由于使用<code>MethodType</code>包装<code>info()</code>函数时，已经将该函数的<code>self</code>参数绑定为<code>clanguage</code>，因此后续再使用<code>info()</code>函数时，就不用再给<code>self</code>参数绑定值了。</p><h1 id="self用法" tabindex="-1"><a class="header-anchor" href="#self用法"><span>self用法</span></a></h1><p>在定义类的过程中，无论是显式创建类的构造方法，还是向类中添加实例方法，都要求将<code>self</code>参数作为方法的第一个参数。</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Person</span><span style="color:#F0F3F6;">:</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#91CBFF;"> __init__</span><span style="color:#F0F3F6;">(self):</span></span>
<span class="line"><span style="color:#91CBFF;">    print</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;正在执行构造方法&quot;</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#BDC4CC;">  # 定义一个study()实例方法</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#DBB7FF;"> study</span><span style="color:#F0F3F6;">(self,name):</span></span>
<span class="line"><span style="color:#91CBFF;">    print</span><span style="color:#F0F3F6;">(name,</span><span style="color:#ADDCFF;">&quot;正在学Python&quot;</span><span style="color:#F0F3F6;">)</span></span></code></pre></div><p>事实上，Python 只是规定，无论是构造方法还是实例方法，最少要包含一个参数，并没有规定该参数的具体名称。之所以将其命名为<code>self</code>，只是程序员之间约定俗成的一种习惯（大家一看到<code>self</code>，就知道它的作用）。</p><p>那么，<code>self</code>参数的具体作用是什么呢？打个比方，如果把类比作造房子的图纸，那么类实例化后的对象是真正可以住的房子。根据一张图纸（类），我们可以设计出成千上万的房子（类对象），每个房子长相都是类似的（都有相同的类变量和类方法），但它们都有各自的主人，那么如何对它们进行区分呢？</p><p>当然是通过<code>self</code>参数，它就相当于每个房子的门钥匙，可以保证每个房子的主人仅能进入自己的房子（每个类对象只能调用自己的类变量和类方法）。</p><p>其实 Python 类方法中的<code>self</code>参数就相当于 C++ 中的<code>this</code>指针。</p><p>也就是说，同一个类可以产生多个对象，当某个对象调用类方法时，该对象会把自身的引用作为第一个参数自动传给该方法，换句话说，Python 会自动绑定类方法的第一个参数指向调用该方法的对象。如此，Python 解释器就能知道到底要操作哪个对象的方法了。</p><p>因此，程序在调用实例方法和构造方法时，不需要手动为第一个参数传值。</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Person</span><span style="color:#F0F3F6;">:</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#91CBFF;"> __init__</span><span style="color:#F0F3F6;">(self):</span></span>
<span class="line"><span style="color:#91CBFF;">    print</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;正在执行构造方法&quot;</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#BDC4CC;">  # 定义一个study()实例方法</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#DBB7FF;"> study</span><span style="color:#F0F3F6;">(self):</span></span>
<span class="line"><span style="color:#91CBFF;">    print</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">self</span><span style="color:#F0F3F6;">, </span><span style="color:#ADDCFF;">&quot;正在学Python&quot;</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#F0F3F6;">zhangsan </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> Person()</span></span>
<span class="line"><span style="color:#F0F3F6;">zhangsan.study()</span></span>
<span class="line"><span style="color:#F0F3F6;">lisi </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> Person()</span></span>
<span class="line"><span style="color:#F0F3F6;">lisi.study()</span></span></code></pre></div><p>上面代码中，<code>study()</code>中的<code>self</code>代表该方法的调用者，即谁调用该方法，那么<code>self</code>就代表谁。因此，该程序的运行结果为：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>正在执行构造方法</span></span>
<span class="line"><span>&lt;__main__.Person object at 0x0000021ADD7D21D0&gt; 正在学Python</span></span>
<span class="line"><span>正在执行构造方法</span></span>
<span class="line"><span>&lt;__main__.Person object at 0x0000021ADD7D2E48&gt; 正在学Python</span></span></code></pre></div><p>另外，对于构造函数中的<code>self</code>参数，其代表的是当前正在初始化的类对象。</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Person</span><span style="color:#F0F3F6;">:</span></span>
<span class="line"><span style="color:#F0F3F6;">  name </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &quot;xxx&quot;</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#91CBFF;"> __init__</span><span style="color:#F0F3F6;">(self,name):</span></span>
<span class="line"><span style="color:#91CBFF;">    self</span><span style="color:#F0F3F6;">.name</span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;">name</span></span>
<span class="line"><span style="color:#F0F3F6;">zhangsan </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> Person(</span><span style="color:#ADDCFF;">&quot;zhangsan&quot;</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(zhangsan.name) </span><span style="color:#BDC4CC;"># zhangsan</span></span>
<span class="line"><span style="color:#F0F3F6;">lisi </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> Person(</span><span style="color:#ADDCFF;">&quot;lisi&quot;</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(lisi.name) </span><span style="color:#BDC4CC;"># lisi</span></span></code></pre></div><p>可以看到，<code>zhangsan</code>在进行初始化时，调用的构造函数中<code>self</code>代表的是<code>zhangsan</code>；而<code>lisi</code>在进行初始化时，调用的构造函数中<code>self</code>代表的是<code>lisi</code>。</p><p>值得一提的是，除了类对象可以直接调用类方法，还有一种函数调用的方式：</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Person</span><span style="color:#F0F3F6;">:</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#DBB7FF;"> who</span><span style="color:#F0F3F6;">(self):</span></span>
<span class="line"><span style="color:#91CBFF;">    print</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">self</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#F0F3F6;">zhangsan </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> Person()</span></span>
<span class="line"><span style="color:#BDC4CC;">#第一种方式</span></span>
<span class="line"><span style="color:#F0F3F6;">zhangsan.who()</span></span>
<span class="line"><span style="color:#BDC4CC;">#第二种方式</span></span>
<span class="line"><span style="color:#F0F3F6;">who </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> zhangsan.who</span></span>
<span class="line"><span style="color:#F0F3F6;">who()</span><span style="color:#BDC4CC;">#通过 who 变量调用zhangsan对象中的 who() 方法</span></span></code></pre></div><p>运行结果为：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>&lt;__main__.Person object at 0x0000025C26F021D0&gt;</span></span>
<span class="line"><span>&lt;__main__.Person object at 0x0000025C26F021D0&gt;</span></span></code></pre></div><p>显然，无论采用哪种方法，<code>self</code>所表示的都是实际调用该方法的对象。</p><p>总之，无论是类中的构造函数还是普通的类方法，实际调用它们的谁，则第一个参数<code>self</code>就代表谁。</p><h1 id="类属性和实例属性" tabindex="-1"><a class="header-anchor" href="#类属性和实例属性"><span>类属性和实例属性</span></a></h1><p>无论是类属性还是类方法，都无法像普通变量或者函数那样，在类的外部直接使用它们。我们可以将类看做一个独立的空间，则类属性其实就是在类体中定义的变量，类方法是在类体中定义的函数。</p><p>在类体中，根据变量定义的位置不同，以及定义的方式不同，类属性又可细分为以下 3 种类型：</p><ul><li>类体中、所有函数之外：此范围定义的变量，称为类属性或类变量；</li><li>类体中，所有函数内部：以<code>self.变量名</code>的方式定义的变量，称为实例属性或实例变量；</li><li>类体中，所有函数内部：以“变量名=变量值”的方式定义的变量，称为局部变量。</li></ul><p>类方法也可细分为实例方法、静态方法和类方法。</p><h2 id="类变量-类属性" tabindex="-1"><a class="header-anchor" href="#类变量-类属性"><span>类变量（类属性）</span></a></h2><p>类变量指的是在类中，但在各个类方法外定义的变量。</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> CLanguage</span><span style="color:#F0F3F6;"> :</span></span>
<span class="line"><span style="color:#BDC4CC;">  # 下面定义了2个类变量</span></span>
<span class="line"><span style="color:#F0F3F6;">  name </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &quot;小明&quot;</span></span>
<span class="line"><span style="color:#F0F3F6;">  add </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &quot;xiaoming&quot;</span></span>
<span class="line"><span style="color:#BDC4CC;">  # 下面定义了一个say实例方法</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#DBB7FF;"> say</span><span style="color:#F0F3F6;">(self, content):</span></span>
<span class="line"><span style="color:#91CBFF;">    print</span><span style="color:#F0F3F6;">(content)</span></span></code></pre></div><p>上面程序中，<code>name</code>和<code>add</code>就属于类变量。</p><p>类变量的特点是，所有类的实例化对象都同时共享类变量，也就是说，类变量在所有实例化对象中是作为公用资源存在的。类变量的调用方式有 2 种，既可以使用类名直接调用，也可以使用类的实例化对象调用。</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">#使用类名直接调用</span></span>
<span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(CLanguage.name) </span><span style="color:#BDC4CC;"># 小明</span></span>
<span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(CLanguage.add) </span><span style="color:#BDC4CC;"># xiaoming</span></span>
<span class="line"><span style="color:#BDC4CC;">#修改类变量的值</span></span>
<span class="line"><span style="color:#F0F3F6;">CLanguage.name </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &quot;小红&quot;</span></span>
<span class="line"><span style="color:#F0F3F6;">CLanguage.add </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &quot;xiaohong&quot;</span></span>
<span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(CLanguage.name) </span><span style="color:#BDC4CC;"># 小红</span></span>
<span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(CLanguage.add) </span><span style="color:#BDC4CC;"># xiaohong</span></span></code></pre></div><p>可以看到，通过类名不仅可以调用类变量，也可以修改它的值。</p><p>当然，也可以使用类对象来调用所属类中的类变量。</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">clang </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> CLanguage()</span></span>
<span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(clang.name)</span></span>
<span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(clang.add)</span></span></code></pre></div><p>注意，因为类变量为所有实例化对象共有，通过类名修改类变量的值，会影响所有的实例化对象。</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;修改前，各类对象中类变量的值：&quot;</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#F0F3F6;">clang1 </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> CLanguage()</span></span>
<span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(clang1.name) </span><span style="color:#BDC4CC;"># 小明</span></span>
<span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(clang1.add) </span><span style="color:#BDC4CC;"># xiaoming</span></span>
<span class="line"><span style="color:#F0F3F6;">clang2 </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> CLanguage()</span></span>
<span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(clang2.name) </span><span style="color:#BDC4CC;"># 小明</span></span>
<span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(clang2.add) </span><span style="color:#BDC4CC;"># xiaoming</span></span>
<span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;修改后，各类对象中类变量的值：&quot;</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#F0F3F6;">CLanguage.name </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &quot;小红&quot;</span></span>
<span class="line"><span style="color:#F0F3F6;">CLanguage.add </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &quot;xiaohong&quot;</span></span>
<span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(clang1.name) </span><span style="color:#BDC4CC;"># 小红</span></span>
<span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(clang1.add) </span><span style="color:#BDC4CC;"># xiaohong</span></span>
<span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(clang2.name) </span><span style="color:#BDC4CC;"># 小红</span></span>
<span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(clang2.add) </span><span style="color:#BDC4CC;"># xiaohong</span></span></code></pre></div><p>显然，通过类名修改类变量，会作用到所有的实例化对象（例如这里的<code>clang1</code>和<code>clang2</code>）。</p><p>注意，通过类对象是无法修改类变量的。通过类对象对类变量赋值，其本质将不再是修改类变量的值，而是在给该对象定义新的实例变量。</p><p>值得一提的是，除了可以通过类名访问类变量之外，还可以动态地为类和对象添加类变量。</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">clang </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> CLanguage()</span></span>
<span class="line"><span style="color:#F0F3F6;">CLanguage.catalog </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 13</span></span>
<span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(clang.catalog) </span><span style="color:#BDC4CC;"># 13</span></span></code></pre></div><h2 id="实例变量-实例属性" tabindex="-1"><a class="header-anchor" href="#实例变量-实例属性"><span>实例变量（实例属性）</span></a></h2><p>实例变量指的是在任意类方法内部，以“self.变量名”的方式定义的变量，其特点是只作用于调用方法的对象。另外，实例变量只能通过对象名访问，无法通过类名访问。</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> CLanguage</span><span style="color:#F0F3F6;"> :</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#91CBFF;"> __init__</span><span style="color:#F0F3F6;">(self):</span></span>
<span class="line"><span style="color:#91CBFF;">    self</span><span style="color:#F0F3F6;">.name </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &quot;小明&quot;</span></span>
<span class="line"><span style="color:#91CBFF;">    self</span><span style="color:#F0F3F6;">.add </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &quot;xiaoming&quot;</span></span>
<span class="line"><span style="color:#BDC4CC;">    # 下面定义了一个say实例方法</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#DBB7FF;"> say</span><span style="color:#F0F3F6;">(self):</span></span>
<span class="line"><span style="color:#91CBFF;">    self</span><span style="color:#F0F3F6;">.catalog </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 13</span></span></code></pre></div><p>此<code>CLanguage</code>类中，<code>name、add</code>以及<code>catalog</code>都是实例变量。其中，由于<code>__init__()</code>函数在创建类对象时会自动调用，而<code>say()</code>方法需要类对象手动调用。因此，<code>CLanguage</code>类的类对象都会包含<code>name</code>和<code>add</code>实例变量，而只有调用了<code>say()</code>方法的类对象，才包含<code>catalog</code>实例变量。</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">clang </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> CLanguage()</span></span>
<span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(clang.name) </span><span style="color:#BDC4CC;"># 小明</span></span>
<span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(clang.add) </span><span style="color:#BDC4CC;"># xiaoming</span></span>
<span class="line"><span style="color:#BDC4CC;">#由于 clang 对象未调用 say() 方法，因此其没有 catalog 变量，下面这行代码会报错</span></span>
<span class="line"><span style="color:#BDC4CC;">#print(clang.catalog)</span></span>
<span class="line"><span style="color:#F0F3F6;">clang2 </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> CLanguage()</span></span>
<span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(clang2.name) </span><span style="color:#BDC4CC;"># 小明</span></span>
<span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(clang2.add) </span><span style="color:#BDC4CC;"># xiaoming</span></span>
<span class="line"><span style="color:#BDC4CC;">#只有调用 say()，才会拥有 catalog 实例变量</span></span>
<span class="line"><span style="color:#F0F3F6;">clang2.say()</span></span>
<span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(clang2.catalog) </span><span style="color:#BDC4CC;"># 13</span></span></code></pre></div><p>通过类对象可以访问类变量，但无法修改类变量的值。这是因为，通过类对象修改类变量的值，不是在给“类变量赋值”，而是定义新的实例变量。</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">clang </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> CLanguage()</span></span>
<span class="line"><span style="color:#BDC4CC;">#clang访问类变量</span></span>
<span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(clang.name) </span><span style="color:#BDC4CC;"># 小明</span></span>
<span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(clang.add) </span><span style="color:#BDC4CC;"># xiaoming</span></span>
<span class="line"><span style="color:#F0F3F6;">clang.name </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &quot;小红&quot;</span></span>
<span class="line"><span style="color:#F0F3F6;">clang.add </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &quot;xiaohong&quot;</span></span>
<span class="line"><span style="color:#BDC4CC;">#clang实例变量的值</span></span>
<span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(clang.name) </span><span style="color:#BDC4CC;"># 小红</span></span>
<span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(clang.add) </span><span style="color:#BDC4CC;"># xiaohong</span></span>
<span class="line"><span style="color:#BDC4CC;">#类变量的值</span></span>
<span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(CLanguage.name) </span><span style="color:#BDC4CC;"># 小明</span></span>
<span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(CLanguage.add) </span><span style="color:#BDC4CC;"># xiaoming</span></span></code></pre></div><p>显然，通过类对象是无法修改类变量的值的，本质其实是给<code>clang</code>对象新添加<code>name</code>和<code>add</code>这 2 个实例变量。</p><p>类中，实例变量和类变量可以同名，但这种情况下使用类对象将无法调用类变量，它会首选实例变量，这也是不推荐“类变量使用对象名调用”的原因。</p><p>另外，和类变量不同，通过某个对象修改实例变量的值，不会影响类的其它实例化对象，更不会影响同名的类变量。</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> CLanguage</span><span style="color:#F0F3F6;"> :</span></span>
<span class="line"><span style="color:#F0F3F6;">  name </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &quot;小明&quot;</span><span style="color:#BDC4CC;">  #类变量</span></span>
<span class="line"><span style="color:#F0F3F6;">  add </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &quot;xiaoming&quot;</span><span style="color:#BDC4CC;">  #类变量</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#91CBFF;"> __init__</span><span style="color:#F0F3F6;">(self):</span></span>
<span class="line"><span style="color:#91CBFF;">    self</span><span style="color:#F0F3F6;">.name </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &quot;小红&quot;</span><span style="color:#BDC4CC;">   #实例变量</span></span>
<span class="line"><span style="color:#91CBFF;">    self</span><span style="color:#F0F3F6;">.add </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &quot;xiaohong&quot;</span><span style="color:#BDC4CC;">   #实例变量</span></span>
<span class="line"><span style="color:#BDC4CC;">  # 下面定义了一个say实例方法</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#DBB7FF;"> say</span><span style="color:#F0F3F6;">(self):</span></span>
<span class="line"><span style="color:#91CBFF;">    self</span><span style="color:#F0F3F6;">.catalog </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 13</span><span style="color:#BDC4CC;">  #实例变量</span></span>
<span class="line"><span style="color:#F0F3F6;">clang </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> CLanguage()</span></span>
<span class="line"><span style="color:#BDC4CC;">#修改 clang 对象的实例变量</span></span>
<span class="line"><span style="color:#F0F3F6;">clang.name </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &quot;小李&quot;</span></span>
<span class="line"><span style="color:#F0F3F6;">clang.add </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &quot;xiaoli&quot;</span></span>
<span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(clang.name) </span><span style="color:#BDC4CC;"># 小李</span></span>
<span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(clang.add) </span><span style="color:#BDC4CC;"># xiaoli</span></span>
<span class="line"><span style="color:#F0F3F6;">clang2 </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> CLanguage()</span></span>
<span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(clang2.name) </span><span style="color:#BDC4CC;"># 小红</span></span>
<span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(clang2.add) </span><span style="color:#BDC4CC;"># xiaohong</span></span>
<span class="line"><span style="color:#BDC4CC;">#输出类变量的值</span></span>
<span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(CLanguage.name) </span><span style="color:#BDC4CC;"># 小明</span></span>
<span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(CLanguage.add) </span><span style="color:#BDC4CC;"># xiaoming</span></span></code></pre></div><p>不仅如此，Python 只支持为特定的对象添加实例变量。例如，在之前代码的基础上，为<code>clang</code>对象添加<code>money</code>实例变量：</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">clang.money </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 30</span></span>
<span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(clang.money)</span></span></code></pre></div><h2 id="局部变量" tabindex="-1"><a class="header-anchor" href="#局部变量"><span>局部变量</span></a></h2><p>除了实例变量，类方法中还可以定义局部变量。局部变量直接以“变量名=值”的方式进行定义：</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> CLanguage</span><span style="color:#F0F3F6;"> :</span></span>
<span class="line"><span style="color:#BDC4CC;">  # 下面定义了一个say实例方法</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#DBB7FF;"> count</span><span style="color:#F0F3F6;">(self,money):</span></span>
<span class="line"><span style="color:#F0F3F6;">    sale </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 0.8</span><span style="color:#FF9492;">*</span><span style="color:#F0F3F6;">money</span></span>
<span class="line"><span style="color:#91CBFF;">    print</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;优惠后的价格为：&quot;</span><span style="color:#F0F3F6;">,sale)</span></span>
<span class="line"><span style="color:#F0F3F6;">clang </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> CLanguage()</span></span>
<span class="line"><span style="color:#F0F3F6;">clang.count(</span><span style="color:#91CBFF;">100</span><span style="color:#F0F3F6;">)</span></span></code></pre></div><p>通常情况下，定义局部变量是为了所在类方法功能的实现。需要注意的一点是，局部变量只能用于所在函数中，函数执行完成后，局部变量也会被销毁。</p><h1 id="实例方法、静态方法和类方法" tabindex="-1"><a class="header-anchor" href="#实例方法、静态方法和类方法"><span>实例方法、静态方法和类方法</span></a></h1><p>类方法可分为类方法、实例方法和静态方法。采用<code>@classmethod</code>修饰的方法为类方法；采用<code>@staticmethod</code>修饰的方法为静态方法；不用任何修饰的方法为实例方法。</p><h2 id="类实例方法" tabindex="-1"><a class="header-anchor" href="#类实例方法"><span>类实例方法</span></a></h2><p>通常情况下，在类中定义的方法默认都是实例方法。类的构造方法理论上也属于实例方法，只不过它比较特殊。</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> CLanguage</span><span style="color:#F0F3F6;">:</span></span>
<span class="line"><span style="color:#BDC4CC;">  #类构造方法，也属于实例方法</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#91CBFF;"> __init__</span><span style="color:#F0F3F6;">(self):</span></span>
<span class="line"><span style="color:#91CBFF;">    self</span><span style="color:#F0F3F6;">.name </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &quot;小明&quot;</span></span>
<span class="line"><span style="color:#91CBFF;">    self</span><span style="color:#F0F3F6;">.add </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &quot;xiaoming&quot;</span></span>
<span class="line"><span style="color:#BDC4CC;">  # 下面定义了一个say实例方法</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#DBB7FF;"> say</span><span style="color:#F0F3F6;">(self):</span></span>
<span class="line"><span style="color:#91CBFF;">    print</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;正在调用 say() 实例方法&quot;</span><span style="color:#F0F3F6;">)</span></span></code></pre></div><p>实例方法最大的特点就是，它最少也要包含一个<code>self</code>参数，用于绑定调用此方法的实例对象（Python 会自动完成绑定）。实例方法通常会用类对象直接调用：</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">clang </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> CLanguage()</span></span>
<span class="line"><span style="color:#F0F3F6;">clang.say() </span><span style="color:#BDC4CC;"># 正在调用 say() 实例方法</span></span></code></pre></div><p>当然，Python 也支持使用类名调用实例方法，但此方式需要手动给<code>self</code>参数传值。</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">#类名调用实例方法，需手动给 self 参数传值</span></span>
<span class="line"><span style="color:#F0F3F6;">clang </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> CLanguage()</span></span>
<span class="line"><span style="color:#F0F3F6;">CLanguage.say(clang) </span><span style="color:#BDC4CC;"># 正在调用 say() 实例方法</span></span></code></pre></div><h2 id="类方法" tabindex="-1"><a class="header-anchor" href="#类方法"><span>类方法</span></a></h2><p>类方法和实例方法相似，它最少也要包含一个参数，只不过类方法中通常将其命名为<code>cls</code>，Python 会自动将类本身绑定给<code>cls</code>参数（注意，绑定的不是类对象）。也就是说，我们在调用类方法时，无需显式为<code>cls</code>参数传参。</p><p>和<code>self</code>一样，<code>cls</code>参数的命名也不是规定的（可以随意命名），只是 Python 程序员约定俗称的习惯而已。</p><p>和实例方法最大的不同在于，类方法需要使用<code>@classmethod</code>修饰符进行修饰：</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> CLanguage</span><span style="color:#F0F3F6;">:</span></span>
<span class="line"><span style="color:#BDC4CC;">  #类构造方法，也属于实例方法</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#91CBFF;"> __init__</span><span style="color:#F0F3F6;">(self):</span></span>
<span class="line"><span style="color:#91CBFF;">    self</span><span style="color:#F0F3F6;">.name </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &quot;小明&quot;</span></span>
<span class="line"><span style="color:#91CBFF;">    self</span><span style="color:#F0F3F6;">.add </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &quot;xiaoming&quot;</span></span>
<span class="line"><span style="color:#BDC4CC;">  #下面定义了一个类方法</span></span>
<span class="line"><span style="color:#DBB7FF;">  @</span><span style="color:#91CBFF;">classmethod</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#DBB7FF;"> info</span><span style="color:#F0F3F6;">(cls):</span></span>
<span class="line"><span style="color:#91CBFF;">    print</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;正在调用类方法&quot;</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">cls</span><span style="color:#F0F3F6;">)</span></span></code></pre></div><p>如果没有<code>＠classmethod</code>，则 Python 解释器会将<code>info()</code>方法认定为实例方法，而不是类方法。</p><p>类方法推荐使用类名直接调用，当然也可以使用实例对象来调用（不推荐）。</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">#使用类名直接调用类方法</span></span>
<span class="line"><span style="color:#F0F3F6;">CLanguage.info()</span></span>
<span class="line"><span style="color:#BDC4CC;">#使用类对象调用类方法</span></span>
<span class="line"><span style="color:#F0F3F6;">clang </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> CLanguage()</span></span>
<span class="line"><span style="color:#F0F3F6;">clang.info()</span></span></code></pre></div><h2 id="类静态方法" tabindex="-1"><a class="header-anchor" href="#类静态方法"><span>类静态方法</span></a></h2><p>静态方法，其实就是函数，和函数唯一的区别是，静态方法定义在类这个空间（类命名空间）中，而函数则定义在程序所在的空间（全局命名空间）中。</p><p>静态方法没有类似<code>self、cls</code>这样的特殊参数，因此 Python 解释器不会对它包含的参数做任何类或对象的绑定。也正因为如此，类的静态方法中无法调用任何类属性和类方法。</p><p>静态方法需要使用<code>@staticmethod</code>修饰：</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> CLanguage</span><span style="color:#F0F3F6;">:</span></span>
<span class="line"><span style="color:#DBB7FF;">  @</span><span style="color:#91CBFF;">staticmethod</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#DBB7FF;"> info</span><span style="color:#F0F3F6;">(name, add):</span></span>
<span class="line"><span style="color:#91CBFF;">    print</span><span style="color:#F0F3F6;">(name, add)</span></span></code></pre></div><p>静态方法的调用，既可以使用类名，也可以使用类对象：</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">#使用类名直接调用静态方法</span></span>
<span class="line"><span style="color:#F0F3F6;">CLanguage.info(</span><span style="color:#ADDCFF;">&quot;小明&quot;</span><span style="color:#F0F3F6;">, </span><span style="color:#ADDCFF;">&quot;xiaoming&quot;</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#BDC4CC;">#使用类对象调用静态方法</span></span>
<span class="line"><span style="color:#F0F3F6;">clang </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> CLanguage()</span></span>
<span class="line"><span style="color:#F0F3F6;">clang.info(</span><span style="color:#ADDCFF;">&quot;小红&quot;</span><span style="color:#F0F3F6;">, </span><span style="color:#ADDCFF;">&quot;xiaohong&quot;</span><span style="color:#F0F3F6;">)</span></span></code></pre></div><p>在实际编程中，几乎不会用到类方法和静态方法，因为我们完全可以使用函数代替它们实现想要的功能，但在一些特殊的场景中（例如工厂模式中），使用类方法和静态方法也是很不错的选择。</p><h1 id="类调用实例方法" tabindex="-1"><a class="header-anchor" href="#类调用实例方法"><span>类调用实例方法</span></a></h1><p>实例方法的调用方式有 2 种，既可以采用类对象调用，也可以直接通过类名调用。</p><p>通常情况下，我们习惯使用类对象调用类中的实例方法。但如果想用类调用实例方法，不能像如下这样：</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> CLanguage</span><span style="color:#F0F3F6;">:</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#DBB7FF;"> info</span><span style="color:#F0F3F6;">(self):</span></span>
<span class="line"><span style="color:#91CBFF;">    print</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;我正在学 Python&quot;</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#BDC4CC;">#通过类名直接调用实例方法</span></span>
<span class="line"><span style="color:#F0F3F6;">CLanguage.info()</span></span></code></pre></div><p>运行上面代码，程序会报出如下错误：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>Traceback (most recent call last):</span></span>
<span class="line"><span>  File &quot;D:\\python3.6\\demo.py&quot;, line 5, in &lt;module&gt;</span></span>
<span class="line"><span>    CLanguage.info()</span></span>
<span class="line"><span>TypeError: info() missing 1 required positional argument: &#39;self&#39;</span></span></code></pre></div><p>其中，最后一行报错信息提示我们，调用<code>info()</code>类方式时缺少给<code>self</code>参数传参。这意味着，和使用类对象调用实例方法不同，通过类名直接调用实例方法时，Python 并不会自动给<code>self</code>参数传值。</p><p><code>self</code>参数需要的是方法的实际调用者（是类对象），而这里只提供了类名，当然无法自动传值。</p><p>因此，如果想通过类名直接调用实例方法，就必须手动为<code>self</code>参数传值。</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> CLanguage</span><span style="color:#F0F3F6;">:</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#DBB7FF;"> info</span><span style="color:#F0F3F6;">(self):</span></span>
<span class="line"><span style="color:#91CBFF;">    print</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;我正在学 Python&quot;</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#F0F3F6;">clang </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> CLanguage()</span></span>
<span class="line"><span style="color:#BDC4CC;">#通过类名直接调用实例方法</span></span>
<span class="line"><span style="color:#F0F3F6;">CLanguage.info(clang)</span></span></code></pre></div><p>可以看到，通过手动将<code>clang</code>这个类对象传给了<code>self</code>参数，使得程序得以正确执行。实际上，这里调用实例方法的形式完全是等价于<code>clang.info()</code>。</p><p>值得一提的是，上面的报错信息只是让我们手动为<code>self</code>参数传值，但并没有规定必须传一个该类的对象，其实完全可以任意传入一个参数：</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> CLanguage</span><span style="color:#F0F3F6;">:</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#DBB7FF;"> info</span><span style="color:#F0F3F6;">(self):</span></span>
<span class="line"><span style="color:#91CBFF;">    print</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">self</span><span style="color:#F0F3F6;">,</span><span style="color:#ADDCFF;">&quot;正在学 Python&quot;</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#BDC4CC;">#通过类名直接调用实例方法</span></span>
<span class="line"><span style="color:#F0F3F6;">CLanguage.info(</span><span style="color:#ADDCFF;">&quot;zhangsan&quot;</span><span style="color:#F0F3F6;">)</span></span></code></pre></div><p>运行结果为：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>zhangsan 正在学 Python</span></span></code></pre></div><p>可以看到，<code>&quot;zhangsan&quot;</code>这个字符串传给了<code>info()</code>方法的<code>self</code>参数。显然，无论是<code>info()</code>方法中使用<code>self</code>参数调用其它类方法，还是使用<code>self</code>参数定义新的实例变量，胡乱的给<code>self</code>参数传参都将会导致程序运行崩溃。</p><p>总的来说，Python 中允许使用类名直接调用实例方法，但必须手动为该方法的第一个<code>self</code>参数传递参数，这种调用方法的方式被称为“非绑定方法”。</p><p>用类的实例对象访问类成员的方式称为绑定方法，而用类名调用类成员的方式称为非绑定方法。</p><h1 id="描述符" tabindex="-1"><a class="header-anchor" href="#描述符"><span>描述符</span></a></h1><p>通过使用描述符，可以让程序员在引用一个对象属性时自定义要完成的工作。</p><p>本质上看，描述符就是一个类，只不过它定义了另一个类中属性的访问方式。换句话说，一个类可以将属性管理全权委托给描述符类。</p><p>描述符是 Python 中复杂属性访问的基础，它在内部被用于实现 property、方法、类方法、静态方法和<code>super</code>类型。</p><p>描述符类基于以下 3 个特殊方法，换句话说，这 3 个方法组成了描述符协议：</p><ul><li><code>__set__(self, obj, type=None)</code>：在设置属性时将调用这一方法；</li><li><code>__get__(self, obj, value)</code>：在读取属性时将调用这一方法；</li><li><code>__delete__(self, obj)</code>：对属性调用<code>del</code>时将调用这一方法。</li></ul><p>其中，实现了<code>setter</code>和<code>getter</code>方法的描述符类被称为数据描述符；反之，如果只实现了<code>getter</code>方法，则称为非数据描述符。</p><p>实际上，在每次查找属性时，描述符协议中的方法都由类对象的特殊方法<code>__getattribute__()</code>调用（注意不要和<code>__getattr__()</code>弄混）。也就是说，每次使用类对象.属性（或者<code>getattr(类对象，属性值)</code>）的调用方式时，都会隐式地调用<code>__getattribute__()</code>，它会按照下列顺序查找该属性：</p><ul><li>验证该属性是否为类实例对象的数据描述符；</li><li>如果不是，就查看该属性是否能在类实例对象的<code>__dict__</code>中找到；</li><li>最后，查看该属性是否为类实例对象的非数据描述符。</li></ul><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">#描述符类</span></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> revealAccess</span><span style="color:#F0F3F6;">:</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#91CBFF;"> __init__</span><span style="color:#F0F3F6;">(self, initval </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> None</span><span style="color:#F0F3F6;">, name </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &#39;var&#39;</span><span style="color:#F0F3F6;">):</span></span>
<span class="line"><span style="color:#91CBFF;">    self</span><span style="color:#F0F3F6;">.val </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> initval</span></span>
<span class="line"><span style="color:#91CBFF;">    self</span><span style="color:#F0F3F6;">.name </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> name</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#91CBFF;"> __get__</span><span style="color:#F0F3F6;">(self, obj, objtype):</span></span>
<span class="line"><span style="color:#91CBFF;">    print</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;Retrieving&quot;</span><span style="color:#F0F3F6;">,</span><span style="color:#91CBFF;">self</span><span style="color:#F0F3F6;">.name)</span></span>
<span class="line"><span style="color:#FF9492;">    return</span><span style="color:#91CBFF;"> self</span><span style="color:#F0F3F6;">.val</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#91CBFF;"> __set__</span><span style="color:#F0F3F6;">(self, obj, val):</span></span>
<span class="line"><span style="color:#91CBFF;">    print</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;updating&quot;</span><span style="color:#F0F3F6;">,</span><span style="color:#91CBFF;">self</span><span style="color:#F0F3F6;">.name)</span></span>
<span class="line"><span style="color:#91CBFF;">    self</span><span style="color:#F0F3F6;">.val </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> val</span></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> myClass</span><span style="color:#F0F3F6;">:</span></span>
<span class="line"><span style="color:#F0F3F6;">  x </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> revealAccess(</span><span style="color:#91CBFF;">10</span><span style="color:#F0F3F6;">,</span><span style="color:#ADDCFF;">&#39;var &quot;x&quot;&#39;</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#F0F3F6;">  y </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 5</span></span>
<span class="line"><span style="color:#F0F3F6;">m </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> myClass()</span></span>
<span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(m.x)</span></span>
<span class="line"><span style="color:#F0F3F6;">m.x </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 20</span></span>
<span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(m.x)</span></span>
<span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(m.y)</span></span></code></pre></div><p>运行结果为：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>Retrieving var &quot;x&quot;</span></span>
<span class="line"><span>10</span></span>
<span class="line"><span>updating var &quot;x&quot;</span></span>
<span class="line"><span>Retrieving var &quot;x&quot;</span></span>
<span class="line"><span>20</span></span>
<span class="line"><span>5</span></span></code></pre></div><p>从这个例子可以看到，如果一个类的某个属性有数据描述符，那么每次查找这个属性时，都会调用描述符的<code>__get__()</code>方法，并返回它的值；同样，每次在对该属性赋值时，也会调用<code>__set__()</code>方法。</p><p>注意，虽然上面例子中没有使用<code>__del__()</code>方法，但也很容易理解，当每次使用<code>del</code>类对象.属性（或者 delattr(类对象，属性)）语句时，都会调用该方法。</p><h1 id="property-函数" tabindex="-1"><a class="header-anchor" href="#property-函数"><span>property()函数</span></a></h1><p>我们一直在用“类对象.属性”的方式访问类中定义的属性，其实这种做法是欠妥的，因为它破坏了类的封装原则。正常情况下，类包含的属性应该是隐藏的，只允许通过类提供的方法来间接实现对类属性的访问和操作。</p><p>因此，在不破坏类封装原则的基础上，为了能够有效操作类中的属性，类中应包含读（或写）类属性的多个<code>getter</code>（或<code>setter</code>）方法，这样就可以通过“类对象.方法(参数)”的方式操作属性：</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> CLanguage</span><span style="color:#F0F3F6;">:</span></span>
<span class="line"><span style="color:#BDC4CC;">  #构造函数</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#91CBFF;"> __init__</span><span style="color:#F0F3F6;">(self,name):</span></span>
<span class="line"><span style="color:#91CBFF;">    self</span><span style="color:#F0F3F6;">.name </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> name </span></span>
<span class="line"><span style="color:#BDC4CC;">  #设置 name 属性值的函数 </span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#DBB7FF;"> setname</span><span style="color:#F0F3F6;">(self,name):</span></span>
<span class="line"><span style="color:#91CBFF;">    self</span><span style="color:#F0F3F6;">.name </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> name</span></span>
<span class="line"><span style="color:#BDC4CC;">  #访问nema属性值的函数</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#DBB7FF;"> getname</span><span style="color:#F0F3F6;">(self):</span></span>
<span class="line"><span style="color:#FF9492;">    return</span><span style="color:#91CBFF;"> self</span><span style="color:#F0F3F6;">.name</span></span>
<span class="line"><span style="color:#BDC4CC;">  #删除name属性值的函数</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#DBB7FF;"> delname</span><span style="color:#F0F3F6;">(self):</span></span>
<span class="line"><span style="color:#91CBFF;">    self</span><span style="color:#F0F3F6;">.name</span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;">&quot;xxx&quot;</span></span>
<span class="line"><span style="color:#F0F3F6;">clang </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> CLanguage(</span><span style="color:#ADDCFF;">&quot;小明&quot;</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#BDC4CC;">#获取name属性值</span></span>
<span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(clang.getname()) </span><span style="color:#BDC4CC;"># 小明</span></span>
<span class="line"><span style="color:#BDC4CC;">#设置name属性值</span></span>
<span class="line"><span style="color:#F0F3F6;">clang.setname(</span><span style="color:#ADDCFF;">&quot;Python教程&quot;</span><span style="color:#F0F3F6;">) </span><span style="color:#BDC4CC;"># Python教程</span></span>
<span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(clang.getname())</span></span>
<span class="line"><span style="color:#BDC4CC;">#删除name属性值</span></span>
<span class="line"><span style="color:#F0F3F6;">clang.delname()</span></span>
<span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(clang.getname()) </span><span style="color:#BDC4CC;"># xxx</span></span></code></pre></div><p>Python 中提供了<code>property()</code>函数，可以实现在不破坏类封装原则的前提下，让开发者依旧使用“类对象.属性”的方式操作类中的属性。</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>属性名=property(fget=None, fset=None, fdel=None, doc=None)</span></span></code></pre></div><p>其中，<code>fget</code>参数用于指定获取该属性值的类方法，<code>fset</code>参数用于指定设置该属性值的方法，<code>fdel</code>参数用于指定删除该属性值的方法，最后的<code>doc</code>是一个文档字符串，用于说明此函数的作用。</p><p>注意，在使用<code>property()</code>函数时，以上 4 个参数可以仅指定第 1 个、或者前 2 个、或者前 3 个，当前也可以全部指定。也就是说，<code>property()</code>函数中参数的指定并不是完全随意的。</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> CLanguage</span><span style="color:#F0F3F6;">:</span></span>
<span class="line"><span style="color:#BDC4CC;">  #构造函数</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#91CBFF;"> __init__</span><span style="color:#F0F3F6;">(self,n):</span></span>
<span class="line"><span style="color:#91CBFF;">    self</span><span style="color:#F0F3F6;">.__name </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> n</span></span>
<span class="line"><span style="color:#BDC4CC;">  #设置 name 属性值的函数</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#DBB7FF;"> setname</span><span style="color:#F0F3F6;">(self,n):</span></span>
<span class="line"><span style="color:#91CBFF;">    self</span><span style="color:#F0F3F6;">.__name </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> n</span></span>
<span class="line"><span style="color:#BDC4CC;">  #访问nema属性值的函数</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#DBB7FF;"> getname</span><span style="color:#F0F3F6;">(self):</span></span>
<span class="line"><span style="color:#FF9492;">    return</span><span style="color:#91CBFF;"> self</span><span style="color:#F0F3F6;">.__name</span></span>
<span class="line"><span style="color:#BDC4CC;">  #删除name属性值的函数</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#DBB7FF;"> delname</span><span style="color:#F0F3F6;">(self):</span></span>
<span class="line"><span style="color:#91CBFF;">    self</span><span style="color:#F0F3F6;">.__name</span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;">&quot;xxx&quot;</span></span>
<span class="line"><span style="color:#BDC4CC;">  #为name 属性配置 property() 函数</span></span>
<span class="line"><span style="color:#F0F3F6;">  name </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> property</span><span style="color:#F0F3F6;">(getname, setname, delname, </span><span style="color:#ADDCFF;">&#39;指明出处&#39;</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#BDC4CC;">#调取说明文档的 2 种方式</span></span>
<span class="line"><span style="color:#BDC4CC;">#print(CLanguage.name.__doc__)</span></span>
<span class="line"><span style="color:#91CBFF;">help</span><span style="color:#F0F3F6;">(CLanguage.name)</span></span>
<span class="line"><span style="color:#F0F3F6;">clang </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> CLanguage(</span><span style="color:#ADDCFF;">&quot;小明&quot;</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#BDC4CC;">#调用 getname() 方法</span></span>
<span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(clang.name)</span></span>
<span class="line"><span style="color:#BDC4CC;">#调用 setname() 方法</span></span>
<span class="line"><span style="color:#F0F3F6;">clang.name</span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;">&quot;Python教程&quot;</span></span>
<span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(clang.name)</span></span>
<span class="line"><span style="color:#BDC4CC;">#调用 delname() 方法</span></span>
<span class="line"><span style="color:#FF9492;">del</span><span style="color:#F0F3F6;"> clang.name</span></span>
<span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(clang.name)</span></span></code></pre></div><p>运行结果为：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>Help on property:</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    指明出处</span></span>
<span class="line"><span></span></span>
<span class="line"><span>小明</span></span>
<span class="line"><span>Python教程</span></span>
<span class="line"><span>xxx</span></span></code></pre></div><p>注意，在此程序中，由于<code>getname()</code>方法中需要返回<code>name</code>属性，如果使用<code>self.name</code>的话，其本身又被调用<code>getname()</code>，这将会先入无限死循环。为了避免这种情况的出现，程序中的<code>name</code>属性必须设置为私有属性，即使用<code>__name</code>（前面有 2 个下划线）。</p><p>当然，<code>property()</code>函数也可以少传入几个参数。</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">name </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> property</span><span style="color:#F0F3F6;">(getname, setname)</span></span></code></pre></div><p>这意味着，<code>name</code>是一个可读写的属性，但不能删除，因为<code>property()</code>函数中并没有为<code>name</code>配置用于函数该属性的方法。也就是说，即便<code>CLanguage</code>类中设计有<code>delname()</code>函数，这种情况下也不能用来删除<code>name</code>属性。</p><p>同理，还可以像如下这样使用<code>property()</code>函数：</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">name </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> property</span><span style="color:#F0F3F6;">(getname) </span><span style="color:#BDC4CC;"># name 属性可读，不可写，也不能删除</span></span>
<span class="line"><span style="color:#F0F3F6;">name </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> property</span><span style="color:#F0F3F6;">(getname, setname,delname) </span><span style="color:#BDC4CC;"># name属性可读、可写、也可删除，就是没有说明文档</span></span></code></pre></div><h1 id="封装" tabindex="-1"><a class="header-anchor" href="#封装"><span>封装</span></a></h1><p>简单的理解封装，即在设计类时，刻意地将一些属性和方法隐藏在类的内部，这样在使用此类时，将无法直接以“类对象.属性名”（或者“类对象.方法名(参数)”）的形式调用这些属性（或方法），而只能用未隐藏的类方法间接操作这些隐藏的属性和方法。</p><p>封装机制保证了类内部数据结构的完整性，因为使用类的用户无法直接看到类中的数据结构，只能使用类允许公开的数据，很好地避免了外部对内部数据的影响，提高了程序的可维护性。</p><p>除此之外，对一个类实现良好的封装，用户只能借助暴露出来的类方法来访问数据，我们只需要在这些暴露的方法中加入适当的控制逻辑，即可轻松实现用户对类中属性或方法的不合理操作。</p><h2 id="python-类如何进行封装" tabindex="-1"><a class="header-anchor" href="#python-类如何进行封装"><span>Python 类如何进行封装</span></a></h2><p>Python 类中的变量和函数，不是公有的（类似<code>public</code>属性），就是私有的（类似<code>private</code>）。</p><p>但是，Python 并没有提供<code>public、private</code>这些修饰符。为了实现类的封装，Python 采取了下面的方法：</p><ul><li>默认情况下，Python 类中的变量和方法都是公有的，它们的名称前都没有下划线（<code>_</code>）；</li><li>如果类中的变量和函数，其名称以双下划线<code>__</code>开头，则该变量（函数）为私有变量（私有函数）。</li></ul><p>除此之外，还可以定义以单下划线<code>_</code>开头的类属性或者类方法（例如<code>_name、_display(self)</code>），这种类属性和类方法通常被视为私有属性和私有方法，虽然它们也能通过类对象正常访问，但这是一种约定俗称的用法。</p><blockquote><p>注意，Python 类中还有以双下划线开头和结尾的类方法（例如类的构造函数<code>__init__(self)</code>），这些都是 Python 内部定义的，用于 Python 内部调用。我们自己定义类属性或者类方法时，不要使用这种格式。</p></blockquote><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> CLanguage</span><span style="color:#F0F3F6;"> :</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#DBB7FF;"> setname</span><span style="color:#F0F3F6;">(self, name):</span></span>
<span class="line"><span style="color:#FF9492;">    if</span><span style="color:#91CBFF;"> len</span><span style="color:#F0F3F6;">(name) </span><span style="color:#FF9492;">&lt;</span><span style="color:#91CBFF;"> 1</span><span style="color:#F0F3F6;">:</span></span>
<span class="line"><span style="color:#FF9492;">      raise</span><span style="color:#91CBFF;"> ValueError</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;名称长度必须大于1！&#39;</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#91CBFF;">    self</span><span style="color:#F0F3F6;">.__name </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> name</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#DBB7FF;"> getname</span><span style="color:#F0F3F6;">(self):</span></span>
<span class="line"><span style="color:#FF9492;">    return</span><span style="color:#91CBFF;"> self</span><span style="color:#F0F3F6;">.__name</span></span>
<span class="line"><span style="color:#BDC4CC;">  #为 name 配置 setter 和 getter 方法</span></span>
<span class="line"><span style="color:#F0F3F6;">  name </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> property</span><span style="color:#F0F3F6;">(getname, setname)</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#DBB7FF;"> setadd</span><span style="color:#F0F3F6;">(self, add):</span></span>
<span class="line"><span style="color:#FF9492;">    if</span><span style="color:#F0F3F6;"> add.startswith(</span><span style="color:#ADDCFF;">&quot;http://&quot;</span><span style="color:#F0F3F6;">):</span></span>
<span class="line"><span style="color:#91CBFF;">      self</span><span style="color:#F0F3F6;">.__add </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> add</span></span>
<span class="line"><span style="color:#FF9492;">    else</span><span style="color:#F0F3F6;">:</span></span>
<span class="line"><span style="color:#FF9492;">      raise</span><span style="color:#91CBFF;"> ValueError</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;地址必须以 http:// 开头&#39;</span><span style="color:#F0F3F6;">) </span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#DBB7FF;"> getadd</span><span style="color:#F0F3F6;">(self):</span></span>
<span class="line"><span style="color:#FF9492;">    return</span><span style="color:#91CBFF;"> self</span><span style="color:#F0F3F6;">.__add</span></span>
<span class="line"><span style="color:#F0F3F6;">  </span></span>
<span class="line"><span style="color:#BDC4CC;">  #为 add 配置 setter 和 getter 方法</span></span>
<span class="line"><span style="color:#F0F3F6;">  add </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> property</span><span style="color:#F0F3F6;">(getadd, setadd)</span></span>
<span class="line"><span style="color:#BDC4CC;">  #定义个私有方法</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#DBB7FF;"> __display</span><span style="color:#F0F3F6;">(self):</span></span>
<span class="line"><span style="color:#91CBFF;">    print</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">self</span><span style="color:#F0F3F6;">.__name,</span><span style="color:#91CBFF;">self</span><span style="color:#F0F3F6;">.__add)</span></span>
<span class="line"><span style="color:#F0F3F6;">clang </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> CLanguage()</span></span>
<span class="line"><span style="color:#F0F3F6;">clang.name </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &quot;百度&quot;</span></span>
<span class="line"><span style="color:#F0F3F6;">clang.add </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &quot;http://www.baidu.com&quot;</span></span>
<span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(clang.name) </span><span style="color:#BDC4CC;"># 百度</span></span>
<span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(clang.add) </span><span style="color:#BDC4CC;"># http://www.baidu.com</span></span></code></pre></div><p>上面程序中，<code>CLanguage</code>将<code>name</code>和<code>add</code>属性都隐藏了起来，但同时也提供了可操作它们的“窗口”，也就是各自的<code>setter</code>和<code>getter</code>方法，这些方法都是公有的。</p><p>不仅如此，以<code>add</code>属性的<code>setadd()</code>方法为例，通过在该方法内部添加控制逻辑，即通过调用<code>startswith()</code>方法，控制用户输入的地址必须以<code>http://</code>开头，否则程序将会执行<code>raise</code>语句抛出<code>ValueError</code>异常。</p><p>通过此程序的运行逻辑不难看出，通过对<code>CLanguage</code>类进行良好的封装，使得用户仅能通过暴露的<code>setter()</code>和<code>getter()</code>方法操作<code>name</code>和<code>add</code>属性，而通过对<code>setname()</code>和<code>setadd()</code>方法进行适当的设计，可以避免用户对类中属性的不合理操作，从而提高了类的可维护性和安全性。</p><p><code>CLanguage</code>类中还有一个<code>__display()</code>方法，由于该类方法为私有（<code>private</code>）方法，且该类没有提供操作该私有方法的“窗口”，因此我们无法在类的外部使用它。换句话说，如下调用<code>__display()</code>方法是不可行的：</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">#尝试调用私有的 display() 方法</span></span>
<span class="line"><span style="color:#F0F3F6;">clang.__display()</span></span></code></pre></div><p>这会导致如下错误：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>Traceback (most recent call last):</span></span>
<span class="line"><span>  File &quot;D:\\python3.6\\1.py&quot;, line 33, in &lt;module&gt;</span></span>
<span class="line"><span>    clang.__display()</span></span>
<span class="line"><span>AttributeError: &#39;CLanguage&#39; object has no attribute &#39;__display&#39;</span></span></code></pre></div><h1 id="继承" tabindex="-1"><a class="header-anchor" href="#继承"><span>继承</span></a></h1><p>继承机制经常用于创建和现有类功能类似的新类，又或是新类只需要在现有类基础上添加一些成员（属性和方法），但又不想直接将现有类代码复制给新类。也就是说，通过使用继承这种机制，可以轻松实现类的重复使用。</p><p>举个例子，假设现有一个<code>Shape</code>类，该类的<code>draw()</code>方法可以在屏幕上画出指定的形状，现在需要创建一个<code>Form</code>类，要求此类不但可以在屏幕上画出指定的形状，还可以计算出所画形状的面积。要创建这样的类，笨方法是将<code>draw()</code>方法直接复制到新类中，并添加计算面积的方法。</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Shape</span><span style="color:#F0F3F6;">:</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#DBB7FF;"> draw</span><span style="color:#F0F3F6;">(self,content):</span></span>
<span class="line"><span style="color:#91CBFF;">    print</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;画&quot;</span><span style="color:#F0F3F6;">,content)</span></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Form</span><span style="color:#F0F3F6;">:</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#DBB7FF;"> draw</span><span style="color:#F0F3F6;">(self,content):</span></span>
<span class="line"><span style="color:#91CBFF;">    print</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;画&quot;</span><span style="color:#F0F3F6;">,content)</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#DBB7FF;"> area</span><span style="color:#F0F3F6;">(self):</span></span>
<span class="line"><span style="color:#BDC4CC;">    #....</span></span>
<span class="line"><span style="color:#91CBFF;">    print</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;此图形的面积为...&quot;</span><span style="color:#F0F3F6;">)</span></span></code></pre></div><p>当然还有更简单的方法，就是使用类的继承机制。实现方法为：让<code>Form</code>类继承<code>Shape</code>类，这样当<code>Form</code>类对象调用<code>draw()</code>方法时，Python 解释器会先去 Form 中找以<code>draw</code>为名的方法，如果找不到，它还会自动去<code>Shape</code>类中找。如此，我们只需在<code>Form</code>类中添加计算面积的方法即可：</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Shape</span><span style="color:#F0F3F6;">:</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#DBB7FF;"> draw</span><span style="color:#F0F3F6;">(self,content):</span></span>
<span class="line"><span style="color:#91CBFF;">    print</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;画&quot;</span><span style="color:#F0F3F6;">,content)</span></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Form</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">Shape</span><span style="color:#F0F3F6;">):</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#DBB7FF;"> area</span><span style="color:#F0F3F6;">(self):</span></span>
<span class="line"><span style="color:#BDC4CC;">    #....</span></span>
<span class="line"><span style="color:#91CBFF;">    print</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;此图形的面积为...&quot;</span><span style="color:#F0F3F6;">)</span></span></code></pre></div><p>上面代码中，<code>class Form(Shape)</code>就表示<code>Form</code>继承<code>Shape</code>。</p><p>Python 中，实现继承的类称为子类，被继承的类称为父类（也可称为基类、超类）。因此在上面这个样例中，<code>Form</code>是子类，<code>Shape</code>是父类。</p><p>子类继承父类时，只需在定义子类时，将父类（可以是多个）放在子类之后的圆括号里即可。</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#F0F3F6;"> 类名(父类1, 父类2, </span><span style="color:#91CBFF;">...</span><span style="color:#F0F3F6;">)：</span></span>
<span class="line"><span style="color:#BDC4CC;">  #类定义部分</span></span></code></pre></div><p>注意，如果该类没有显式指定继承自哪个类，则默认继承 object 类（object 类是 Python 中所有类的父类，即要么是直接父类，要么是间接父类）。另外，Python 的继承是多继承机制（和 C++ 一样），即一个子类可以同时拥有多个直接父类。</p><p>“派生”和继承是一个意思，只是观察角度不同而已。换句话说，继承是相对子类来说的，即子类继承自父类；而派生是相对于父类来说的，即父类派生出子类。</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> People</span><span style="color:#F0F3F6;">:</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#DBB7FF;"> say</span><span style="color:#F0F3F6;">(self):</span></span>
<span class="line"><span style="color:#91CBFF;">    print</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;我是一个人，名字是：&quot;</span><span style="color:#F0F3F6;">,</span><span style="color:#91CBFF;">self</span><span style="color:#F0F3F6;">.name)</span></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Animal</span><span style="color:#F0F3F6;">:</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#DBB7FF;"> display</span><span style="color:#F0F3F6;">(self):</span></span>
<span class="line"><span style="color:#91CBFF;">    print</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;人也是高级动物&quot;</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#BDC4CC;">#同时继承 People 和 Animal 类</span></span>
<span class="line"><span style="color:#BDC4CC;">#其同时拥有 name 属性、say() 和 display() 方法</span></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Person</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">People</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">Animal</span><span style="color:#F0F3F6;">):</span></span>
<span class="line"><span style="color:#FF9492;">  pass</span></span>
<span class="line"><span style="color:#F0F3F6;">zhangsan </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> Person()</span></span>
<span class="line"><span style="color:#F0F3F6;">zhangsan.name </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &quot;张三&quot;</span></span>
<span class="line"><span style="color:#F0F3F6;">zhangsan.say()</span></span>
<span class="line"><span style="color:#F0F3F6;">zhangsan.display()</span></span></code></pre></div><p>运行结果为：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>我是一个人，名字是： 张三</span></span>
<span class="line"><span>人也是高级动物</span></span></code></pre></div><p>可以看到，虽然 Person 类为空类，但由于其继承自 People 和 Animal 这 2 个类，因此实际上 Person 并不空，它同时拥有这 2 个类所有的属性和方法。<br> 没错，子类拥有父类所有的属性和方法，即便该属性或方法是私有（private）的。</p><h2 id="关于python的多继承" tabindex="-1"><a class="header-anchor" href="#关于python的多继承"><span>关于Python的多继承</span></a></h2><p>事实上，大部分面向对象的编程语言，都只支持单继承，即子类有且只能有一个父类。而 Python 却支持多继承（C++也支持多继承）。<br> 和单继承相比，多继承容易让代码逻辑复杂、思路混乱，一直备受争议，中小型项目中较少使用，后来的 Java、C#、PHP 等干脆取消了多继承。</p><p>使用多继承经常需要面临的问题是，多个父类中包含同名的类方法。对于这种情况，Python 的处置措施是：根据子类继承多个父类时这些父类的前后次序决定，即排在前面父类中的类方法会覆盖排在后面父类中的同名类方法。</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> People</span><span style="color:#F0F3F6;">:</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#91CBFF;"> __init__</span><span style="color:#F0F3F6;">(self):</span></span>
<span class="line"><span style="color:#91CBFF;">    self</span><span style="color:#F0F3F6;">.name </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> People</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#DBB7FF;"> say</span><span style="color:#F0F3F6;">(self):</span></span>
<span class="line"><span style="color:#91CBFF;">    print</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;People类&quot;</span><span style="color:#F0F3F6;">,</span><span style="color:#91CBFF;">self</span><span style="color:#F0F3F6;">.name)</span></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Animal</span><span style="color:#F0F3F6;">:</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#91CBFF;"> __init__</span><span style="color:#F0F3F6;">(self):</span></span>
<span class="line"><span style="color:#91CBFF;">    self</span><span style="color:#F0F3F6;">.name </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> Animal</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#DBB7FF;"> say</span><span style="color:#F0F3F6;">(self):</span></span>
<span class="line"><span style="color:#91CBFF;">    print</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;Animal类&quot;</span><span style="color:#F0F3F6;">,</span><span style="color:#91CBFF;">self</span><span style="color:#F0F3F6;">.name)</span></span>
<span class="line"><span style="color:#BDC4CC;">#People中的 name 属性和 say() 会遮蔽 Animal 类中的</span></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Person</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">People</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">Animal</span><span style="color:#F0F3F6;">):</span></span>
<span class="line"><span style="color:#FF9492;">  pass</span></span>
<span class="line"><span style="color:#F0F3F6;">zhangsan </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> Person()</span></span>
<span class="line"><span style="color:#F0F3F6;">zhangsan.name </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &quot;张三&quot;</span></span>
<span class="line"><span style="color:#F0F3F6;">zhangsan.say()</span></span></code></pre></div><p>程序运行结果为：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>People类 张三</span></span></code></pre></div><p>可以看到，当<code>Person</code>同时继承<code>People</code>类和<code>Animal</code>类时，<code>People</code>类在前，因此如果<code>People</code>和<code>Animal</code>拥有同名的类方法，实际调用的是<code>People</code>类中的。</p><h1 id="父类方法重写" tabindex="-1"><a class="header-anchor" href="#父类方法重写"><span>父类方法重写</span></a></h1><p>在 Python 中，子类继承了父类，那么子类就拥有了父类所有的类属性和类方法。通常情况下，子类会在此基础上，扩展一些新的类属性和类方法。</p><p>但凡事都有例外，我们可能会遇到这样一种情况，即子类从父类继承得来的类方法中，大部分是适合子类使用的，但有个别的类方法，并不能直接照搬父类的，如果不对这部分类方法进行修改，子类对象无法使用。针对这种情况，我们就需要在子类中重复父类的方法。</p><p>举个例子，鸟通常是有翅膀的，也会飞，因此我们可以像如下这样定义个和鸟相关的类：</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Bird</span><span style="color:#F0F3F6;">:</span></span>
<span class="line"><span style="color:#BDC4CC;">  #鸟有翅膀</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#DBB7FF;"> isWing</span><span style="color:#F0F3F6;">(self):</span></span>
<span class="line"><span style="color:#91CBFF;">    print</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;鸟有翅膀&quot;</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#BDC4CC;">  #鸟会飞</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#DBB7FF;"> fly</span><span style="color:#F0F3F6;">(self):</span></span>
<span class="line"><span style="color:#91CBFF;">    print</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;鸟会飞&quot;</span><span style="color:#F0F3F6;">)</span></span></code></pre></div><p>但是，对于鸵鸟来说，它虽然也属于鸟类，也有翅膀，但是它只会奔跑，并不会飞。针对这种情况，可以这样定义鸵鸟类：</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Ostrich</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">Bird</span><span style="color:#F0F3F6;">):</span></span>
<span class="line"><span style="color:#BDC4CC;">  # 重写Bird类的fly()方法</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#DBB7FF;"> fly</span><span style="color:#F0F3F6;">(self):</span></span>
<span class="line"><span style="color:#91CBFF;">    print</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;鸵鸟不会飞&quot;</span><span style="color:#F0F3F6;">)</span></span></code></pre></div><p>可以看到，因为<code>Ostrich</code>继承自<code>Bird</code>，因此<code>Ostrich</code>类拥有<code>Bird</code>类的<code>isWing()</code>和<code>fly()</code>方法。其中，<code>isWing()</code>方法同样适合<code>Ostrich</code>，但<code>fly()</code>明显不适合，因此我们在<code>Ostrich</code>类中对<code>fly()</code>方法进行重写。</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Bird</span><span style="color:#F0F3F6;">:</span></span>
<span class="line"><span style="color:#BDC4CC;">  #鸟有翅膀</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#DBB7FF;"> isWing</span><span style="color:#F0F3F6;">(self):</span></span>
<span class="line"><span style="color:#91CBFF;">    print</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;鸟有翅膀&quot;</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#BDC4CC;">  #鸟会飞</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#DBB7FF;"> fly</span><span style="color:#F0F3F6;">(self):</span></span>
<span class="line"><span style="color:#91CBFF;">    print</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;鸟会飞&quot;</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Ostrich</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">Bird</span><span style="color:#F0F3F6;">):</span></span>
<span class="line"><span style="color:#BDC4CC;">  # 重写Bird类的fly()方法</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#DBB7FF;"> fly</span><span style="color:#F0F3F6;">(self):</span></span>
<span class="line"><span style="color:#91CBFF;">    print</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;鸵鸟不会飞&quot;</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#BDC4CC;"># 创建Ostrich对象</span></span>
<span class="line"><span style="color:#F0F3F6;">ostrich </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> Ostrich()</span></span>
<span class="line"><span style="color:#BDC4CC;">#调用 Ostrich 类中重写的 fly() 类方法</span></span>
<span class="line"><span style="color:#F0F3F6;">ostrich.fly()</span></span></code></pre></div><p>运行结果为：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>鸵鸟不会飞</span></span></code></pre></div><p>显然，<code>ostrich</code>调用的是重写之后的<code>fly()</code>类方法。</p><h2 id="如何调用被重写的方法" tabindex="-1"><a class="header-anchor" href="#如何调用被重写的方法"><span>如何调用被重写的方法</span></a></h2><p>事实上，如果我们在子类中重写了从父类继承来的类方法，那么当在类的外部通过子类对象调用该方法时，Python 总是会执行子类中重写的方法。</p><p>这就产生一个新的问题，即如果想调用父类中被重写的这个方法，该怎么办呢？</p><p>Python 中的类可以看做是一个独立空间，而类方法其实就是出于该空间中的一个函数。而如果想要全局空间中，调用类空间中的函数，只需要在调用该函数时备注类名即可。</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Bird</span><span style="color:#F0F3F6;">:</span></span>
<span class="line"><span style="color:#BDC4CC;">  #鸟有翅膀</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#DBB7FF;"> isWing</span><span style="color:#F0F3F6;">(self):</span></span>
<span class="line"><span style="color:#91CBFF;">    print</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;鸟有翅膀&quot;</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#BDC4CC;">  #鸟会飞</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#DBB7FF;"> fly</span><span style="color:#F0F3F6;">(self):</span></span>
<span class="line"><span style="color:#91CBFF;">    print</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;鸟会飞&quot;</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Ostrich</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">Bird</span><span style="color:#F0F3F6;">):</span></span>
<span class="line"><span style="color:#BDC4CC;">  # 重写Bird类的fly()方法</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#DBB7FF;"> fly</span><span style="color:#F0F3F6;">(self):</span></span>
<span class="line"><span style="color:#91CBFF;">    print</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;鸵鸟不会飞&quot;</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#BDC4CC;"># 创建Ostrich对象</span></span>
<span class="line"><span style="color:#F0F3F6;">ostrich </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> Ostrich()</span></span>
<span class="line"><span style="color:#BDC4CC;">#调用 Bird 类中的 fly() 方法</span></span>
<span class="line"><span style="color:#F0F3F6;">Bird.fly(ostrich)</span></span></code></pre></div><p>程序运行结果为：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>鸟会飞</span></span></code></pre></div><p>此程序中，需要大家注意的一点是，使用类名调用其类方法，Python 不会为该方法的第一个<code>self</code>参数自定绑定值，因此采用这种调用方法，需要手动为<code>self</code>参数赋值。</p><p>通过类名调用实例方法的这种方式，又被称为未绑定方法。</p><h1 id="super-函数" tabindex="-1"><a class="header-anchor" href="#super-函数"><span>super()函数</span></a></h1><p>Python 中子类会继承父类所有的类属性和类方法。严格来说，类的构造方法其实就是实例方法，因此毫无疑问，父类的构造方法，子类同样会继承。</p><p>但我们知道，Python 支持多继承，如果子类继承的多个父类中包含同名的类实例方法，则子类对象在调用该方法时，会优先选择排在最前面的父类中的实例方法。显然，构造方法也是如此。</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> People</span><span style="color:#F0F3F6;">:</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#91CBFF;"> __init__</span><span style="color:#F0F3F6;">(self,name):</span></span>
<span class="line"><span style="color:#91CBFF;">    self</span><span style="color:#F0F3F6;">.name </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> name</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#DBB7FF;"> say</span><span style="color:#F0F3F6;">(self):</span></span>
<span class="line"><span style="color:#91CBFF;">    print</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;我是人，名字为：&quot;</span><span style="color:#F0F3F6;">,</span><span style="color:#91CBFF;">self</span><span style="color:#F0F3F6;">.name)</span></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Animal</span><span style="color:#F0F3F6;">:</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#91CBFF;"> __init__</span><span style="color:#F0F3F6;">(self,food):</span></span>
<span class="line"><span style="color:#91CBFF;">    self</span><span style="color:#F0F3F6;">.food </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> food</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#DBB7FF;"> display</span><span style="color:#F0F3F6;">(self):</span></span>
<span class="line"><span style="color:#91CBFF;">    print</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;我是动物,我吃&quot;</span><span style="color:#F0F3F6;">,</span><span style="color:#91CBFF;">self</span><span style="color:#F0F3F6;">.food)</span></span>
<span class="line"><span style="color:#BDC4CC;">#People中的 name 属性和 say() 会遮蔽 Animal 类中的</span></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Person</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">People</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">Animal</span><span style="color:#F0F3F6;">):</span></span>
<span class="line"><span style="color:#FF9492;">  pass</span></span>
<span class="line"><span style="color:#F0F3F6;">per </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> Person(</span><span style="color:#ADDCFF;">&quot;zhangsan&quot;</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#F0F3F6;">per.say()</span></span>
<span class="line"><span style="color:#BDC4CC;">#per.display()</span></span></code></pre></div><p>运行结果，结果为：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>我是人，名字为： zhangsan</span></span></code></pre></div><p>上面程序中，Person 类同时继承 People 和 Animal，其中 People 在前。这意味着，在创建 per 对象时，其将会调用从 People 继承来的构造函数。因此我们看到，上面程序在创建 per 对象的同时，还要给 name 属性进行赋值。</p><p>但如果去掉最后一行的注释，运行此行代码，Python 解释器会报如下错误：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>Traceback (most recent call last):</span></span>
<span class="line"><span>  File &quot;D:\\python3.6\\Demo.py&quot;, line 18, in &lt;module&gt;</span></span>
<span class="line"><span>    per.display()</span></span>
<span class="line"><span>  File &quot;D:\\python3.6\\Demo.py&quot;, line 11, in display</span></span>
<span class="line"><span>    print(&quot;我是动物,我吃&quot;,self.food)</span></span>
<span class="line"><span>AttributeError: &#39;Person&#39; object has no attribute &#39;food&#39;</span></span></code></pre></div><p>这是因为，从 Animal 类中继承的 display() 方法中，需要用到 food 属性的值，但由于 People 类的构造方法“遮蔽”了Animal 类的构造方法，使得在创建 per 对象时，Animal 类的构造方法未得到执行，所以程序出错。</p><p>反过来也是如此，如果将第 13 行代码改为如下形式：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>class Person(Animal, People)</span></span></code></pre></div><p>则在创建 per 对象时，会给 food 属性传值。这意味着，per.display() 能顺序执行，但 per.say() 将会报错。</p><p>针对这种情况，正确的做法是定义 Person 类自己的构造方法（等同于重写第一个直接父类的构造方法）。但需要注意，如果在子类中定义构造方法，则必须在该方法中调用父类的构造方法。</p><p>在子类中的构造方法中，调用父类构造方法的方式有 2 种，分别是：</p><ul><li>类可以看做一个独立空间，在类的外部调用其中的实例方法，可以向调用普通函数那样，只不过需要额外备注类名（此方式又称为未绑定方法）；</li><li>使用 super() 函数。但如果涉及多继承，该函数只能调用第一个直接父类的构造方法。</li></ul><p>也就是说，涉及到多继承时，在子类构造函数中，调用第一个父类构造方法的方式有以上 2 种，而调用其它父类构造方法的方式只能使用未绑定方法。</p><p>在 Python 3.x 中，<code>super()</code>函数的语法格式：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>super().__init__(...)</span></span></code></pre></div><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> People</span><span style="color:#F0F3F6;">:</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#91CBFF;"> __init__</span><span style="color:#F0F3F6;">(self,name):</span></span>
<span class="line"><span style="color:#91CBFF;">    self</span><span style="color:#F0F3F6;">.name </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> name</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#DBB7FF;"> say</span><span style="color:#F0F3F6;">(self):</span></span>
<span class="line"><span style="color:#91CBFF;">    print</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;我是人，名字为：&quot;</span><span style="color:#F0F3F6;">,</span><span style="color:#91CBFF;">self</span><span style="color:#F0F3F6;">.name)</span></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Animal</span><span style="color:#F0F3F6;">:</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#91CBFF;"> __init__</span><span style="color:#F0F3F6;">(self,food):</span></span>
<span class="line"><span style="color:#91CBFF;">    self</span><span style="color:#F0F3F6;">.food </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> food</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#DBB7FF;"> display</span><span style="color:#F0F3F6;">(self):</span></span>
<span class="line"><span style="color:#91CBFF;">    print</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;我是动物,我吃&quot;</span><span style="color:#F0F3F6;">,</span><span style="color:#91CBFF;">self</span><span style="color:#F0F3F6;">.food)</span></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Person</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">People</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">Animal</span><span style="color:#F0F3F6;">):</span></span>
<span class="line"><span style="color:#BDC4CC;">  #自定义构造方法</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#91CBFF;"> __init__</span><span style="color:#F0F3F6;">(self,name,food):</span></span>
<span class="line"><span style="color:#BDC4CC;">    #调用 People 类的构造方法</span></span>
<span class="line"><span style="color:#91CBFF;">    super</span><span style="color:#F0F3F6;">().</span><span style="color:#91CBFF;">__init__</span><span style="color:#F0F3F6;">(name)</span></span>
<span class="line"><span style="color:#BDC4CC;">    #super(Person,self).__init__(name) #执行效果和上一行相同</span></span>
<span class="line"><span style="color:#BDC4CC;">    #People.__init__(self,name)#使用未绑定方法调用 People 类构造方法</span></span>
<span class="line"><span style="color:#BDC4CC;">    #调用其它父类的构造方法，需手动给 self 传值</span></span>
<span class="line"><span style="color:#F0F3F6;">    Animal.</span><span style="color:#91CBFF;">__init__</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">self</span><span style="color:#F0F3F6;">,food)    </span></span>
<span class="line"><span style="color:#F0F3F6;">per </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> Person(</span><span style="color:#ADDCFF;">&quot;zhangsan&quot;</span><span style="color:#F0F3F6;">,</span><span style="color:#ADDCFF;">&quot;熟食&quot;</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#F0F3F6;">per.say() </span><span style="color:#BDC4CC;"># 我是人，名字为： zhangsan</span></span>
<span class="line"><span style="color:#F0F3F6;">per.display() </span><span style="color:#BDC4CC;"># 我是动物,我吃 熟食</span></span></code></pre></div><p>可以看到，<code>Person</code>类自定义的构造方法中，调用<code>People</code>类构造方法，可以使用<code>super()</code>函数，也可以使用未绑定方法。但是调用<code>Animal</code>类的构造方法，只能使用未绑定方法。</p><h1 id="slots-限制类实例动态添加属性和方法" tabindex="-1"><a class="header-anchor" href="#slots-限制类实例动态添加属性和方法"><span><strong>slots</strong>：限制类实例动态添加属性和方法</span></a></h1><p>了解了如何动态的为单个实例对象添加属性，甚至如果必要的话，还可以为所有的类实例对象统一添加属性（通过给类添加属性）。</p><p>那么，Python 是否也允许动态地为类或实例对象添加方法呢？答案是肯定的。我们知道，类方法又可细分为实例方法、静态方法和类方法，Python 语言允许为类动态地添加这 3 种方法；但对于实例对象，则只允许动态地添加实例方法，不能添加类方法和静态方法。</p><p>为单个实例对象添加方法，不会影响该类的其它实例对象；而如果为类动态地添加方法，则所有的实例对象都可以使用。</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> CLanguage</span><span style="color:#F0F3F6;">:</span></span>
<span class="line"><span style="color:#FF9492;">    pass</span></span>
<span class="line"><span style="color:#BDC4CC;">#下面定义了一个实例方法</span></span>
<span class="line"><span style="color:#FF9492;">def</span><span style="color:#DBB7FF;"> info</span><span style="color:#F0F3F6;">(self):</span></span>
<span class="line"><span style="color:#91CBFF;">    print</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;正在调用实例方法&quot;</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#BDC4CC;">#下面定义了一个类方法</span></span>
<span class="line"><span style="color:#DBB7FF;">@</span><span style="color:#91CBFF;">classmethod</span></span>
<span class="line"><span style="color:#FF9492;">def</span><span style="color:#DBB7FF;"> info2</span><span style="color:#F0F3F6;">(cls):</span></span>
<span class="line"><span style="color:#91CBFF;">    print</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;正在调用类方法&quot;</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#BDC4CC;">#下面定义个静态方法</span></span>
<span class="line"><span style="color:#DBB7FF;">@</span><span style="color:#91CBFF;">staticmethod</span></span>
<span class="line"><span style="color:#FF9492;">def</span><span style="color:#DBB7FF;"> info3</span><span style="color:#F0F3F6;">():</span></span>
<span class="line"><span style="color:#91CBFF;">    print</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;正在调用静态方法&quot;</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#BDC4CC;">#类可以动态添加以上 3 种方法，会影响所有实例对象</span></span>
<span class="line"><span style="color:#F0F3F6;">CLanguage.info </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> info</span></span>
<span class="line"><span style="color:#F0F3F6;">CLanguage.info2 </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> info2</span></span>
<span class="line"><span style="color:#F0F3F6;">CLanguage.info3 </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> info3</span></span>
<span class="line"><span style="color:#F0F3F6;">clang </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> CLanguage()</span></span>
<span class="line"><span style="color:#BDC4CC;">#如今，clang 具有以上 3 种方法</span></span>
<span class="line"><span style="color:#F0F3F6;">clang.info()</span></span>
<span class="line"><span style="color:#F0F3F6;">clang.info2()</span></span>
<span class="line"><span style="color:#F0F3F6;">clang.info3()</span></span>
<span class="line"><span style="color:#BDC4CC;">#类实例对象只能动态添加实例方法，不会影响其它实例对象</span></span>
<span class="line"><span style="color:#F0F3F6;">clang1 </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> CLanguage()</span></span>
<span class="line"><span style="color:#F0F3F6;">clang1.info </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> info</span></span>
<span class="line"><span style="color:#BDC4CC;">#必须手动为 self 传值</span></span>
<span class="line"><span style="color:#F0F3F6;">clang1.info(clang1)</span></span></code></pre></div><p>程序输出结果为：<br> 正在调用实例方法<br> 正在调用类方法<br> 正在调用静态方法<br> 正在调用实例方法</p><p>显然，动态给类或者实例对象添加属性或方法，是非常灵活的。但与此同时，如果胡乱地使用，也会给程序带来一定的隐患，即程序中已经定义好的类，如果不做任何限制，是可以做动态的修改的。</p><p>庆幸的是，Python 提供了<code>__slots__</code>属性，通过它可以避免用户频繁的给实例对象动态地添加属性或方法。</p><p>再次声明，<code>__slots__</code>只能限制为实例对象动态添加属性和方法，而无法限制动态地为类添加属性和方法。</p><p><code>__slots__</code>属性值其实就是一个元组，只有其中指定的元素，才可以作为动态添加的属性或者方法的名称。举个例子：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>class CLanguage:</span></span>
<span class="line"><span>    __slots__ = (&#39;name&#39;,&#39;add&#39;,&#39;info&#39;)</span></span></code></pre></div><p>可以看到，<code>CLanguage</code>类中指定了<code>__slots__</code>属性，这意味着，该类的实例对象仅限于动态添加<code>name、add、info</code>这 3 个属性以及<code>name()、add()</code>和<code>info()</code>这 3 个方法。</p><p>注意，对于动态添加的方法，<code>__slots__</code>限制的是其方法名，并不限制参数的个数。</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">def</span><span style="color:#DBB7FF;"> info</span><span style="color:#F0F3F6;">(self,name):</span></span>
<span class="line"><span style="color:#91CBFF;">    print</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;正在调用实例方法&quot;</span><span style="color:#F0F3F6;">,</span><span style="color:#91CBFF;">self</span><span style="color:#F0F3F6;">.name)</span></span>
<span class="line"><span style="color:#F0F3F6;">clang </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> CLanguage()</span></span>
<span class="line"><span style="color:#F0F3F6;">clang.name </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &quot;小明&quot;</span></span>
<span class="line"><span style="color:#BDC4CC;">#为 clang 对象动态添加 info 实例方法</span></span>
<span class="line"><span style="color:#F0F3F6;">clang.info </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> info</span></span>
<span class="line"><span style="color:#F0F3F6;">clang.info(clang,</span><span style="color:#ADDCFF;">&quot;Python教程&quot;</span><span style="color:#F0F3F6;">)</span></span></code></pre></div><p>程序运行结果为：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>正在调用实例方法 小明</span></span></code></pre></div><p>还是在<code>CLanguage</code>类的基础上，添加如下代码并运行：</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">def</span><span style="color:#DBB7FF;"> info</span><span style="color:#F0F3F6;">(self,name):</span></span>
<span class="line"><span style="color:#91CBFF;">    print</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;正在调用实例方法&quot;</span><span style="color:#F0F3F6;">,</span><span style="color:#91CBFF;">self</span><span style="color:#F0F3F6;">.name)</span></span>
<span class="line"><span style="color:#F0F3F6;">clang </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> CLanguage()</span></span>
<span class="line"><span style="color:#F0F3F6;">clang.name </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &quot;小明&quot;</span></span>
<span class="line"><span style="color:#F0F3F6;">clang.say </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> info</span></span>
<span class="line"><span style="color:#F0F3F6;">clang.say(clang,</span><span style="color:#ADDCFF;">&quot;Python教程&quot;</span><span style="color:#F0F3F6;">)</span></span></code></pre></div><p>运行程序，显示如下信息：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>Traceback (most recent call last):</span></span>
<span class="line"><span>  File &quot;D:\\python3.6\\1.py&quot;, line 9, in &lt;module&gt;</span></span>
<span class="line"><span>    clang.say = info</span></span>
<span class="line"><span>AttributeError: &#39;CLanguage&#39; object has no attribute &#39;say&#39;</span></span></code></pre></div><p>显然，根据<code>__slots__</code>属性的设置，<code>CLanguage</code>类的实例对象是不能动态添加以 say 为名称的方法的。</p><p><code>__slots__</code>属性限制的对象是类的实例对象，而不是类，因此下面的代码是合法的：</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">def</span><span style="color:#DBB7FF;"> info</span><span style="color:#F0F3F6;">(self):</span></span>
<span class="line"><span style="color:#91CBFF;">  print</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;正在调用实例方法&quot;</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#F0F3F6;">CLanguage.say </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> info</span></span>
<span class="line"><span style="color:#F0F3F6;">clang </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> CLanguage()</span></span>
<span class="line"><span style="color:#F0F3F6;">clang.say()</span></span></code></pre></div><p>程序运行结果为：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>正在调用实例方法</span></span></code></pre></div><p>当然，还可以为类动态添加类方法和静态方法，这里不再给出具体实例，读者可自行编写代码尝试。</p><p>此外，<code>__slots__</code>属性对由该类派生出来的子类，也是不起作用的。例如如下代码：</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> CLanguage</span><span style="color:#F0F3F6;">:</span></span>
<span class="line"><span style="color:#91CBFF;">  __slots__</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> (</span><span style="color:#ADDCFF;">&#39;name&#39;</span><span style="color:#F0F3F6;">,</span><span style="color:#ADDCFF;">&#39;add&#39;</span><span style="color:#F0F3F6;">,</span><span style="color:#ADDCFF;">&#39;info&#39;</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#BDC4CC;">#Clanguage 的空子类</span></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> CLangs</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">CLanguage</span><span style="color:#F0F3F6;">):</span></span>
<span class="line"><span style="color:#FF9492;">  pass</span></span>
<span class="line"><span style="color:#BDC4CC;">#定义的实例方法</span></span>
<span class="line"><span style="color:#FF9492;">def</span><span style="color:#DBB7FF;"> info</span><span style="color:#F0F3F6;">(self):</span></span>
<span class="line"><span style="color:#91CBFF;">  print</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;正在调用实例方法&quot;</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#F0F3F6;">clang </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> CLangs()</span></span>
<span class="line"><span style="color:#BDC4CC;">#为子类对象动态添加 say() 方法</span></span>
<span class="line"><span style="color:#F0F3F6;">clang.say </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> info</span></span>
<span class="line"><span style="color:#F0F3F6;">clang.say(clang)</span></span></code></pre></div><p>运行结果为：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>正在调用实例方法</span></span></code></pre></div><p>显然，<code>__slots__</code>属性只对当前所在的类起限制作用。</p><p>因此，如果子类也要限制外界为其实例对象动态地添加属性和方法，必须在子类中设置<code>__slots__</code>属性。</p><p>注意，如果为子类也设置有<code>__slots__</code>属性，那么子类实例对象允许动态添加的属性和方法，是子类中<code>__slots__</code>属性和父类<code>__slots__</code>属性的和。</p><h1 id="type-函数-动态创建类" tabindex="-1"><a class="header-anchor" href="#type-函数-动态创建类"><span>type()函数：动态创建类</span></a></h1><p>我们知道，<code>type()</code>函数属于 Python 内置函数，通常用来查看某个变量的具体类型。其实，<code>type()</code>函数还有一个更高级的用法，即创建一个自定义类型（也就是创建一个类）。</p><p>type() 函数的语法格式有 2 种：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>type(obj) </span></span>
<span class="line"><span>type(name, bases, dict)</span></span></code></pre></div><p>以上这 2 种语法格式，各参数的含义及功能分别是：</p><ul><li>第一种语法格式用来查看某个变量（类对象）的具体类型，obj 表示某个变量或者类对象。</li><li>第二种语法格式用来创建类，其中 name 表示类的名称；bases 表示一个元组，其中存储的是该类的父类；dict 表示一个字典，用于表示类内定义的属性或者方法。</li></ul><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">#查看 3.4 的类型</span></span>
<span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">type</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">3.4</span><span style="color:#F0F3F6;">))</span></span>
<span class="line"><span style="color:#BDC4CC;">#查看类对象的类型</span></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> CLanguage</span><span style="color:#F0F3F6;">:</span></span>
<span class="line"><span style="color:#FF9492;">    pass</span></span>
<span class="line"><span style="color:#F0F3F6;">clangs </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> CLanguage()</span></span>
<span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">type</span><span style="color:#F0F3F6;">(clangs))</span></span></code></pre></div><p>输出结果为：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>&lt;class &#39;float&#39;&gt;</span></span>
<span class="line"><span>&lt;class &#39;__main__.CLanguage&#39;&gt;</span></span></code></pre></div><p><code>type()</code>函数的另一种用法，即创建一个新类，先来分析一个样例：</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">#定义一个实例方法</span></span>
<span class="line"><span style="color:#FF9492;">def</span><span style="color:#DBB7FF;"> say</span><span style="color:#F0F3F6;">(self):</span></span>
<span class="line"><span style="color:#91CBFF;">    print</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;我要学 Python！&quot;</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#BDC4CC;">#使用 type() 函数创建类</span></span>
<span class="line"><span style="color:#F0F3F6;">CLanguage </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> type</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;CLanguage&quot;</span><span style="color:#F0F3F6;">,(</span><span style="color:#91CBFF;">object</span><span style="color:#F0F3F6;">,),</span><span style="color:#91CBFF;">dict</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">say</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> say, </span><span style="color:#FFB757;">name</span><span style="color:#FF9492;"> =</span><span style="color:#ADDCFF;"> &quot;C语言中文网&quot;</span><span style="color:#F0F3F6;">))</span></span>
<span class="line"><span style="color:#BDC4CC;">#创建一个 CLanguage 实例对象</span></span>
<span class="line"><span style="color:#F0F3F6;">clangs </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> CLanguage()</span></span>
<span class="line"><span style="color:#BDC4CC;">#调用 say() 方法和 name 属性</span></span>
<span class="line"><span style="color:#F0F3F6;">clangs.say()</span></span>
<span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(clangs.name)</span></span></code></pre></div><p>注意，Python 元组语法规定，当<code>(object,)</code>元组中只有一个元素时，最后的逗号（,）不能省略。</p><p>可以看到，此程序中通过<code>type()</code>创建了类，其类名为<code>CLanguage</code>，继承自<code>objects</code>类，且该类中还包含一个<code>say()</code>方法和一个<code>name</code>属性。</p><p>运行上面的程序，其输出结果为：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>我要学 Python！</span></span>
<span class="line"><span>C语言中文网</span></span></code></pre></div><p>可以看到，使用<code>type()</code>函数创建的类，和直接使用<code>class</code>定义的类并无差别。事实上，我们在使用<code>class</code>定义类时，Python 解释器底层依然是用<code>type()</code>来创建这个类。</p><h1 id="metaclass元类" tabindex="-1"><a class="header-anchor" href="#metaclass元类"><span>MetaClass元类</span></a></h1><p><code>MetaClass</code>元类，本质也是一个类，但和普通类的用法不同，它可以对类内部的定义（包括类属性和类方法）进行动态的修改。可以这么说，使用元类的主要目的就是为了实现在创建类时，能够动态地改变类中定义的属性或者方法。</p><p>不要从字面上去理解元类的含义，事实上<code>MetaClass</code>中的<code>Meta</code>这个词根，起源于希腊语词汇 meta，包含“超越”和“改变”的意思。</p><p>举个例子，根据实际场景的需要，我们要为多个类添加一个 name 属性和一个 say() 方法。显然有多种方法可以实现，但其中一种方法就是使用 MetaClass 元类。</p><p>如果在创建类时，想用<code>MetaClass</code>元类动态地修改内部的属性或者方法，则类的创建过程将变得复杂：先创建 MetaClass 元类，然后用元类去创建类，最后使用该类的实例化对象实现功能。</p><p>如果想把一个类设计成<code>MetaClass</code>元类，其必须符合以下条件：</p><ul><li>必须显式继承自<code>type</code>类；</li><li>类中需要定义并实现<code>__new__()</code>方法，该方法一定要返回该类的一个实例对象，因为在使用元类创建类时，该<code>__new__()</code>方法会自动被执行，用来修改新建的类。</li></ul><p>我们先尝试定义一个<code>MetaClass</code>元类：</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">#定义一个元类</span></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> FirstMetaClass</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">type</span><span style="color:#F0F3F6;">):</span></span>
<span class="line"><span style="color:#BDC4CC;">    # cls代表动态修改的类</span></span>
<span class="line"><span style="color:#BDC4CC;">    # name代表动态修改的类名</span></span>
<span class="line"><span style="color:#BDC4CC;">    # bases代表被动态修改的类的所有父类</span></span>
<span class="line"><span style="color:#BDC4CC;">    # attr代表被动态修改的类的所有属性、方法组成的字典</span></span>
<span class="line"><span style="color:#FF9492;">    def</span><span style="color:#91CBFF;"> __new__</span><span style="color:#F0F3F6;">(cls, name, bases, attrs):</span></span>
<span class="line"><span style="color:#BDC4CC;">        # 动态为该类添加一个name属性</span></span>
<span class="line"><span style="color:#F0F3F6;">        attrs[</span><span style="color:#ADDCFF;">&#39;name&#39;</span><span style="color:#F0F3F6;">] </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &quot;C语言中文网&quot;</span></span>
<span class="line"><span style="color:#F0F3F6;">        attrs[</span><span style="color:#ADDCFF;">&#39;say&#39;</span><span style="color:#F0F3F6;">] </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> lambda</span><span style="color:#F0F3F6;"> self: </span><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;调用 say() 实例方法&quot;</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#FF9492;">        return</span><span style="color:#91CBFF;"> super</span><span style="color:#F0F3F6;">().</span><span style="color:#91CBFF;">__new__</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">cls</span><span style="color:#F0F3F6;">,name,bases,attrs)</span></span></code></pre></div><p>此程序中，首先可以断定 FirstMetaClass 是一个类。其次，由于该类继承自 type 类，并且内部实现了 <strong>new</strong>() 方法，因此可以断定 FirstMetaCLass 是一个元类。</p><p>可以看到，在这个元类的<code>__new__()</code>方法中，手动添加了一个 name 属性和 say() 方法。这意味着，通过 FirstMetaClass 元类创建的类，会额外添加 name 属性和 say() 方法。通过如下代码，可以验证这个结论：</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">#定义类时，指定元类</span></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> CLanguage</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">object</span><span style="color:#F0F3F6;">,</span><span style="color:#91CBFF;">metaclass</span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;">FirstMetaClass</span><span style="color:#F0F3F6;">):</span></span>
<span class="line"><span style="color:#FF9492;">  pass</span></span>
<span class="line"><span style="color:#F0F3F6;">clangs </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> CLanguage()</span></span>
<span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(clangs.name)</span></span>
<span class="line"><span style="color:#F0F3F6;">clangs.say()</span></span></code></pre></div><p>可以看到，在创建类时，通过在标注父类的同时指定元类（格式为metaclass=元类名），则当 Python 解释器在创建这该类时，FirstMetaClass 元类中的 <strong>new</strong> 方法就会被调用，从而实现动态修改类属性或者类方法的目的。</p><p>运行上面的程序，输出结果为：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>C语言中文网</span></span>
<span class="line"><span>调用 say() 实例方法</span></span></code></pre></div><p>显然，<code>FirstMetaClass</code>元类的<code>__new__()</code>方法动态地为<code>Clanguage</code>类添加了<code>name</code>属性和<code>say()</code>方法，因此，即便该类在定义时是空类，它也依然有<code>name</code>属性和<code>say()</code>方法。</p><p>对于<code>MetaClass</code>元类，它多用于创建 API，因此我们几乎不会使用到它。</p><h1 id="多态" tabindex="-1"><a class="header-anchor" href="#多态"><span>多态</span></a></h1><p>我们都知道，Python 是弱类型语言，其最明显的特征是在使用变量时，无需为其指定具体的数据类型。这会导致一种情况，即同一变量可能会被先后赋值不同的类对象，例如：</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> CLanguage</span><span style="color:#F0F3F6;">:</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#DBB7FF;"> say</span><span style="color:#F0F3F6;">(self):</span></span>
<span class="line"><span style="color:#91CBFF;">    print</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;赋值的是 CLanguage 类的实例对象&quot;</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> CPython</span><span style="color:#F0F3F6;">:</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#DBB7FF;"> say</span><span style="color:#F0F3F6;">(self):</span></span>
<span class="line"><span style="color:#91CBFF;">    print</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;赋值的是 CPython 类的实例对象&quot;</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#F0F3F6;">a </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> CLanguage()</span></span>
<span class="line"><span style="color:#F0F3F6;">a.say()</span></span>
<span class="line"><span style="color:#F0F3F6;">a </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> CPython()</span></span>
<span class="line"><span style="color:#F0F3F6;">a.say()</span></span></code></pre></div><p>运行结果为：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>赋值的是 CLanguage 类的实例对象</span></span>
<span class="line"><span>赋值的是 CPython 类的实例对象</span></span></code></pre></div><p>可以看到，<code>a</code>可以被先后赋值为<code>CLanguage</code>类和<code>CPython</code>类的对象，但这并不是多态。类的多态特性，还要满足以下 2 个前提条件：</p><ul><li>继承：多态一定是发生在子类和父类之间；</li><li>重写：子类重写了父类的方法。</li></ul><p>下面程序是对上面代码的改写：</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> CLanguage</span><span style="color:#F0F3F6;">:</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#DBB7FF;"> say</span><span style="color:#F0F3F6;">(self):</span></span>
<span class="line"><span style="color:#91CBFF;">    print</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;调用的是 Clanguage 类的say方法&quot;</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> CPython</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">CLanguage</span><span style="color:#F0F3F6;">):</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#DBB7FF;"> say</span><span style="color:#F0F3F6;">(self):</span></span>
<span class="line"><span style="color:#91CBFF;">    print</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;调用的是 CPython 类的say方法&quot;</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> CLinux</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">CLanguage</span><span style="color:#F0F3F6;">):</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#DBB7FF;"> say</span><span style="color:#F0F3F6;">(self):</span></span>
<span class="line"><span style="color:#91CBFF;">    print</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;调用的是 CLinux 类的say方法&quot;</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#F0F3F6;">a </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> CLanguage()</span></span>
<span class="line"><span style="color:#F0F3F6;">a.say()</span></span>
<span class="line"><span style="color:#F0F3F6;">a </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> CPython()</span></span>
<span class="line"><span style="color:#F0F3F6;">a.say()</span></span>
<span class="line"><span style="color:#F0F3F6;">a </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> CLinux()</span></span>
<span class="line"><span style="color:#F0F3F6;">a.say()</span></span></code></pre></div><p>程序执行结果为：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>调用的是 Clanguage 类的say方法</span></span>
<span class="line"><span>调用的是 CPython 类的say方法</span></span>
<span class="line"><span>调用的是 CLinux 类的say方法</span></span></code></pre></div><p>可以看到，<code>CPython</code>和<code>CLinux</code>都继承自<code>CLanguage</code>类，且各自都重写了父类的<code>say()</code>方法。从运行结果可以看出，同一变量<code>a</code>在执行同一个<code>say()</code>方法时，由于<code>a</code>实际表示不同的类实例对象，因此<code>a.say()</code>调用的并不是同一个类中的<code>say()</code>方法，这就是多态。</p><p>其实，Python 在多态的基础上，衍生出了一种更灵活的编程机制。继续对上面的程序进行改写：</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> WhoSay</span><span style="color:#F0F3F6;">:</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#DBB7FF;"> say</span><span style="color:#F0F3F6;">(self,who):</span></span>
<span class="line"><span style="color:#F0F3F6;">    who.say()</span></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> CLanguage</span><span style="color:#F0F3F6;">:</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#DBB7FF;"> say</span><span style="color:#F0F3F6;">(self):</span></span>
<span class="line"><span style="color:#91CBFF;">    print</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;调用的是 Clanguage 类的say方法&quot;</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> CPython</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">CLanguage</span><span style="color:#F0F3F6;">):</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#DBB7FF;"> say</span><span style="color:#F0F3F6;">(self):</span></span>
<span class="line"><span style="color:#91CBFF;">    print</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;调用的是 CPython 类的say方法&quot;</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> CLinux</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">CLanguage</span><span style="color:#F0F3F6;">):</span></span>
<span class="line"><span style="color:#FF9492;">  def</span><span style="color:#DBB7FF;"> say</span><span style="color:#F0F3F6;">(self):</span></span>
<span class="line"><span style="color:#91CBFF;">    print</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;调用的是 CLinux 类的say方法&quot;</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#F0F3F6;">a </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> WhoSay()</span></span>
<span class="line"><span style="color:#BDC4CC;">#调用 CLanguage 类的 say() 方法</span></span>
<span class="line"><span style="color:#F0F3F6;">a.say(CLanguage())</span></span>
<span class="line"><span style="color:#BDC4CC;">#调用 CPython 类的 say() 方法</span></span>
<span class="line"><span style="color:#F0F3F6;">a.say(CPython())</span></span>
<span class="line"><span style="color:#BDC4CC;">#调用 CLinux 类的 say() 方法</span></span>
<span class="line"><span style="color:#F0F3F6;">a.say(CLinux())</span></span></code></pre></div><p>程序执行结果为：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>调用的是 Clanguage 类的say方法</span></span>
<span class="line"><span>调用的是 CPython 类的say方法</span></span>
<span class="line"><span>调用的是 CLinux 类的say方法</span></span></code></pre></div><p>此程序中，通过给<code>WhoSay</code>类中的<code>say()</code>函数添加一个<code>who</code>参数，其内部利用传入的<code>who</code>调用<code>say()</code>方法。这意味着，当调用<code>WhoSay</code>类中的<code>say()</code>方法时，我们传给<code>who</code>参数的是哪个类的实例对象，它就会调用那个类中的<code>say()</code>方法。</p><h1 id="枚举类" tabindex="-1"><a class="header-anchor" href="#枚举类"><span>枚举类</span></a></h1><p>一些具有特殊含义的类，其实例化对象的个数往往是固定的，比如用一个类表示月份，则该类的实例对象最多有 12 个。对于这些实例化对象个数固定的类，可以用枚举类来定义。</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">from</span><span style="color:#F0F3F6;"> enum </span><span style="color:#FF9492;">import</span><span style="color:#F0F3F6;"> Enum</span></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Color</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">Enum</span><span style="color:#F0F3F6;">):</span></span>
<span class="line"><span style="color:#BDC4CC;">  # 为序列值指定value值</span></span>
<span class="line"><span style="color:#F0F3F6;">  red </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 1</span></span>
<span class="line"><span style="color:#F0F3F6;">  green </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 2</span></span>
<span class="line"><span style="color:#F0F3F6;">  blue </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 3</span></span></code></pre></div><p>如果想将一个类定义为枚举类，只需要令其继承自<code>enum</code>模块中的<code>Enum</code>类即可。例如在上面程序中，<code>Color</code>类继承自<code>Enum</code>类，则证明这是一个枚举类。</p><p>在<code>Color</code>枚举类中，<code>red、green、blue</code>都是该类的成员（可以理解为是类变量）。注意，枚举类的每个成员都由 2 部分组成，分别为<code>name</code>和<code>value</code>，其中<code>name</code>属性值为该枚举值的变量名（如<code>red</code>），<code>value</code>代表该枚举值的序号（序号通常从 1 开始）。</p><p>和普通类的用法不同，枚举类不能用来实例化对象，但这并不妨碍我们访问枚举类中的成员。访问枚举类成员的方式有多种：</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">#调用枚举成员的 3 种方式</span></span>
<span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(Color.red)</span></span>
<span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(Color[</span><span style="color:#ADDCFF;">&#39;red&#39;</span><span style="color:#F0F3F6;">])</span></span>
<span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(Color(</span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">))</span></span>
<span class="line"><span style="color:#BDC4CC;">#调取枚举成员中的 value 和 name</span></span>
<span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(Color.red.value)</span></span>
<span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(Color.red.name)</span></span>
<span class="line"><span style="color:#BDC4CC;">#遍历枚举类中所有成员的 2 种方式</span></span>
<span class="line"><span style="color:#FF9492;">for</span><span style="color:#F0F3F6;"> color </span><span style="color:#FF9492;">in</span><span style="color:#F0F3F6;"> Color:</span></span>
<span class="line"><span style="color:#91CBFF;">  print</span><span style="color:#F0F3F6;">(color)</span></span></code></pre></div><p>程序输出结果为：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>Color.red</span></span>
<span class="line"><span>Color.red</span></span>
<span class="line"><span>Color.red</span></span>
<span class="line"><span>1</span></span>
<span class="line"><span>red</span></span>
<span class="line"><span>Color.red</span></span>
<span class="line"><span>Color.green</span></span>
<span class="line"><span>Color.blue</span></span></code></pre></div><p>枚举类成员之间不能比较大小，但可以用<code>==</code>或者<code>is</code>进行比较是否相等：</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(Color.red </span><span style="color:#FF9492;">==</span><span style="color:#F0F3F6;"> Color.green) </span><span style="color:#BDC4CC;"># Flase</span></span>
<span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(Color.red.name </span><span style="color:#FF9492;">is</span><span style="color:#F0F3F6;"> Color.green.name) </span><span style="color:#BDC4CC;"># Flase</span></span></code></pre></div><p>需要注意的是，枚举类中各个成员的值，不能在类的外部做任何修改，也就是说，下面语法的做法是错误的：</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">Color.red </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 4</span></span></code></pre></div><p>除此之外，该枚举类还提供了一个<code>__members__</code>属性，该属性是一个包含枚举类中所有成员的字典，通过遍历该属性，也可以访问枚举类中的各个成员。</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">for</span><span style="color:#F0F3F6;"> name,member </span><span style="color:#FF9492;">in</span><span style="color:#F0F3F6;"> Color.</span><span style="color:#91CBFF;">__members__</span><span style="color:#F0F3F6;">.items():</span></span>
<span class="line"><span style="color:#91CBFF;">  print</span><span style="color:#F0F3F6;">(name,</span><span style="color:#ADDCFF;">&quot;-&gt;&quot;</span><span style="color:#F0F3F6;">,member)</span></span></code></pre></div><p>输出结果为：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>red -&gt; Color.red</span></span>
<span class="line"><span>green -&gt; Color.green</span></span>
<span class="line"><span>blue -&gt; Color.blue</span></span></code></pre></div><p>值得一提的是，Python 枚举类中各个成员必须保证<code>name</code>互不相同，但<code>value</code>可以相同：</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">from</span><span style="color:#F0F3F6;"> enum </span><span style="color:#FF9492;">import</span><span style="color:#F0F3F6;"> Enum</span></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Color</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">Enum</span><span style="color:#F0F3F6;">):</span></span>
<span class="line"><span style="color:#BDC4CC;">  # 为序列值指定value值</span></span>
<span class="line"><span style="color:#F0F3F6;">  red </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 1</span></span>
<span class="line"><span style="color:#F0F3F6;">  green </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 1</span></span>
<span class="line"><span style="color:#F0F3F6;">  blue </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 3</span></span>
<span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(Color[</span><span style="color:#ADDCFF;">&#39;green&#39;</span><span style="color:#F0F3F6;">])</span></span></code></pre></div><p>输出结果为：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>Color.red</span></span></code></pre></div><p>可以看到，<code>Color</code>枚举类中<code>red</code>和<code>green</code>具有相同的值（都是 1），Python 允许这种情况的发生，它会将<code>green</code>当做是<code>red</code>的别名，因此当访问<code>green</code>成员时，最终输出的是<code>red</code>。</p><p>在实际编程过程中，如果想避免发生这种情况，可以借助<code>@unique</code>装饰器，这样当枚举类中出现相同值的成员时，程序会报<code>ValueError</code>错误。</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">#引入 unique</span></span>
<span class="line"><span style="color:#FF9492;">from</span><span style="color:#F0F3F6;"> enum </span><span style="color:#FF9492;">import</span><span style="color:#F0F3F6;"> Enum,unique</span></span>
<span class="line"><span style="color:#BDC4CC;">#添加 unique 装饰器</span></span>
<span class="line"><span style="color:#DBB7FF;">@unique</span></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Color</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">Enum</span><span style="color:#F0F3F6;">):</span></span>
<span class="line"><span style="color:#BDC4CC;">  # 为序列值指定value值</span></span>
<span class="line"><span style="color:#F0F3F6;">  red </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 1</span></span>
<span class="line"><span style="color:#F0F3F6;">  green </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 1</span></span>
<span class="line"><span style="color:#F0F3F6;">  blue </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 3</span></span>
<span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(Color[</span><span style="color:#ADDCFF;">&#39;green&#39;</span><span style="color:#F0F3F6;">])</span></span></code></pre></div><p>运行程序会报错：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>Traceback (most recent call last):</span></span>
<span class="line"><span>  File &quot;D:\\python3.6\\demo.py&quot;, line 3, in &lt;module&gt;</span></span>
<span class="line"><span>    class Color(Enum):</span></span>
<span class="line"><span>  File &quot;D:\\python3.6\\lib\\enum.py&quot;, line 834, in unique</span></span>
<span class="line"><span>    (enumeration, alias_details))</span></span>
<span class="line"><span>ValueError: duplicate values found in &lt;enum &#39;Color&#39;&gt;: green -&gt; red</span></span></code></pre></div><p>除了通过继承<code>Enum</code>类的方法创建枚举类，还可以使用<code>Enum()</code>函数创建枚举类。</p><div class="language-python" data-highlighter="shiki" data-ext="python" data-title="python" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">from</span><span style="color:#F0F3F6;"> enum </span><span style="color:#FF9492;">import</span><span style="color:#F0F3F6;"> Enum</span></span>
<span class="line"><span style="color:#BDC4CC;">#创建一个枚举类</span></span>
<span class="line"><span style="color:#F0F3F6;">Color </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> Enum(</span><span style="color:#ADDCFF;">&quot;Color&quot;</span><span style="color:#F0F3F6;">,(</span><span style="color:#ADDCFF;">&#39;red&#39;</span><span style="color:#F0F3F6;">,</span><span style="color:#ADDCFF;">&#39;green&#39;</span><span style="color:#F0F3F6;">,</span><span style="color:#ADDCFF;">&#39;blue&#39;</span><span style="color:#F0F3F6;">))</span></span>
<span class="line"><span style="color:#BDC4CC;">#调用枚举成员的 3 种方式</span></span>
<span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(Color.red)</span></span>
<span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(Color[</span><span style="color:#ADDCFF;">&#39;red&#39;</span><span style="color:#F0F3F6;">])</span></span>
<span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(Color(</span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">))</span></span>
<span class="line"><span style="color:#BDC4CC;">#调取枚举成员中的 value 和 name</span></span>
<span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(Color.red.value)</span></span>
<span class="line"><span style="color:#91CBFF;">print</span><span style="color:#F0F3F6;">(Color.red.name)</span></span>
<span class="line"><span style="color:#BDC4CC;">#遍历枚举类中所有成员的 2 种方式</span></span>
<span class="line"><span style="color:#FF9492;">for</span><span style="color:#F0F3F6;"> color </span><span style="color:#FF9492;">in</span><span style="color:#F0F3F6;"> Color:</span></span>
<span class="line"><span style="color:#91CBFF;">  print</span><span style="color:#F0F3F6;">(color)</span></span></code></pre></div><p><code>Enum()</code>函数可接受 2 个参数，第一个用于指定枚举类的类名，第二个参数用于指定枚举类中的多个成员。</p><p>如上所示，仅通过一行代码，即创建了一个和前面的<code>Color</code>类相同的枚举类。运行程序，其输出结果为：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>Color.red</span></span>
<span class="line"><span>Color.red</span></span>
<span class="line"><span>Color.red</span></span>
<span class="line"><span>1</span></span>
<span class="line"><span>red</span></span>
<span class="line"><span>Color.red</span></span>
<span class="line"><span>Color.green</span></span>
<span class="line"><span>Color.blue</span></span></code></pre></div>`,388)]))}const r=a(o,[["render",e],["__file","python类和对象.html.vue"]]),i=JSON.parse('{"path":"/python/python%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1.html","title":"self用法","lang":"zh-CN","frontmatter":{"description":"class：定义类 定义一个类使用class关键字实现： 无论是类属性还是类方法，对于类来说，它们都不是必需的。另外，类中属性和方法所在的位置是任意的，即它们之间并没有固定的前后次序。 类属性指的就是包含在类中的变量；类方法指的是包含类中的函数。换句话说，类属性和类方法其实分别是包含类中的变量和函数的别称。 Python 类是由类头（class类名）和...","head":[["meta",{"property":"og:url","content":"https://wsq01.github.io/wsq-blog/python/python%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1.html"}],["meta",{"property":"og:title","content":"self用法"}],["meta",{"property":"og:description","content":"class：定义类 定义一个类使用class关键字实现： 无论是类属性还是类方法，对于类来说，它们都不是必需的。另外，类中属性和方法所在的位置是任意的，即它们之间并没有固定的前后次序。 类属性指的就是包含在类中的变量；类方法指的是包含类中的函数。换句话说，类属性和类方法其实分别是包含类中的变量和函数的别称。 Python 类是由类头（class类名）和..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-04-23T09:49:11.000Z"}],["meta",{"property":"article:modified_time","content":"2025-04-23T09:49:11.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"self用法\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-04-23T09:49:11.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"WSQ\\",\\"url\\":\\"https://wsq01.github.com\\"}]}"]]},"headers":[{"level":2,"title":"class：定义类","slug":"class-定义类","link":"#class-定义类","children":[]},{"level":2,"title":"init()类构造方法","slug":"init-类构造方法","link":"#init-类构造方法","children":[]},{"level":2,"title":"类对象的创建和使用","slug":"类对象的创建和使用","link":"#类对象的创建和使用","children":[{"level":3,"title":"类的实例化","slug":"类的实例化","link":"#类的实例化","children":[]},{"level":3,"title":"类对象的使用","slug":"类对象的使用","link":"#类对象的使用","children":[]}]},{"level":2,"title":"类变量（类属性）","slug":"类变量-类属性","link":"#类变量-类属性","children":[]},{"level":2,"title":"实例变量（实例属性）","slug":"实例变量-实例属性","link":"#实例变量-实例属性","children":[]},{"level":2,"title":"局部变量","slug":"局部变量","link":"#局部变量","children":[]},{"level":2,"title":"类实例方法","slug":"类实例方法","link":"#类实例方法","children":[]},{"level":2,"title":"类方法","slug":"类方法","link":"#类方法","children":[]},{"level":2,"title":"类静态方法","slug":"类静态方法","link":"#类静态方法","children":[]},{"level":2,"title":"Python 类如何进行封装","slug":"python-类如何进行封装","link":"#python-类如何进行封装","children":[]},{"level":2,"title":"关于Python的多继承","slug":"关于python的多继承","link":"#关于python的多继承","children":[]},{"level":2,"title":"如何调用被重写的方法","slug":"如何调用被重写的方法","link":"#如何调用被重写的方法","children":[]}],"git":{"createdTime":1745401751000,"updatedTime":1745401751000,"contributors":[{"name":"WSQ","email":"592786982@qq.com","commits":1}]},"readingTime":{"minutes":50.4,"words":15121},"filePathRelative":"python/python类和对象.md","localizedDate":"2025年4月23日","autoDesc":true}');export{r as comp,i as data};
