import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,d as l,o}from"./app-Coac0FJ0.js";const p={};function e(t,s){return o(),n("div",null,s[0]||(s[0]=[l(`<h2 id="访问控制修饰符" tabindex="-1"><a class="header-anchor" href="#访问控制修饰符"><span>访问控制修饰符</span></a></h2><p>在 Java 语言中提供了多个作用域修饰符，其中常用的有<code>public、private、protected、final、abstract、static、transient</code>和<code>volatile</code>，这些修饰符有类修饰符、变量修饰符和方法修饰符。</p><p>通过使用访问控制修饰符来限制对对象私有属性的访问，可以获得 3 个重要的好处。</p><ul><li>防止对封装数据的未授权访问。</li><li>有助于保证数据完整性。</li><li>当类的私有实现细节必须改变时，可以限制发生在整个应用程序中的“连锁反应”。</li></ul><p>访问控制符是一组限定类、属性或方法是否可以被程序里的其他部分访问和调用的修饰符。类的访问控制符只能是空或者<code>public</code>，方法和属性的访问控制符有 4 个，分别是<code>public、 private、protected</code>和<code>friendly</code>，其中<code>friendly</code>是一种没有定义专门的访问控制符的默认情况。</p><table><thead><tr><th style="text-align:center;">访问范围</th><th style="text-align:center;">private</th><th style="text-align:center;">friendly(默认)</th><th style="text-align:center;">protected</th><th style="text-align:center;">public</th></tr></thead><tbody><tr><td style="text-align:center;">同一个类</td><td style="text-align:center;">可访问</td><td style="text-align:center;">可访问</td><td style="text-align:center;">可访问</td><td style="text-align:center;">可访问</td></tr><tr><td style="text-align:center;">同一包中的其他类</td><td style="text-align:center;">不可访问</td><td style="text-align:center;">可访问</td><td style="text-align:center;">可访问</td><td style="text-align:center;">可访问</td></tr><tr><td style="text-align:center;">不同包中的子类</td><td style="text-align:center;">不可访问</td><td style="text-align:center;">不可访问</td><td style="text-align:center;">可访问</td><td style="text-align:center;">可访问</td></tr><tr><td style="text-align:center;">不同包中的非子类</td><td style="text-align:center;">不可访问</td><td style="text-align:center;">不可访问</td><td style="text-align:center;">不可访问</td><td style="text-align:center;">可访问</td></tr></tbody></table><ol><li><code>private</code><br> 用 private 修饰的类成员，只能被该类自身的方法访问和修改，而不能被任何其他类（包括该类的子类）访问和引用。因此，<code>private</code>修饰符具有最高的保护级别。</li><li><code>friendly</code>（默认）<br> 如果一个类没有访问控制符，说明它具有默认的访问控制特性。这种默认的访问控制权规定，该类只能被同一个包中的类访问和引用，而不能被其他包中的类使用，即使其他包中有该类的子类。这种访问特性又称为包访问性（<code>package private</code>）。<br> 同样，类内的成员如果没有访问控制符，也说明它们具有包访问性，或称为友元（<code>friend</code>）。定义在同一个文件夹中的所有类属于一个包，所以前面的程序要把用户自定义的类放在同一个文件夹中（Java 项目默认的包），以便不加修饰符也能运行。</li><li><code>protected</code><br> 用保护访问控制符<code>protected</code>修饰的类成员可以被三种类所访问：该类自身、与它在同一个包中的其他类以及在其他包中的该类的子类。使用<code>protected</code>修饰符的主要作用，是允许其他包中它的子类来访问父类的特定属性和方法，否则可以使用默认访问控制符。</li><li><code>public</code><br> 当一个类被声明为<code>public</code>时，它就具有了被其他包中的类访问的可能性，只要包中的其他类在程序中使用<code>import</code>语句引入<code>public</code>类，就可以访问和引用这个类。<br> 类中被设定为<code>public</code>的方法是这个类对外的接口部分，避免了程序的其他部分直接去操作类内的数据，实际就是数据封装思想的体现。每个 Java 程序的主类都必须是<code>public</code>类，也是基于相同的原因。</li></ol><div class="language-java" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Student</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#BDC4CC;">  // 姓名，其访问权限为默认(friendly)</span></span>
<span class="line"><span style="color:#F0F3F6;">  String</span><span style="color:#F0F3F6;"> name;</span></span>
<span class="line"><span style="color:#BDC4CC;">  // 定义私有变量，身份证号码</span></span>
<span class="line"><span style="color:#FF9492;">  private</span><span style="color:#F0F3F6;"> String</span><span style="color:#F0F3F6;"> idNumber;</span></span>
<span class="line"><span style="color:#BDC4CC;">  // 定义受保护变量，学号</span></span>
<span class="line"><span style="color:#FF9492;">  protected</span><span style="color:#F0F3F6;"> String</span><span style="color:#F0F3F6;"> no;</span></span>
<span class="line"><span style="color:#BDC4CC;">  // 定义共有变量，邮箱</span></span>
<span class="line"><span style="color:#FF9492;">  public</span><span style="color:#F0F3F6;"> String</span><span style="color:#F0F3F6;"> email;</span></span>
<span class="line"><span style="color:#BDC4CC;">  // 定义共有方法，显示学生信息</span></span>
<span class="line"><span style="color:#FF9492;">  public</span><span style="color:#F0F3F6;"> String </span><span style="color:#DBB7FF;">info</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#FF9492;">    return</span><span style="color:#ADDCFF;">&quot;姓名：&quot;</span><span style="color:#FF9492;">+</span><span style="color:#F0F3F6;">name</span><span style="color:#FF9492;">+</span><span style="color:#ADDCFF;">&quot;，身份证号码：&quot;</span><span style="color:#FF9492;">+</span><span style="color:#F0F3F6;">idNumber</span><span style="color:#FF9492;">+</span><span style="color:#ADDCFF;">&quot;，学号：&quot;</span><span style="color:#FF9492;">+</span><span style="color:#F0F3F6;">no</span><span style="color:#FF9492;">+</span><span style="color:#ADDCFF;">&quot;，邮箱：&quot;</span><span style="color:#FF9492;">+</span><span style="color:#F0F3F6;">email;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><div class="language-java" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">public</span><span style="color:#FF9492;"> class</span><span style="color:#FFB757;"> StudentTest</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  public</span><span style="color:#FF9492;"> static</span><span style="color:#FF9492;"> void</span><span style="color:#DBB7FF;"> main</span><span style="color:#F0F3F6;">(</span><span style="color:#FF9492;">String</span><span style="color:#F0F3F6;">[] </span><span style="color:#FFB757;">args</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#BDC4CC;">    // 创建Student类对象</span></span>
<span class="line"><span style="color:#F0F3F6;">    Student</span><span style="color:#F0F3F6;"> stu</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> Student</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#BDC4CC;">    // 向Student类对象中的属性赋值</span></span>
<span class="line"><span style="color:#F0F3F6;">    stu.name </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &quot;zhht&quot;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#BDC4CC;">    // stu.idNumber=&quot;043765290763137806&quot;;</span></span>
<span class="line"><span style="color:#BDC4CC;">    // 这是不允许的。提示stu.idNumber是不可见的，必须注释掉才可运行</span></span>
<span class="line"><span style="color:#F0F3F6;">    stu.no </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &quot;20lil01637&quot;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">    stu.email </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &quot;zhht@qq.com&quot;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">    System.out.</span><span style="color:#DBB7FF;">println</span><span style="color:#F0F3F6;">(stu.</span><span style="color:#DBB7FF;">info</span><span style="color:#F0F3F6;">());</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>从上面的例子中可以看出，范围控制修饰符成功地限制了访问者访问不同修饰符的属性（成员变量），从而实现了数据的隐藏。</p><h2 id="static关键字" tabindex="-1"><a class="header-anchor" href="#static关键字"><span>static关键字</span></a></h2><p>在类中，使用<code>static</code>修饰符修饰的属性（成员变量）称为静态变量，也可以称为类变量，常量称为静态常量，方法称为静态方法或类方法，它们统称为静态成员，归整个类所有。</p><p>静态成员不依赖于类的特定实例，被类的所有实例共享，就是说<code>static</code>修饰的方法或者变量不需要依赖于对象来进行访问，只要这个类被加载，Java 虚拟机就可以根据类名找到它们。</p><p>调用静态成员的语法形式如下：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>类名.静态成员</span></span></code></pre></div><p>注意：</p><ul><li><code>static</code>修饰的成员变量和方法，从属于类。</li><li>普通变量和方法从属于对象。</li><li>静态方法不能调用非静态成员，编译会报错。</li></ul><h3 id="静态变量" tabindex="-1"><a class="header-anchor" href="#静态变量"><span>静态变量</span></a></h3><p>类的成员变量可以分为以下两种：</p><ul><li>静态变量（或称为类变量），指被<code>static</code>修饰的成员变量。</li><li>实例变量，指没有被<code>static</code>修饰的成员变量。</li></ul><p>静态变量与实例变量的区别如下：</p><ol><li>静态变量</li></ol><ul><li>运行时，Java 虚拟机只为静态变量分配一次内存，在加载类的过程中完成静态变量的内存分配。</li><li>在类的内部，可以在任何方法内直接访问静态变量。</li><li>在其他类中，可以通过类名访问该类中的静态变量。</li></ul><ol start="2"><li>实例变量</li></ol><ul><li>每创建一个实例，Java 虚拟机就会为实例变量分配一次内存。</li><li>在类的内部，可以在非静态方法中直接访问实例变量。</li><li>在本类的静态方法或其他类中则需要通过类的实例对象进行访问。</li></ul><p>静态变量在类中的作用如下：</p><ul><li>静态变量可以被类的所有实例共享，因此静态变量可以作为实例之间的共享数据，增加实例之间的交互性。</li><li>如果类的所有实例都包含一个相同的常量属性，则可以把这个属性定义为静态常量类型，从而节省内存空间。例如，在类中定义一个静态常量 PI。</li></ul><div class="language-java" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">public</span><span style="color:#FF9492;"> static</span><span style="color:#FF9492;"> double</span><span style="color:#F0F3F6;"> PI</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> 3.14159256</span><span style="color:#F0F3F6;">;</span></span></code></pre></div><p>创建一个带静态变量的类，然后在<code>main()</code>方法中访问该变量并输出结果。</p><div class="language-java" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">public</span><span style="color:#FF9492;"> class</span><span style="color:#FFB757;"> StaticVar</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  public</span><span style="color:#FF9492;"> static</span><span style="color:#F0F3F6;"> String</span><span style="color:#F0F3F6;"> str1</span><span style="color:#FF9492;"> =</span><span style="color:#ADDCFF;"> &quot;Hello&quot;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">  public</span><span style="color:#FF9492;"> static</span><span style="color:#FF9492;"> void</span><span style="color:#DBB7FF;"> main</span><span style="color:#F0F3F6;">(</span><span style="color:#FF9492;">String</span><span style="color:#F0F3F6;">[] </span><span style="color:#FFB757;">args</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#F0F3F6;">    String</span><span style="color:#F0F3F6;"> str2</span><span style="color:#FF9492;"> =</span><span style="color:#ADDCFF;"> &quot;World!&quot;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#BDC4CC;">    // 直接访问str1</span></span>
<span class="line"><span style="color:#F0F3F6;">    String</span><span style="color:#F0F3F6;"> accessVar1</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> str1</span><span style="color:#FF9492;">+</span><span style="color:#F0F3F6;">str2;</span></span>
<span class="line"><span style="color:#F0F3F6;">    System.out.</span><span style="color:#DBB7FF;">println</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;第 1 次访问静态变量，结果为：&quot;</span><span style="color:#FF9492;">+</span><span style="color:#F0F3F6;">accessVar1);</span></span>
<span class="line"><span style="color:#BDC4CC;">    // 通过类名访问str1</span></span>
<span class="line"><span style="color:#F0F3F6;">    String</span><span style="color:#F0F3F6;"> accessVar2</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> StaticVar.str1</span><span style="color:#FF9492;">+</span><span style="color:#F0F3F6;">str2;</span></span>
<span class="line"><span style="color:#F0F3F6;">    System.out.</span><span style="color:#DBB7FF;">println</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;第 2 次访问静态变量，结果为：&quot;</span><span style="color:#FF9492;">+</span><span style="color:#F0F3F6;">accessVar2);</span></span>
<span class="line"><span style="color:#BDC4CC;">    // 通过对象svt1访问str1</span></span>
<span class="line"><span style="color:#F0F3F6;">    StaticVar</span><span style="color:#F0F3F6;"> svt1</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> StaticVar</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#F0F3F6;">    svt1.str1 </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> svt1.str1</span><span style="color:#FF9492;">+</span><span style="color:#F0F3F6;">str2;</span></span>
<span class="line"><span style="color:#F0F3F6;">    String</span><span style="color:#F0F3F6;"> accessVar3</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> svt1.str1;</span></span>
<span class="line"><span style="color:#F0F3F6;">    System.out.</span><span style="color:#DBB7FF;">println</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;第3次访向静态变量，结果为：&quot;</span><span style="color:#FF9492;">+</span><span style="color:#F0F3F6;">accessVar3);</span></span>
<span class="line"><span style="color:#BDC4CC;">    // 通过对象svt2访问str1</span></span>
<span class="line"><span style="color:#F0F3F6;">    StaticVar</span><span style="color:#F0F3F6;"> svt2</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> StaticVar</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#F0F3F6;">    String</span><span style="color:#F0F3F6;"> accessVar4</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> svt2.str1</span><span style="color:#FF9492;">+</span><span style="color:#F0F3F6;">str2;</span></span>
<span class="line"><span style="color:#F0F3F6;">    System.out.</span><span style="color:#DBB7FF;">println</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;第 4 次访问静态变量，结果为：&quot;</span><span style="color:#FF9492;">+</span><span style="color:#F0F3F6;">accessVar4);</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>运行该程序后的结果如下所示。</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>第 1 次访问静态变量，结果为：HelloWorld!</span></span>
<span class="line"><span>第 2 次访问静态变量，结果为：HelloWorld!</span></span>
<span class="line"><span>第 3 次访向静态变量，结果为：HelloWorld!</span></span>
<span class="line"><span>第 4 次访问静态变量，结果为：HelloWorld!World!</span></span></code></pre></div><p>从运行结果可以看出，在类中定义静态的属性（成员变量），在<code>main()</code>方法中可以直接访问，也可以通过类名访问，还可以通过类的实例对象来访问。</p><p>注意：静态变量是被多个实例所共享的。</p><h3 id="静态方法" tabindex="-1"><a class="header-anchor" href="#静态方法"><span>静态方法</span></a></h3><p>与成员变量类似，成员方法也可以分为以下两种：</p><ul><li>静态方法（或称为类方法），指被<code>static</code>修饰的成员方法。</li><li>实例方法，指没有被<code>static</code>修饰的成员方法。</li></ul><p>静态方法与实例方法的区别如下：</p><ul><li>静态方法不需要通过它所属的类的任何实例就可以被调用，因此在静态方法中不能使用<code>this</code>关键字，也不能直接访问所属类的实例变量和实例方法，但是可以直接访问所属类的静态变量和静态方法。另外，和<code>this</code>关键字一样，<code>super</code>关键字也与类的特定实例相关，所以在静态方法中也不能使用<code>super</code>关键字。</li><li>在实例方法中可以直接访问所属类的静态变量、静态方法、实例变量和实例方法。</li></ul><p>创建一个带静态变量的类，添加几个静态方法对静态变量的值进行修改，然后在<code>main()</code>方法中调用静态方法并输出结果。</p><div class="language-java" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">public</span><span style="color:#FF9492;"> class</span><span style="color:#FFB757;"> StaticMethod</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  public</span><span style="color:#FF9492;"> static</span><span style="color:#FF9492;"> int</span><span style="color:#F0F3F6;"> count</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> 1</span><span style="color:#F0F3F6;">;    </span><span style="color:#BDC4CC;">// 定义静态变量count</span></span>
<span class="line"><span style="color:#FF9492;">  public</span><span style="color:#FF9492;"> int</span><span style="color:#DBB7FF;"> method1</span><span style="color:#F0F3F6;">() {    </span></span>
<span class="line"><span style="color:#BDC4CC;">    // 实例方法method1</span></span>
<span class="line"><span style="color:#F0F3F6;">    count</span><span style="color:#FF9492;">++</span><span style="color:#F0F3F6;">;    </span><span style="color:#BDC4CC;">// 访问静态变量count并赋值</span></span>
<span class="line"><span style="color:#F0F3F6;">    System.out.</span><span style="color:#DBB7FF;">println</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;在静态方法 method1()中的 count=&quot;</span><span style="color:#FF9492;">+</span><span style="color:#F0F3F6;">count);    </span><span style="color:#BDC4CC;">// 打印count</span></span>
<span class="line"><span style="color:#FF9492;">    return</span><span style="color:#F0F3F6;"> count;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#FF9492;">  public</span><span style="color:#FF9492;"> static</span><span style="color:#FF9492;"> int</span><span style="color:#DBB7FF;"> method2</span><span style="color:#F0F3F6;">() {    </span></span>
<span class="line"><span style="color:#BDC4CC;">    // 静态方法method2</span></span>
<span class="line"><span style="color:#F0F3F6;">    count </span><span style="color:#FF9492;">+=</span><span style="color:#F0F3F6;"> count;    </span><span style="color:#BDC4CC;">// 访问静态变量count并赋值</span></span>
<span class="line"><span style="color:#F0F3F6;">    System.out.</span><span style="color:#DBB7FF;">println</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;在静态方法 method2()中的 count=&quot;</span><span style="color:#FF9492;">+</span><span style="color:#F0F3F6;">count);    </span><span style="color:#BDC4CC;">// 打印count</span></span>
<span class="line"><span style="color:#FF9492;">    return</span><span style="color:#F0F3F6;"> count;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#FF9492;">  public</span><span style="color:#FF9492;"> static</span><span style="color:#FF9492;"> void</span><span style="color:#DBB7FF;"> PrintCount</span><span style="color:#F0F3F6;">() {    </span></span>
<span class="line"><span style="color:#BDC4CC;">    // 静态方法PrintCount</span></span>
<span class="line"><span style="color:#F0F3F6;">    count </span><span style="color:#FF9492;">+=</span><span style="color:#91CBFF;"> 2</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">    System.out.</span><span style="color:#DBB7FF;">println</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;在静态方法 PrintCount()中的 count=&quot;</span><span style="color:#FF9492;">+</span><span style="color:#F0F3F6;">count);    </span><span style="color:#BDC4CC;">// 打印count</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#FF9492;">  public</span><span style="color:#FF9492;"> static</span><span style="color:#FF9492;"> void</span><span style="color:#DBB7FF;"> main</span><span style="color:#F0F3F6;">(</span><span style="color:#FF9492;">String</span><span style="color:#F0F3F6;">[] </span><span style="color:#FFB757;">args</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#F0F3F6;">    StaticMethod</span><span style="color:#F0F3F6;"> sft</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> StaticMethod</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#BDC4CC;">    // 通过实例对象调用实例方法</span></span>
<span class="line"><span style="color:#F0F3F6;">    System.out.</span><span style="color:#DBB7FF;">println</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;method1() 方法返回值 intro1=&quot;</span><span style="color:#FF9492;">+</span><span style="color:#F0F3F6;">sft.</span><span style="color:#DBB7FF;">method1</span><span style="color:#F0F3F6;">());</span></span>
<span class="line"><span style="color:#BDC4CC;">    // 直接调用静态方法</span></span>
<span class="line"><span style="color:#F0F3F6;">    System.out.</span><span style="color:#DBB7FF;">println</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;method2() 方法返回值 intro1=&quot;</span><span style="color:#FF9492;">+</span><span style="color:#DBB7FF;">method2</span><span style="color:#F0F3F6;">());</span></span>
<span class="line"><span style="color:#BDC4CC;">    // 通过类名调用静态方法，打印 count</span></span>
<span class="line"><span style="color:#F0F3F6;">    StaticMethod.</span><span style="color:#DBB7FF;">PrintCount</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>运行该程序后的结果如下所示。</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>在静态方法 method1()中的 count=2</span></span>
<span class="line"><span>method1() 方法返回值 intro1=2</span></span>
<span class="line"><span>在静态方法 method2()中的 count=4</span></span>
<span class="line"><span>method2() 方法返回值 intro1=4</span></span>
<span class="line"><span>在静态方法 PrintCount()中的 count=6</span></span></code></pre></div><p>在该程序中，静态变量<code>count</code>作为实例之间的共享数据，因此在不同的方法中调用<code>count</code>，值是不一样的。从该程序中可以看出，在静态方法<code>method1()</code>和<code>PrintCount()</code>中是不可以调用非静态方法<code>method1()</code>的，而在<code>method1()</code>方法中可以调用静态方法<code>method2()</code>和<code>PrintCount()</code>。</p><p>在访问非静态方法时，需要通过实例对象来访问，而在访问静态方法时，可以直接访问，也可以通过类名来访问，还可以通过实例化对象来访问。</p><h3 id="静态代码块" tabindex="-1"><a class="header-anchor" href="#静态代码块"><span>静态代码块</span></a></h3><p>静态代码块指 Java 类中的<code>static{ }</code>代码块，主要用于初始化类，为类的静态变量赋初始值，提升程序性能。</p><p>静态代码块的特点如下：</p><ul><li>静态代码块类似于一个方法，但它不可以存在于任何方法体中。</li><li>静态代码块可以置于类中的任何地方，类中可以有多个静态初始化块。</li><li>Java 虚拟机在加载类时执行静态代码块，所以很多时候会将一些只需要进行一次的初始化操作都放在<code>static</code>代码块中进行。</li><li>如果类中包含多个静态代码块，则 Java 虚拟机将按它们在类中出现的顺序依次执行它们，每个静态代码块只会被执行一次。</li><li>静态代码块与静态方法一样，不能直接访问类的实例变量和实例方法，而需要通过类的实例对象来访问。</li></ul><p>编写一个 Java 类，在类中定义一个静态变量，然后使用静态代码块修改静态变量的值。最后在 main() 方法中进行测试和输出。</p><div class="language-java" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">public</span><span style="color:#FF9492;"> class</span><span style="color:#FFB757;"> StaticCode</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  public</span><span style="color:#FF9492;"> static</span><span style="color:#FF9492;"> int</span><span style="color:#F0F3F6;"> count</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> 0</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">  {</span></span>
<span class="line"><span style="color:#F0F3F6;">    count</span><span style="color:#FF9492;">++</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">    System.out.</span><span style="color:#DBB7FF;">println</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;非静态代码块 count=&quot;</span><span style="color:#FF9492;"> +</span><span style="color:#F0F3F6;"> count);</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#FF9492;">  static</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">    count</span><span style="color:#FF9492;">++</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">    System.out.</span><span style="color:#DBB7FF;">println</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;静态代码块1 count=&quot;</span><span style="color:#FF9492;"> +</span><span style="color:#F0F3F6;"> count);</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#FF9492;">  static</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">    count</span><span style="color:#FF9492;">++</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">    System.out.</span><span style="color:#DBB7FF;">println</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;静态代码块2 count=&quot;</span><span style="color:#FF9492;"> +</span><span style="color:#F0F3F6;"> count);</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#FF9492;">  public</span><span style="color:#FF9492;"> static</span><span style="color:#FF9492;"> void</span><span style="color:#DBB7FF;"> main</span><span style="color:#F0F3F6;">(</span><span style="color:#FF9492;">String</span><span style="color:#F0F3F6;">[] </span><span style="color:#FFB757;">args</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#F0F3F6;">    System.out.</span><span style="color:#DBB7FF;">println</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;*************** StaticCode1 执行 ***************&quot;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#F0F3F6;">    StaticCode</span><span style="color:#F0F3F6;"> sct1</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> StaticCode</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#F0F3F6;">    System.out.</span><span style="color:#DBB7FF;">println</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;*************** StaticCode2 执行 ***************&quot;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#F0F3F6;">    StaticCode</span><span style="color:#F0F3F6;"> sct2</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> StaticCode</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>如上述示例，为了说明静态代码块只被执行一次，特地添加了非静态代码块作为对比，并在主方法中创建了两个类的实例对象。上述示例的执行结果为：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>静态代码块1 count=1</span></span>
<span class="line"><span>静态代码块2 count=2</span></span>
<span class="line"><span>*************** StaticCode1 执行 ***************</span></span>
<span class="line"><span>非静态代码块 count=3</span></span>
<span class="line"><span>*************** StaticCode2 执行 ***************</span></span>
<span class="line"><span>非静态代码块 count=4</span></span></code></pre></div><p>上述代码中<code>{ }</code>代码块为非静态代码块，非静态代码块是在创建对象时自动执行的代码，不创建对象不执行该类的非静态代码块。代码域中定义的变量都是局部的，只有域中的代码可以调用。</p><h2 id="final修饰符" tabindex="-1"><a class="header-anchor" href="#final修饰符"><span>final修饰符</span></a></h2><p><code>final</code>在 Java 中的意思是最终，表示对象是最终形态的，不可改变的意思。<code>final</code>应用于类、方法和变量时意义是不同的，但本质是一样的，都表示不可改变。</p><p>使用<code>final</code>关键字声明类、变量和方法需要注意以下几点：</p><ul><li><code>final</code>用在变量的前面表示变量的值不可以改变，此时该变量可以被称为常量。</li><li><code>final</code>用在方法的前面表示方法不可以被重写。</li><li><code>final</code>用在类的前面表示该类不能有子类，即该类不可以被继承。</li></ul><h3 id="final-修饰变量" tabindex="-1"><a class="header-anchor" href="#final-修饰变量"><span>final 修饰变量</span></a></h3><p><code>final</code>修饰的变量即成为常量，只能赋值一次，但是<code>final</code>所修饰局部变量和成员变量有所不同。</p><ul><li><code>final</code>修饰的局部变量必须使用之前被赋值一次才能使用。</li><li><code>final</code>修饰的成员变量在声明时没有赋值的叫“空白<code>final</code>变量”。空白<code>final</code>变量必须在构造方法或静态代码块中初始化。</li></ul><blockquote><p>注意：<code>final</code>修饰的变量不能被赋值这种说法是错误的，严格的说法是，<code>final</code>修饰的变量不可被改变，一旦获得了初始值，该<code>final</code>变量的值就不能被重新赋值。</p></blockquote><p>当使用<code>final</code>修饰基本类型变量时，不能对基本类型变量重新赋值，因此基本类型变量不能被改变。 但对于引用类型变量而言，它保存的仅仅是一个引用，final 只保证这个引用类型变量所引用的地址不会改变，即一直引用同一个对象，但这个对象完全可以发生改变。</p><p>如果一个程序中的变量使用<code>public static final</code>声明，则此变量将称为全局变量。</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>public static final String SEX= &quot;女&quot;;</span></span></code></pre></div><h3 id="final修饰方法" tabindex="-1"><a class="header-anchor" href="#final修饰方法"><span>final修饰方法</span></a></h3><p><code>final</code>修饰的方法不可被重写，如果出于某些原因，不希望子类重写父类的某个方法，则可以使用<code>final</code>修饰该方法。</p><p>Java 提供的<code>Object</code>类里就有一个<code>final</code>方法<code>getClass()</code>，因为 Java 不希望任何类重写这个方法，所以使用<code>final</code>把这个方法密封起来。但对于该类提供的<code>toString()</code>和<code>equals()</code>方法，都允许子类重写，因此没有使用<code>final</code>修饰它们。</p><div class="language-java" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">public</span><span style="color:#FF9492;"> class</span><span style="color:#FFB757;"> FinalMethodTest</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  public</span><span style="color:#FF9492;"> final</span><span style="color:#FF9492;"> void</span><span style="color:#DBB7FF;"> test</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Sub</span><span style="color:#FF9492;"> extends</span><span style="color:#91CBFF;"> FinalMethodTest</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#BDC4CC;">  // 下面方法定义将出现编译错误，不能重写final方法</span></span>
<span class="line"><span style="color:#FF9492;">  public</span><span style="color:#FF9492;"> void</span><span style="color:#DBB7FF;"> test</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面程序中父类是<code>FinalMethodTest</code>，该类里定义的<code>test()</code>方法是一个<code>final</code>方法，如果其子类试图重写该方法，将会引发编译错误。</p><p>对于一个<code>private</code>方法，因为它仅在当前类中可见，其子类无法访问该方法，所以子类无法重写该方法——如果子类中定义一个与父类<code>private</code>方法有相同方法名、相同形参列表、相同返回值类型的方法，也不是方法重写，只是重新定义了一个新方法。因此，即使使用<code>final</code>修饰一个<code>private</code>访问权限的方法，依然可以在其子类中定义与该方法具有相同方法名、相同形参列表、相同返回值类型的方法。</p><div class="language-java" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">public</span><span style="color:#FF9492;"> class</span><span style="color:#FFB757;"> PrivateFinalMethodTest</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  private</span><span style="color:#FF9492;"> final</span><span style="color:#FF9492;"> void</span><span style="color:#DBB7FF;"> test</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Sub</span><span style="color:#FF9492;"> extends</span><span style="color:#91CBFF;"> PrivateFinalMethodTest</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#BDC4CC;">  // 下面的方法定义不会出现问题</span></span>
<span class="line"><span style="color:#FF9492;">  public</span><span style="color:#FF9492;"> void</span><span style="color:#DBB7FF;"> test</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面程序没有任何问题，虽然子类和父类同样包含了同名的<code>void test()</code>方法，但子类并不是重写父类的方法，因此即使父类的<code>void test()</code>方法使用了<code>final</code>修饰，子类中依然可以定义<code>void test()</code>方法。</p><p><code>final</code>修饰的方法仅仅是不能被重写，并不是不能被重载，因此下面程序完全没有问题。</p><div class="language-java" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">public</span><span style="color:#FF9492;"> class</span><span style="color:#FFB757;"> FinalOverload</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#BDC4CC;">  // final 修饰的方法只是不能被重写，完全可以被重载</span></span>
<span class="line"><span style="color:#FF9492;">  public</span><span style="color:#FF9492;"> final</span><span style="color:#FF9492;"> void</span><span style="color:#DBB7FF;"> test</span><span style="color:#F0F3F6;">(){}</span></span>
<span class="line"><span style="color:#FF9492;">  public</span><span style="color:#FF9492;"> final</span><span style="color:#FF9492;"> void</span><span style="color:#DBB7FF;"> test</span><span style="color:#F0F3F6;">(String </span><span style="color:#FFB757;">arg</span><span style="color:#F0F3F6;">){}</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><h3 id="final修饰类" tabindex="-1"><a class="header-anchor" href="#final修饰类"><span>final修饰类</span></a></h3><p><code>final</code>修饰的类不能被继承。当子类继承父类时，将可以访问到父类内部数据，并可通过重写父类方法来改变父类方法的实现细节，这可能导致一些不安全的因素。为了保证某个类不可被继承，则可以使用<code>final</code>修饰这个类。</p><div class="language-java" data-highlighter="shiki" data-ext="java" data-title="java" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">final</span><span style="color:#FF9492;"> class</span><span style="color:#FFB757;"> SuperClass</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> SubClass</span><span style="color:#FF9492;"> extends</span><span style="color:#91CBFF;"> SuperClass</span><span style="color:#F0F3F6;"> {    </span><span style="color:#BDC4CC;">//编译错误</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><h3 id="final-修饰符使用总结" tabindex="-1"><a class="header-anchor" href="#final-修饰符使用总结"><span>final 修饰符使用总结</span></a></h3><ol><li><code>final</code>修饰类中的变量<br> 表示该变量一旦被初始化便不可改变，这里不可改变的意思对基本类型变量来说是其值不可变，而对对象引用类型变量来说其引用不可再变。其初始化可以在两个地方：一是其定义处，也就是说在<code>final</code>变量定义时直接给其赋值；二是在构造方法中。这两个地方只能选其一，要么在定义时给值，要么在构造方法中给值，不能同时既在定义时赋值，又在构造方法中赋予另外的值。</li><li><code>final</code>修饰类中的方法<br> 说明这种方法提供的功能已经满足当前要求，不需要进行扩展，并且也不允许任何从此类继承的类来重写这种方法，但是继承仍然可以继承这个方法，也就是说可以直接使用。在声明类中，一个<code>final</code>方法只被实现一次。</li><li><code>final</code>修饰类<br> 表示该类是无法被任何其他类继承的，意味着此类在一个继承树中是一个叶子类，并且此类的设计已被认为很完美而不需要进行修改或扩展。</li></ol><p>对于<code>final</code>类中的成员，可以定义其为<code>final</code>，也可以不是<code>final</code>。而对于方法，由于所属类为<code>final</code>的关系，自然也就成了<code>final</code>型。也可以明确地给<code>final</code>类中的方法加上一个<code>final</code>，这显然没有意义。</p>`,81)]))}const r=a(p,[["render",e],["__file","Java修饰符和关键字.html.vue"]]),i=JSON.parse('{"path":"/java/java%E5%9F%BA%E7%A1%80/Java%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%92%8C%E5%85%B3%E9%94%AE%E5%AD%97.html","title":"","lang":"zh-CN","frontmatter":{"description":"访问控制修饰符 在 Java 语言中提供了多个作用域修饰符，其中常用的有public、private、protected、final、abstract、static、transient和volatile，这些修饰符有类修饰符、变量修饰符和方法修饰符。 通过使用访问控制修饰符来限制对对象私有属性的访问，可以获得 3 个重要的好处。 防止对封装数据的未授权...","head":[["meta",{"property":"og:url","content":"https://wsq01.github.io/wsq-blog/java/java%E5%9F%BA%E7%A1%80/Java%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%92%8C%E5%85%B3%E9%94%AE%E5%AD%97.html"}],["meta",{"property":"og:description","content":"访问控制修饰符 在 Java 语言中提供了多个作用域修饰符，其中常用的有public、private、protected、final、abstract、static、transient和volatile，这些修饰符有类修饰符、变量修饰符和方法修饰符。 通过使用访问控制修饰符来限制对对象私有属性的访问，可以获得 3 个重要的好处。 防止对封装数据的未授权..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-11-01T01:55:29.000Z"}],["meta",{"property":"article:modified_time","content":"2024-11-01T01:55:29.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-11-01T01:55:29.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"WSQ\\",\\"url\\":\\"https://wsq01.github.com\\"}]}"]]},"headers":[{"level":2,"title":"访问控制修饰符","slug":"访问控制修饰符","link":"#访问控制修饰符","children":[]},{"level":2,"title":"static关键字","slug":"static关键字","link":"#static关键字","children":[{"level":3,"title":"静态变量","slug":"静态变量","link":"#静态变量","children":[]},{"level":3,"title":"静态方法","slug":"静态方法","link":"#静态方法","children":[]},{"level":3,"title":"静态代码块","slug":"静态代码块","link":"#静态代码块","children":[]}]},{"level":2,"title":"final修饰符","slug":"final修饰符","link":"#final修饰符","children":[{"level":3,"title":"final 修饰变量","slug":"final-修饰变量","link":"#final-修饰变量","children":[]},{"level":3,"title":"final修饰方法","slug":"final修饰方法","link":"#final修饰方法","children":[]},{"level":3,"title":"final修饰类","slug":"final修饰类","link":"#final修饰类","children":[]},{"level":3,"title":"final 修饰符使用总结","slug":"final-修饰符使用总结","link":"#final-修饰符使用总结","children":[]}]}],"git":{"createdTime":1730426129000,"updatedTime":1730426129000,"contributors":[{"name":"WSQ","email":"592786982@qq.com","commits":1}]},"readingTime":{"minutes":15.36,"words":4609},"filePathRelative":"java/java基础/Java修饰符和关键字.md","localizedDate":"2024年11月1日","autoDesc":true}');export{r as comp,i as data};
