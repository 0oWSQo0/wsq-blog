import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,d as l,o as p}from"./app-Coac0FJ0.js";const o={};function e(F,s){return p(),n("div",null,s[0]||(s[0]=[l(`<p><code>interface</code>是对象的模板，可以看作是一种类型约定，中文译为“接口”。使用了某个模板的对象，就拥有了指定的类型结构。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">interface</span><span style="color:#FFB757;"> Person</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FFB757;">  firstName</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> string</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FFB757;">  lastName</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> string</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FFB757;">  age</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> number</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面示例中，定义了一个接口<code>Person</code>，它指定一个对象模板，拥有三个属性<code>firstName、lastName</code>和<code>age</code>。任何实现这个接口的对象，都必须部署这三个属性，并且必须符合规定的类型。</p><p>实现该接口很简单，只要指定它作为对象的类型即可。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> p</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;">Person</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">  firstName: </span><span style="color:#ADDCFF;">&#39;John&#39;</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#F0F3F6;">  lastName: </span><span style="color:#ADDCFF;">&#39;Smith&#39;</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#F0F3F6;">  age: </span><span style="color:#91CBFF;">25</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span></code></pre></div><p>上面示例中，变量<code>p</code>的类型就是接口<code>Person</code>，所以必须符合<code>Person</code>指定的结构。</p><p>方括号运算符可以取出<code>interface</code>某个属性的类型。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">interface</span><span style="color:#FFB757;"> Foo</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FFB757;">  a</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> string</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">type</span><span style="color:#FFB757;"> A</span><span style="color:#FF9492;"> =</span><span style="color:#FFB757;"> Foo</span><span style="color:#F0F3F6;">[</span><span style="color:#ADDCFF;">&#39;a&#39;</span><span style="color:#F0F3F6;">]; </span><span style="color:#BDC4CC;">// string</span></span></code></pre></div><p>上面示例中，<code>Foo[&#39;a&#39;]</code>返回属性<code>a</code>的类型，所以类型<code>A</code>就是<code>string</code>。</p><p><code>interface</code>可以表示对象的各种语法，它的成员有5种形式。</p><p>对象属性<br> 对象的属性索引<br> 对象方法<br> 函数<br> 构造函数<br> （1）对象属性</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">interface</span><span style="color:#FFB757;"> Point</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FFB757;">  x</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> number</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FFB757;">  y</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> number</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面示例中，<code>x</code>和<code>y</code>都是对象的属性，分别使用冒号指定每个属性的类型。</p><p>属性之间使用分号或逗号分隔，最后一个属性结尾的分号或逗号可以省略。</p><p>如果属性是可选的，就在属性名后面加一个问号。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">interface</span><span style="color:#FFB757;"> Foo</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FFB757;">  x</span><span style="color:#FF9492;">?:</span><span style="color:#91CBFF;"> string</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>如果属性是只读的，需要加上<code>readonly</code>修饰符。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">interface</span><span style="color:#FFB757;"> A</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  readonly</span><span style="color:#FFB757;"> a</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> string</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>（2）对象的属性索引</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">interface</span><span style="color:#FFB757;"> A</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">  [</span><span style="color:#FFB757;">prop</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> string</span><span style="color:#F0F3F6;">]</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> number</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面示例中，<code>[prop: string]</code>就是属性的字符串索引，表示属性名只要是字符串，都符合类型要求。</p><p>属性索引共有<code>string、number</code>和<code>symbol</code>三种类型。</p><p>一个接口中，最多只能定义一个字符串索引。字符串索引会约束该类型中所有名字为字符串的属性。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">interface</span><span style="color:#FFB757;"> MyObj</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">  [</span><span style="color:#FFB757;">prop</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> string</span><span style="color:#F0F3F6;">]</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> number</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FFB757;">  a</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> boolean</span><span style="color:#F0F3F6;">;      </span><span style="color:#BDC4CC;">// 编译错误</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面示例中，属性索引指定所有名称为字符串的属性，它们的属性值必须是数值（<code>number</code>）。属性<code>a</code>的值为布尔值就报错了。</p><p>属性的数值索引，其实是指定数组的类型。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">interface</span><span style="color:#FFB757;"> A</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">  [</span><span style="color:#FFB757;">prop</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> number</span><span style="color:#F0F3F6;">]</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> string</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> obj</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;">A</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> [</span><span style="color:#ADDCFF;">&#39;a&#39;</span><span style="color:#F0F3F6;">, </span><span style="color:#ADDCFF;">&#39;b&#39;</span><span style="color:#F0F3F6;">, </span><span style="color:#ADDCFF;">&#39;c&#39;</span><span style="color:#F0F3F6;">];</span></span></code></pre></div><p>上面示例中，<code>[prop: number]</code>表示属性名的类型是数值，所以可以用数组对变量obj赋值。</p><p>同样的，一个接口中最多只能定义一个数值索引。数值索引会约束所有名称为数值的属性。</p><p>如果一个<code>interface</code>同时定义了字符串索引和数值索引，那么数值索引必须服从于字符串索引。因为在 JavaScript 中，数值属性名最终是自动转换成字符串属性名。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">interface</span><span style="color:#FFB757;"> A</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">  [</span><span style="color:#FFB757;">prop</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> string</span><span style="color:#F0F3F6;">]</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> number</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">  [</span><span style="color:#FFB757;">prop</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> number</span><span style="color:#F0F3F6;">]</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> string</span><span style="color:#F0F3F6;">; </span><span style="color:#BDC4CC;">// 报错</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">interface</span><span style="color:#FFB757;"> B</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">  [</span><span style="color:#FFB757;">prop</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> string</span><span style="color:#F0F3F6;">]</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> number</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">  [</span><span style="color:#FFB757;">prop</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> number</span><span style="color:#F0F3F6;">]</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> number</span><span style="color:#F0F3F6;">; </span><span style="color:#BDC4CC;">// 正确</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面示例中，数值索引的属性值类型与字符串索引不一致，就会报错。数值索引必须兼容字符串索引的类型声明。</p><p>（3）对象的方法</p><p>对象的方法共有三种写法。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">// 写法一</span></span>
<span class="line"><span style="color:#FF9492;">interface</span><span style="color:#FFB757;"> A</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#DBB7FF;">  f</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">x</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> boolean</span><span style="color:#F0F3F6;">)</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> string</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;">// 写法二</span></span>
<span class="line"><span style="color:#FF9492;">interface</span><span style="color:#FFB757;"> B</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#DBB7FF;">  f</span><span style="color:#FF9492;">:</span><span style="color:#F0F3F6;"> (</span><span style="color:#FFB757;">x</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> boolean</span><span style="color:#F0F3F6;">) </span><span style="color:#FF9492;">=&gt;</span><span style="color:#91CBFF;"> string</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;">// 写法三</span></span>
<span class="line"><span style="color:#FF9492;">interface</span><span style="color:#FFB757;"> C</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FFB757;">  f</span><span style="color:#FF9492;">:</span><span style="color:#F0F3F6;"> { (</span><span style="color:#FFB757;">x</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> boolean</span><span style="color:#F0F3F6;">)</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> string</span><span style="color:#F0F3F6;"> };</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>属性名可以采用表达式，所以下面的写法也是可以的。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> f</span><span style="color:#FF9492;"> =</span><span style="color:#ADDCFF;"> &#39;f&#39;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">interface</span><span style="color:#FFB757;"> A</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">  [f](</span><span style="color:#FFB757;">x</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> boolean</span><span style="color:#F0F3F6;">)</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> string</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>类型方法可以重载。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">interface</span><span style="color:#FFB757;"> A</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#DBB7FF;">  f</span><span style="color:#F0F3F6;">()</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> number</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#DBB7FF;">  f</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">x</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> boolean</span><span style="color:#F0F3F6;">)</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> boolean</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#DBB7FF;">  f</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">x</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> string</span><span style="color:#F0F3F6;">, </span><span style="color:#FFB757;">y</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> string</span><span style="color:#F0F3F6;">)</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> string</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p><code>interface</code>里面的函数重载，不需要给出实现。但是，由于对象内部定义方法时，无法使用函数重载的语法，所以需要额外在对象外部给出函数方法的实现。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">interface</span><span style="color:#FFB757;"> A</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#DBB7FF;">  f</span><span style="color:#F0F3F6;">()</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> number</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#DBB7FF;">  f</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">x</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> boolean</span><span style="color:#F0F3F6;">)</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> boolean</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#DBB7FF;">  f</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">x</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> string</span><span style="color:#F0F3F6;">, </span><span style="color:#FFB757;">y</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> string</span><span style="color:#F0F3F6;">)</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> string</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">function</span><span style="color:#DBB7FF;"> MyFunc</span><span style="color:#F0F3F6;">()</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> number</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">function</span><span style="color:#DBB7FF;"> MyFunc</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">x</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> boolean</span><span style="color:#F0F3F6;">)</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> boolean</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">function</span><span style="color:#DBB7FF;"> MyFunc</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">x</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> string</span><span style="color:#F0F3F6;">, </span><span style="color:#FFB757;">y</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> string</span><span style="color:#F0F3F6;">)</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> string</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">function</span><span style="color:#DBB7FF;"> MyFunc</span><span style="color:#F0F3F6;">(</span></span>
<span class="line"><span style="color:#FFB757;">  x</span><span style="color:#FF9492;">?:</span><span style="color:#91CBFF;">boolean</span><span style="color:#FF9492;">|</span><span style="color:#91CBFF;">string</span><span style="color:#F0F3F6;">, </span><span style="color:#FFB757;">y</span><span style="color:#FF9492;">?:</span><span style="color:#91CBFF;">string</span></span>
<span class="line"><span style="color:#F0F3F6;">)</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">number</span><span style="color:#FF9492;">|</span><span style="color:#91CBFF;">boolean</span><span style="color:#FF9492;">|</span><span style="color:#91CBFF;">string</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  if</span><span style="color:#F0F3F6;"> (x </span><span style="color:#FF9492;">===</span><span style="color:#91CBFF;"> undefined</span><span style="color:#FF9492;"> &amp;&amp;</span><span style="color:#F0F3F6;"> y </span><span style="color:#FF9492;">===</span><span style="color:#91CBFF;"> undefined</span><span style="color:#F0F3F6;">) </span><span style="color:#FF9492;">return</span><span style="color:#91CBFF;"> 1</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">  if</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">typeof</span><span style="color:#F0F3F6;"> x </span><span style="color:#FF9492;">===</span><span style="color:#ADDCFF;"> &#39;boolean&#39;</span><span style="color:#FF9492;"> &amp;&amp;</span><span style="color:#F0F3F6;"> y </span><span style="color:#FF9492;">===</span><span style="color:#91CBFF;"> undefined</span><span style="color:#F0F3F6;">) </span><span style="color:#FF9492;">return</span><span style="color:#91CBFF;"> true</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">  if</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">typeof</span><span style="color:#F0F3F6;"> x </span><span style="color:#FF9492;">===</span><span style="color:#ADDCFF;"> &#39;string&#39;</span><span style="color:#FF9492;"> &amp;&amp;</span><span style="color:#FF9492;"> typeof</span><span style="color:#F0F3F6;"> y </span><span style="color:#FF9492;">===</span><span style="color:#ADDCFF;"> &#39;string&#39;</span><span style="color:#F0F3F6;">) </span><span style="color:#FF9492;">return</span><span style="color:#ADDCFF;"> &#39;hello&#39;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">  throw</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> Error</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;wrong parameters&#39;</span><span style="color:#F0F3F6;">);  </span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> a</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;">A</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">  f: MyFunc</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面示例中，接口<code>A</code>的方法<code>f()</code>有函数重载，需要额外定义一个函数<code>MyFunc()</code>实现这个重载，然后部署接口<code>A</code>的对象<code>a</code>的属性<code>f</code>等于函数<code>MyFunc()</code>就可以了。</p><p>（4）函数</p><p><code>interface</code>也可以用来声明独立的函数。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">interface</span><span style="color:#FFB757;"> Add</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">  (</span><span style="color:#FFB757;">x</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">number</span><span style="color:#F0F3F6;">, </span><span style="color:#FFB757;">y</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">number</span><span style="color:#F0F3F6;">)</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> number</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#DBB7FF;"> myAdd</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;">Add</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> (</span><span style="color:#FFB757;">x</span><span style="color:#F0F3F6;">,</span><span style="color:#FFB757;">y</span><span style="color:#F0F3F6;">) </span><span style="color:#FF9492;">=&gt;</span><span style="color:#F0F3F6;"> x </span><span style="color:#FF9492;">+</span><span style="color:#F0F3F6;"> y;</span></span></code></pre></div><p>上面示例中，接口<code>Add</code>声明了一个函数类型。</p><p>（5）构造函数</p><p><code>interface</code>内部可以使用<code>new</code>关键字，表示构造函数。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">interface</span><span style="color:#FFB757;"> ErrorConstructor</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  new</span><span style="color:#F0F3F6;"> (</span><span style="color:#FFB757;">message</span><span style="color:#FF9492;">?:</span><span style="color:#91CBFF;"> string</span><span style="color:#F0F3F6;">)</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;"> Error</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面示例中，接口<code>ErrorConstructor</code>内部有<code>new</code>命令，表示它是一个构造函数。</p><p>TypeScript 里面，构造函数特指具有<code>constructor</code>属性的类。</p><h2 id="interface-的继承" tabindex="-1"><a class="header-anchor" href="#interface-的继承"><span>interface 的继承</span></a></h2><p><code>interface</code>可以继承其他类型，主要有下面几种情况。</p><h3 id="interface-继承-interface" tabindex="-1"><a class="header-anchor" href="#interface-继承-interface"><span>interface 继承 interface</span></a></h3><p><code>interface</code>可以使用<code>extends</code>关键字，继承其他<code>interface</code>。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">interface</span><span style="color:#FFB757;"> Shape</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FFB757;">  name</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> string</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">interface</span><span style="color:#FFB757;"> Circle</span><span style="color:#FF9492;"> extends</span><span style="color:#91CBFF;"> Shape</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FFB757;">  radius</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> number</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面示例中，<code>Circle</code>继承了<code>Shape</code>，所以<code>Circle</code>其实有两个属性<code>name</code>和<code>radius</code>。这时，<code>Circle</code>是子接口，<code>Shape</code>是父接口。</p><p><code>extends</code>关键字会从继承的接口里面拷贝属性类型，这样就不必书写重复的属性。</p><p><code>interface</code>允许多重继承。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">interface</span><span style="color:#FFB757;"> Style</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FFB757;">  color</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> string</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">interface</span><span style="color:#FFB757;"> Shape</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FFB757;">  name</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> string</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">interface</span><span style="color:#FFB757;"> Circle</span><span style="color:#FF9492;"> extends</span><span style="color:#91CBFF;"> Style</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">Shape</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FFB757;">  radius</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> number</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面示例中，<code>Circle</code>同时继承了<code>Style</code>和<code>Shape</code>，所以拥有三个属性<code>color、name</code>和<code>radius</code>。</p><p>多重接口继承，实际上相当于多个父接口的合并。</p><p>如果子接口与父接口存在同名属性，那么子接口的属性会覆盖父接口的属性。注意，子接口与父接口的同名属性必须是类型兼容的，不能有冲突，否则会报错。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">interface</span><span style="color:#FFB757;"> Foo</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FFB757;">  id</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> string</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">interface</span><span style="color:#FFB757;"> Bar</span><span style="color:#FF9492;"> extends</span><span style="color:#91CBFF;"> Foo</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FFB757;">  id</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> number</span><span style="color:#F0F3F6;">; </span><span style="color:#BDC4CC;">// 报错</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面示例中，<code>Bar</code>继承了<code>Foo</code>，但是两者的同名属性<code>id</code>的类型不兼容，导致报错。</p><p>多重继承时，如果多个父接口存在同名属性，那么这些同名属性不能有类型冲突，否则会报错。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">interface</span><span style="color:#FFB757;"> Foo</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FFB757;">  id</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> string</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">interface</span><span style="color:#FFB757;"> Bar</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FFB757;">  id</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> number</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;">// 报错</span></span>
<span class="line"><span style="color:#FF9492;">interface</span><span style="color:#FFB757;"> Baz</span><span style="color:#FF9492;"> extends</span><span style="color:#91CBFF;"> Foo</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">Bar</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FFB757;">  type</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> string</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面示例中，<code>Baz</code>同时继承了<code>Foo</code>和<code>Bar</code>，但是后两者的同名属性<code>id</code>有类型冲突，导致报错。</p><h3 id="interface-继承-type" tabindex="-1"><a class="header-anchor" href="#interface-继承-type"><span>interface 继承 type</span></a></h3><p><code>interface</code>可以继承<code>type</code>命令定义的对象类型。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">type</span><span style="color:#FFB757;"> Country</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FFB757;">  name</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> string</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FFB757;">  capital</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> string</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">interface</span><span style="color:#FFB757;"> CountryWithPop</span><span style="color:#FF9492;"> extends</span><span style="color:#91CBFF;"> Country</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FFB757;">  population</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> number</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面示例中，<code>CountryWithPop</code>继承了<code>type</code>命令定义的<code>Country</code>对象，并且新增了一个<code>population</code>属性。</p><p>注意，如果<code>type</code>命令定义的类型不是对象，<code>interface</code> 就无法继承。</p><h3 id="interface-继承-class" tabindex="-1"><a class="header-anchor" href="#interface-继承-class"><span>interface 继承 class</span></a></h3><p><code>interface</code>还可以继承<code>class</code>，即继承该类的所有成员。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> A</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FFB757;">  x</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">string</span><span style="color:#FF9492;"> =</span><span style="color:#ADDCFF;"> &#39;&#39;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#DBB7FF;">  y</span><span style="color:#F0F3F6;">()</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">boolean</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">    return</span><span style="color:#91CBFF;"> true</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">interface</span><span style="color:#FFB757;"> B</span><span style="color:#FF9492;"> extends</span><span style="color:#91CBFF;"> A</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FFB757;">  z</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> number</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面示例中，<code>B</code>继承了<code>A</code>，因此<code>B</code>就具有属性<code>x、y()</code>和<code>z</code>。</p><p>实现<code>B</code>接口的对象就需要实现这些属性。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> b</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;">B</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">  x: </span><span style="color:#ADDCFF;">&#39;&#39;</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#DBB7FF;">  y</span><span style="color:#F0F3F6;">: </span><span style="color:#FF9492;">function</span><span style="color:#F0F3F6;">(){ </span><span style="color:#FF9492;">return</span><span style="color:#91CBFF;"> true</span><span style="color:#F0F3F6;"> },</span></span>
<span class="line"><span style="color:#F0F3F6;">  z: </span><span style="color:#91CBFF;">123</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面示例中，对象<code>b</code>就实现了接口<code>B</code>，而接口<code>B</code>又继承了类<code>A</code>。</p><p>某些类拥有私有成员和保护成员，<code>interface</code>可以继承这样的类，但是意义不大。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> A</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  private</span><span style="color:#FFB757;"> x</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> string</span><span style="color:#FF9492;"> =</span><span style="color:#ADDCFF;"> &#39;&#39;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">  protected</span><span style="color:#FFB757;"> y</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> string</span><span style="color:#FF9492;"> =</span><span style="color:#ADDCFF;"> &#39;&#39;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">interface</span><span style="color:#FFB757;"> B</span><span style="color:#FF9492;"> extends</span><span style="color:#91CBFF;"> A</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FFB757;">  z</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> number</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;">// 报错</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> b</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;">B</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> { </span><span style="color:#BDC4CC;">/* ... */</span><span style="color:#F0F3F6;"> }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;">// 报错</span></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> C</span><span style="color:#FF9492;"> implements</span><span style="color:#91CBFF;"> B</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#BDC4CC;">  // ...</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面示例中，<code>A</code>有私有成员和保护成员，<code>B</code>继承了<code>A</code>，但无法用于对象，因为对象不能实现这些成员。这导致<code>B</code>只能用于其他<code>class</code>，而这时其他<code>class</code>与<code>A</code>之间不构成父类和子类的关系，使得<code>x</code>与<code>y</code>无法部署。</p><h2 id="接口合并" tabindex="-1"><a class="header-anchor" href="#接口合并"><span>接口合并</span></a></h2><p>多个同名接口会合并成一个接口。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">interface</span><span style="color:#FFB757;"> Box</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FFB757;">  height</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> number</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FFB757;">  width</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> number</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">interface</span><span style="color:#FFB757;"> Box</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FFB757;">  length</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> number</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面示例中，两个<code>Box</code>接口会合并成一个接口，同时有<code>height、width</code>和<code>length</code>三个属性。</p><p>这样的设计主要是为了兼容 JavaScript 的行为。JavaScript 开发者常常对全局对象或者外部库，添加自己的属性和方法。那么，只要使用<code>interface</code>给出这些自定义属性和方法的类型，就能自动跟原始的<code>interface</code>合并，使得扩展外部类型非常方便。</p><p>举例来说，Web 网页开发经常会对<code>window</code>对象和<code>document</code>对象添加自定义属性，但是 TypeScript 会报错，因为原始定义没有这些属性。解决方法就是把自定义属性写成<code>interface</code>，合并进原始定义。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">interface</span><span style="color:#FFB757;"> Document</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FFB757;">  foo</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> string</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">document.foo </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &#39;hello&#39;</span><span style="color:#F0F3F6;">;</span></span></code></pre></div><p>上面示例中，接口<code>Document</code>增加了一个自定义属性<code>foo</code>，从而就可以在<code>document</code>对象上使用自定义属性。</p><p>同名接口合并时，同一个属性如果有多个类型声明，彼此不能有类型冲突。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">interface</span><span style="color:#FFB757;"> A</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FFB757;">  a</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> number</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">interface</span><span style="color:#FFB757;"> A</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FFB757;">  a</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> string</span><span style="color:#F0F3F6;">; </span><span style="color:#BDC4CC;">// 报错</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面示例中，接口<code>A</code>的属性<code>a</code>有两个类型声明，彼此是冲突的，导致报错。</p><p>同名接口合并时，如果同名方法有不同的类型声明，那么会发生函数重载。而且，后面的定义比前面的定义具有更高的优先级。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">interface</span><span style="color:#FFB757;"> Cloner</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#DBB7FF;">  clone</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">animal</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;"> Animal</span><span style="color:#F0F3F6;">)</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;"> Animal</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">interface</span><span style="color:#FFB757;"> Cloner</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#DBB7FF;">  clone</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">animal</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;"> Sheep</span><span style="color:#F0F3F6;">)</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;"> Sheep</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">interface</span><span style="color:#FFB757;"> Cloner</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#DBB7FF;">  clone</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">animal</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;"> Dog</span><span style="color:#F0F3F6;">)</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;"> Dog</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#DBB7FF;">  clone</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">animal</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;"> Cat</span><span style="color:#F0F3F6;">)</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;"> Cat</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;">// 等同于</span></span>
<span class="line"><span style="color:#FF9492;">interface</span><span style="color:#FFB757;"> Cloner</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#DBB7FF;">  clone</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">animal</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;"> Dog</span><span style="color:#F0F3F6;">)</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;"> Dog</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#DBB7FF;">  clone</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">animal</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;"> Cat</span><span style="color:#F0F3F6;">)</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;"> Cat</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#DBB7FF;">  clone</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">animal</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;"> Sheep</span><span style="color:#F0F3F6;">)</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;"> Sheep</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#DBB7FF;">  clone</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">animal</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;"> Animal</span><span style="color:#F0F3F6;">)</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;"> Animal</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面示例中，<code>clone()</code>方法有不同的类型声明，会发生函数重载。这时，越靠后的定义，优先级越高，排在函数重载的越前面。比如，<code>clone(animal: Animal)</code>是最先出现的类型声明，就排在函数重载的最后，属于<code>clone()</code>函数最后匹配的类型。</p><p>这个规则有一个例外。同名方法之中，如果有一个参数是字面量类型，字面量类型有更高的优先级。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">interface</span><span style="color:#FFB757;"> A</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#DBB7FF;">  f</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">x</span><span style="color:#FF9492;">:</span><span style="color:#ADDCFF;">&#39;foo&#39;</span><span style="color:#F0F3F6;">)</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> boolean</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">interface</span><span style="color:#FFB757;"> A</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#DBB7FF;">  f</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">x</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">any</span><span style="color:#F0F3F6;">)</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> void</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;">// 等同于</span></span>
<span class="line"><span style="color:#FF9492;">interface</span><span style="color:#FFB757;"> A</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#DBB7FF;">  f</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">x</span><span style="color:#FF9492;">:</span><span style="color:#ADDCFF;">&#39;foo&#39;</span><span style="color:#F0F3F6;">)</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> boolean</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#DBB7FF;">  f</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">x</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">any</span><span style="color:#F0F3F6;">)</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> void</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面示例中，<code>f()</code>方法有一个类型声明的参数x是字面量类型，这个类型声明的优先级最高，会排在函数重载的最前面。</p><p>一个实际的例子是<code>Document</code>对象的<code>createElement()</code>方法，它会根据参数的不同，而生成不同的 HTML 节点对象。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">interface</span><span style="color:#FFB757;"> Document</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#DBB7FF;">  createElement</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">tagName</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> any</span><span style="color:#F0F3F6;">)</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;"> Element</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#FF9492;">interface</span><span style="color:#FFB757;"> Document</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#DBB7FF;">  createElement</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">tagName</span><span style="color:#FF9492;">:</span><span style="color:#ADDCFF;"> &quot;div&quot;</span><span style="color:#F0F3F6;">)</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;"> HTMLDivElement</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#DBB7FF;">  createElement</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">tagName</span><span style="color:#FF9492;">:</span><span style="color:#ADDCFF;"> &quot;span&quot;</span><span style="color:#F0F3F6;">)</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;"> HTMLSpanElement</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#FF9492;">interface</span><span style="color:#FFB757;"> Document</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#DBB7FF;">  createElement</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">tagName</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> string</span><span style="color:#F0F3F6;">)</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;"> HTMLElement</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#DBB7FF;">  createElement</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">tagName</span><span style="color:#FF9492;">:</span><span style="color:#ADDCFF;"> &quot;canvas&quot;</span><span style="color:#F0F3F6;">)</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;"> HTMLCanvasElement</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;">// 等同于</span></span>
<span class="line"><span style="color:#FF9492;">interface</span><span style="color:#FFB757;"> Document</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#DBB7FF;">  createElement</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">tagName</span><span style="color:#FF9492;">:</span><span style="color:#ADDCFF;"> &quot;canvas&quot;</span><span style="color:#F0F3F6;">)</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;"> HTMLCanvasElement</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#DBB7FF;">  createElement</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">tagName</span><span style="color:#FF9492;">:</span><span style="color:#ADDCFF;"> &quot;div&quot;</span><span style="color:#F0F3F6;">)</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;"> HTMLDivElement</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#DBB7FF;">  createElement</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">tagName</span><span style="color:#FF9492;">:</span><span style="color:#ADDCFF;"> &quot;span&quot;</span><span style="color:#F0F3F6;">)</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;"> HTMLSpanElement</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#DBB7FF;">  createElement</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">tagName</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> string</span><span style="color:#F0F3F6;">)</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;"> HTMLElement</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#DBB7FF;">  createElement</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">tagName</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> any</span><span style="color:#F0F3F6;">)</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;"> Element</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面示例中，<code>createElement()</code>方法的函数重载，参数为字面量的类型声明会排到最前面，返回具体的 HTML 节点对象。类型越不具体的参数，排在越后面，返回通用的 HTML 节点对象。</p><p>如果两个<code>interface</code>组成的联合类型存在同名属性，那么该属性的类型也是联合类型。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">interface</span><span style="color:#FFB757;"> Circle</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FFB757;">  area</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> bigint</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">interface</span><span style="color:#FFB757;"> Rectangle</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FFB757;">  area</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> number</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">declare</span><span style="color:#FF9492;"> const</span><span style="color:#91CBFF;"> s</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;"> Circle</span><span style="color:#FF9492;"> |</span><span style="color:#FFB757;"> Rectangle</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">s.area;   </span><span style="color:#BDC4CC;">// bigint | number</span></span></code></pre></div><p>上面示例中，接口<code>Circle</code>和<code>Rectangle</code>组成一个联合类型<code>Circle | Rectangle</code>。因此，这个联合类型的同名属性area，也是一个联合类型。本例中的<code>declare</code>命令表示变量<code>s</code>的具体定义，由其他脚本文件给出。</p><h2 id="interface-与-type-的异同" tabindex="-1"><a class="header-anchor" href="#interface-与-type-的异同"><span>interface 与 type 的异同</span></a></h2><p><code>interface</code>命令与<code>type</code>命令作用类似，都可以表示对象类型。</p><p>很多对象类型既可以用<code>interface</code>表示，也可以用<code>type</code>表示。而且，两者往往可以换用，几乎所有的<code>interface</code>命令都可以改写为<code>type</code>命令。</p><p>它们的相似之处，首先表现在都能为对象类型起名。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">type</span><span style="color:#FFB757;"> Country</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FFB757;">  name</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> string</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FFB757;">  capital</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> string</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">interface</span><span style="color:#FFB757;"> Country</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FFB757;">  name</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> string</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FFB757;">  capital</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> string</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面示例是<code>type</code>命令和<code>interface</code>命令，分别定义同一个类型。</p><p><code>class</code>命令也有类似作用，通过定义一个类，同时定义一个对象类型。但是，它会创造一个值，编译后依然存在。如果只是单纯想要一个类型，应该使用<code>type</code>或<code>interface</code>。</p><p><code>interface</code>与<code>type</code>的区别有下面几点。</p><p>（1）<code>type</code>能够表示非对象类型，而<code>interface</code>只能表示对象类型（包括数组、函数等）。</p><p>（2）<code>interface</code>可以继承其他类型，<code>type</code>不支持继承。</p><p>继承的主要作用是添加属性，<code>type</code>定义的对象类型如果想要添加属性，只能使用<code>&amp;</code>运算符，重新定义一个类型。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">type</span><span style="color:#FFB757;"> Animal</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FFB757;">  name</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> string</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">type</span><span style="color:#FFB757;"> Bear</span><span style="color:#FF9492;"> =</span><span style="color:#FFB757;"> Animal</span><span style="color:#FF9492;"> &amp;</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FFB757;">  honey</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> boolean</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面示例中，类型<code>Bear</code>在<code>Animal</code>的基础上添加了一个属性<code>honey</code>。</p><p>上例的&amp;运算符，表示同时具备两个类型的特征，因此可以起到两个对象类型合并的作用。</p><p>作为比较，<code>interface</code>添加属性，采用的是继承的写法。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">interface</span><span style="color:#FFB757;"> Animal</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FFB757;">  name</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> string</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">interface</span><span style="color:#FFB757;"> Bear</span><span style="color:#FF9492;"> extends</span><span style="color:#91CBFF;"> Animal</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FFB757;">  honey</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> boolean</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>继承时，<code>type</code>和<code>interface</code>是可以换用的。<code>interface</code>可以继承<code>type</code>。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">type</span><span style="color:#FFB757;"> Foo</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> { </span><span style="color:#FFB757;">x</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> number</span><span style="color:#F0F3F6;">; };</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">interface</span><span style="color:#FFB757;"> Bar</span><span style="color:#FF9492;"> extends</span><span style="color:#91CBFF;"> Foo</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FFB757;">  y</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> number</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p><code>type</code>也可以继承<code>interface</code>。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">interface</span><span style="color:#FFB757;"> Foo</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FFB757;">  x</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> number</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">type</span><span style="color:#FFB757;"> Bar</span><span style="color:#FF9492;"> =</span><span style="color:#FFB757;"> Foo</span><span style="color:#FF9492;"> &amp;</span><span style="color:#F0F3F6;"> { </span><span style="color:#FFB757;">y</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> number</span><span style="color:#F0F3F6;">; };</span></span></code></pre></div><p>（3）同名<code>interface</code>会自动合并，同名<code>type</code>则会报错。也就是说，TypeScript 不允许使用<code>type</code>多次定义同一个类型。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">type</span><span style="color:#FFB757;"> A</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> { </span><span style="color:#FFB757;">foo</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">number</span><span style="color:#F0F3F6;"> }; </span><span style="color:#BDC4CC;">// 报错</span></span>
<span class="line"><span style="color:#FF9492;">type</span><span style="color:#FFB757;"> A</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> { </span><span style="color:#FFB757;">bar</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">number</span><span style="color:#F0F3F6;"> }; </span><span style="color:#BDC4CC;">// 报错</span></span></code></pre></div><p>上面示例中，<code>type</code>两次定义了类型<code>A</code>，导致两行都会报错。</p><p>作为比较，<code>interface</code>则会自动合并。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">interface</span><span style="color:#FFB757;"> A</span><span style="color:#F0F3F6;"> { </span><span style="color:#FFB757;">foo</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">number</span><span style="color:#F0F3F6;"> };</span></span>
<span class="line"><span style="color:#FF9492;">interface</span><span style="color:#FFB757;"> A</span><span style="color:#F0F3F6;"> { </span><span style="color:#FFB757;">bar</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">number</span><span style="color:#F0F3F6;"> };</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> obj</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;">A</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">  foo: </span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#F0F3F6;">  bar: </span><span style="color:#91CBFF;">1</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span></code></pre></div><p>上面示例中，<code>interface</code>把类型<code>A</code>的两个定义合并在一起。</p><p>这表明，<code>interface</code>是开放的，可以添加属性，<code>type</code>是封闭的，不能添加属性，只能定义新的<code>type</code>。</p><p>（4）<code>interface</code>不能包含属性映射（<code>mapping</code>），<code>type</code>可以。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">interface</span><span style="color:#FFB757;"> Point</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FFB757;">  x</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> number</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FFB757;">  y</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> number</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;">// 正确</span></span>
<span class="line"><span style="color:#FF9492;">type</span><span style="color:#FFB757;"> PointCopy1</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">  [</span><span style="color:#FFB757;">Key</span><span style="color:#FF9492;"> in</span><span style="color:#FF9492;"> keyof</span><span style="color:#FFB757;"> Point</span><span style="color:#F0F3F6;">]</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;"> Point</span><span style="color:#F0F3F6;">[</span><span style="color:#FFB757;">Key</span><span style="color:#F0F3F6;">];</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;">// 报错</span></span>
<span class="line"><span style="color:#FF9492;">interface</span><span style="color:#FFB757;"> PointCopy2</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">  [Key </span><span style="color:#FF9492;">in</span><span style="color:#F0F3F6;"> keyof Point]</span><span style="color:#FF9492;">:</span><span style="color:#FFB757;"> Point</span><span style="color:#F0F3F6;">[</span><span style="color:#FFB757;">Key</span><span style="color:#F0F3F6;">];</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span></code></pre></div><p>（5）<code>this</code>关键字只能用于<code>interface</code>。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">// 正确</span></span>
<span class="line"><span style="color:#FF9492;">interface</span><span style="color:#FFB757;"> Foo</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#DBB7FF;">  add</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">num</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">number</span><span style="color:#F0F3F6;">)</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> this</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;">// 报错</span></span>
<span class="line"><span style="color:#FF9492;">type</span><span style="color:#FFB757;"> Foo</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#DBB7FF;">  add</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">num</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">number</span><span style="color:#F0F3F6;">)</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> this</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span></code></pre></div><p>上面示例中，<code>type</code>命令声明的方法<code>add()</code>，返回<code>this</code>就报错了。<code>interface</code>命令没有这个问题。</p><p>下面是返回<code>this</code>的实际对象的例子。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Calculator</span><span style="color:#FF9492;"> implements</span><span style="color:#91CBFF;"> Foo</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FFB757;">  result</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> 0</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#DBB7FF;">  add</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">num</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">number</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#91CBFF;">    this</span><span style="color:#F0F3F6;">.result </span><span style="color:#FF9492;">+=</span><span style="color:#F0F3F6;"> num;</span></span>
<span class="line"><span style="color:#FF9492;">    return</span><span style="color:#91CBFF;"> this</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>（6）<code>type</code>可以扩展原始数据类型，<code>interface</code>不行。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">// 正确</span></span>
<span class="line"><span style="color:#FF9492;">type</span><span style="color:#FFB757;"> MyStr</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> string</span><span style="color:#FF9492;"> &amp;</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FFB757;">  type</span><span style="color:#FF9492;">:</span><span style="color:#ADDCFF;"> &#39;new&#39;</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;">// 报错</span></span>
<span class="line"><span style="color:#FF9492;">interface</span><span style="color:#FFB757;"> MyStr</span><span style="color:#FF9492;"> extends</span><span style="color:#91CBFF;"> string</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FFB757;">  type</span><span style="color:#FF9492;">:</span><span style="color:#ADDCFF;"> &#39;new&#39;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面示例中，<code>type</code>可以扩展原始数据类型<code>string</code>，<code>interface</code>就不行。</p><p>（7）<code>interface</code>无法表达某些复杂类型（比如交叉类型和联合类型），但是<code>type</code>可以。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">type</span><span style="color:#FFB757;"> A</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> { </span><span style="color:#BDC4CC;">/* ... */</span><span style="color:#F0F3F6;"> };</span></span>
<span class="line"><span style="color:#FF9492;">type</span><span style="color:#FFB757;"> B</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> { </span><span style="color:#BDC4CC;">/* ... */</span><span style="color:#F0F3F6;"> };</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">type</span><span style="color:#FFB757;"> AorB</span><span style="color:#FF9492;"> =</span><span style="color:#FFB757;"> A</span><span style="color:#FF9492;"> |</span><span style="color:#FFB757;"> B</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">type</span><span style="color:#FFB757;"> AorBwithName</span><span style="color:#FF9492;"> =</span><span style="color:#FFB757;"> AorB</span><span style="color:#FF9492;"> &amp;</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FFB757;">  name</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> string</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span></code></pre></div><p>上面示例中，类型<code>AorB</code>是一个联合类型，<code>AorBwithName</code>则是为<code>AorB</code>添加一个属性。这两种运算，<code>interface</code>都没法表达。</p><p>综上所述，如果有复杂的类型运算，那么没有其他选择只能使用<code>type</code>；一般情况下，<code>interface</code>灵活性比较高，便于扩充类型或自动合并，建议优先使用。</p>`,147)]))}const r=a(o,[["render",e],["__file","ts的interface接口.html.vue"]]),y=JSON.parse('{"path":"/js/ts/ts%E7%9A%84interface%E6%8E%A5%E5%8F%A3.html","title":"","lang":"zh-CN","frontmatter":{"description":"interface是对象的模板，可以看作是一种类型约定，中文译为“接口”。使用了某个模板的对象，就拥有了指定的类型结构。 上面示例中，定义了一个接口Person，它指定一个对象模板，拥有三个属性firstName、lastName和age。任何实现这个接口的对象，都必须部署这三个属性，并且必须符合规定的类型。 实现该接口很简单，只要指定它作为对象的类型...","head":[["meta",{"property":"og:url","content":"https://wsq01.github.io/wsq-blog/js/ts/ts%E7%9A%84interface%E6%8E%A5%E5%8F%A3.html"}],["meta",{"property":"og:description","content":"interface是对象的模板，可以看作是一种类型约定，中文译为“接口”。使用了某个模板的对象，就拥有了指定的类型结构。 上面示例中，定义了一个接口Person，它指定一个对象模板，拥有三个属性firstName、lastName和age。任何实现这个接口的对象，都必须部署这三个属性，并且必须符合规定的类型。 实现该接口很简单，只要指定它作为对象的类型..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-09-11T05:57:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-09-11T05:57:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-09-11T05:57:00.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"WSQ\\",\\"url\\":\\"https://wsq01.github.com\\"}]}"]]},"headers":[{"level":2,"title":"interface 的继承","slug":"interface-的继承","link":"#interface-的继承","children":[{"level":3,"title":"interface 继承 interface","slug":"interface-继承-interface","link":"#interface-继承-interface","children":[]},{"level":3,"title":"interface 继承 type","slug":"interface-继承-type","link":"#interface-继承-type","children":[]},{"level":3,"title":"interface 继承 class","slug":"interface-继承-class","link":"#interface-继承-class","children":[]}]},{"level":2,"title":"接口合并","slug":"接口合并","link":"#接口合并","children":[]},{"level":2,"title":"interface 与 type 的异同","slug":"interface-与-type-的异同","link":"#interface-与-type-的异同","children":[]}],"git":{"createdTime":1726034220000,"updatedTime":1726034220000,"contributors":[{"name":"WSQ","email":"592786982@qq.com","commits":1}]},"readingTime":{"minutes":12.37,"words":3711},"filePathRelative":"js/ts/ts的interface接口.md","localizedDate":"2024年9月11日","autoDesc":true}');export{r as comp,y as data};
