import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,d as l,o as p}from"./app-ByvFWdWZ.js";const o={};function e(F,s){return p(),n("div",null,s[0]||(s[0]=[l(`<h2 id="类的由来" tabindex="-1"><a class="header-anchor" href="#类的由来"><span>类的由来</span></a></h2><p>JavaScript 中，生成实例对象的传统方法是通过构造函数。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">function</span><span style="color:#DBB7FF;"> Point</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">x</span><span style="color:#F0F3F6;">, </span><span style="color:#FFB757;">y</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#91CBFF;">  this</span><span style="color:#F0F3F6;">.x </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> x;</span></span>
<span class="line"><span style="color:#91CBFF;">  this</span><span style="color:#F0F3F6;">.y </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> y;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#91CBFF;">Point</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">prototype</span><span style="color:#F0F3F6;">.</span><span style="color:#DBB7FF;">toString</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> function</span><span style="color:#F0F3F6;"> () {</span></span>
<span class="line"><span style="color:#FF9492;">  return</span><span style="color:#ADDCFF;"> &#39;(&#39;</span><span style="color:#FF9492;"> +</span><span style="color:#91CBFF;"> this</span><span style="color:#F0F3F6;">.x </span><span style="color:#FF9492;">+</span><span style="color:#ADDCFF;"> &#39;, &#39;</span><span style="color:#FF9492;"> +</span><span style="color:#91CBFF;"> this</span><span style="color:#F0F3F6;">.y </span><span style="color:#FF9492;">+</span><span style="color:#ADDCFF;"> &#39;)&#39;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span>
<span class="line"><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> p </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> Point</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">);</span></span></code></pre></div><p>ES6引入了<code>Class</code>（类）这个概念，作为对象的模板。通过<code>class</code>关键字，可以定义类。</p><p>基本上，ES6的<code>class</code>可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的<code>class</code>写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的<code>class</code>改写，就是下面这样。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">//定义类</span></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Point</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  constructor</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">x</span><span style="color:#F0F3F6;">, </span><span style="color:#FFB757;">y</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#91CBFF;">    this</span><span style="color:#F0F3F6;">.x </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> x;</span></span>
<span class="line"><span style="color:#91CBFF;">    this</span><span style="color:#F0F3F6;">.y </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> y;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#DBB7FF;">  toString</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#FF9492;">    return</span><span style="color:#ADDCFF;"> &#39;(&#39;</span><span style="color:#FF9492;"> +</span><span style="color:#91CBFF;"> this</span><span style="color:#F0F3F6;">.x </span><span style="color:#FF9492;">+</span><span style="color:#ADDCFF;"> &#39;, &#39;</span><span style="color:#FF9492;"> +</span><span style="color:#91CBFF;"> this</span><span style="color:#F0F3F6;">.y </span><span style="color:#FF9492;">+</span><span style="color:#ADDCFF;"> &#39;)&#39;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面代码定义了一个“类”，可以看到里面有一个<code>constructor</code>方法，这就是构造方法，而<code>this</code>关键字则代表实例对象。也就是说，ES5的构造函数<code>Point</code>，对应ES6的<code>Point</code>类的构造方法。</p><p><code>Point</code>类除了构造方法，还定义了一个<code>toString</code>方法。注意，定义“类”的方法的时候，前面不需要加上<code>function</code>这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。</p><p>ES6 的类，完全可以看作构造函数的另一种写法。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Point</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#BDC4CC;">  // ...</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#FF9492;">typeof</span><span style="color:#F0F3F6;"> Point </span><span style="color:#BDC4CC;">// &quot;function&quot;</span></span>
<span class="line"><span style="color:#F0F3F6;">Point </span><span style="color:#FF9492;">===</span><span style="color:#91CBFF;"> Point</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">prototype</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">constructor</span><span style="color:#BDC4CC;"> // true</span></span></code></pre></div><p>上面代码表明，类的数据类型就是函数，类本身就指向构造函数。</p><p>使用的时候，也是直接对类使用<code>new</code>命令，跟构造函数的用法完全一致。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Bar</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#DBB7FF;">  doStuff</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#F0F3F6;">    console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;stuff&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> b </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> Bar</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#F0F3F6;">b.</span><span style="color:#DBB7FF;">doStuff</span><span style="color:#F0F3F6;">() </span><span style="color:#BDC4CC;">// &quot;stuff&quot;</span></span></code></pre></div><p>构造函数的<code>prototype</code>属性，在ES6的“类”上面继续存在。事实上，类的所有方法都定义在类的<code>prototype</code>属性上面。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Point</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  constructor</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#BDC4CC;">    // ...</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#DBB7FF;">  toString</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#BDC4CC;">    // ...</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#DBB7FF;">  toValue</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#BDC4CC;">    // ...</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#BDC4CC;">// 等同于</span></span>
<span class="line"><span style="color:#91CBFF;">Point</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">prototype</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#DBB7FF;">  constructor</span><span style="color:#F0F3F6;">() {},</span></span>
<span class="line"><span style="color:#DBB7FF;">  toString</span><span style="color:#F0F3F6;">() {},</span></span>
<span class="line"><span style="color:#DBB7FF;">  toValue</span><span style="color:#F0F3F6;">() {},</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span></code></pre></div><p>在类的实例上面调用方法，其实就是调用原型上的方法。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> B</span><span style="color:#F0F3F6;"> {}</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> b </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> B</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#F0F3F6;">b.</span><span style="color:#91CBFF;">constructor</span><span style="color:#FF9492;"> ===</span><span style="color:#91CBFF;"> B</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">prototype</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">constructor</span><span style="color:#BDC4CC;"> // true</span></span></code></pre></div><p>上面代码中，<code>b</code>是<code>B</code>类的实例，它的<code>constructor</code>方法就是<code>B</code>类原型的<code>constructor</code>方法。</p><p>由于类的方法都定义在<code>prototype</code>对象上面，所以类的新方法可以添加在<code>prototype</code>对象上面。<code>Object.assign</code>方法可以很方便地一次向类添加多个方法。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Point</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  constructor</span><span style="color:#F0F3F6;">(){</span></span>
<span class="line"><span style="color:#BDC4CC;">    // ...</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">assign</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">Point</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">prototype</span><span style="color:#F0F3F6;">, {</span></span>
<span class="line"><span style="color:#DBB7FF;">  toString</span><span style="color:#F0F3F6;">(){},</span></span>
<span class="line"><span style="color:#DBB7FF;">  toValue</span><span style="color:#F0F3F6;">(){}</span></span>
<span class="line"><span style="color:#F0F3F6;">});</span></span></code></pre></div><p><code>prototype</code>对象的<code>constructor</code>属性，直接指向“类”的本身，这与 ES5 的行为是一致的。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#91CBFF;">Point</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">prototype</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">constructor</span><span style="color:#FF9492;"> ===</span><span style="color:#F0F3F6;"> Point </span><span style="color:#BDC4CC;">// true</span></span></code></pre></div><p>另外，类的内部所有定义的方法，都是不可枚举的（<code>non-enumerable</code>）。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Point</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  constructor</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">x</span><span style="color:#F0F3F6;">, </span><span style="color:#FFB757;">y</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#BDC4CC;">    // ...</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#DBB7FF;">  toString</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#BDC4CC;">    // ...</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">keys</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">Point</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">prototype</span><span style="color:#F0F3F6;">) </span><span style="color:#BDC4CC;">// []</span></span>
<span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">getOwnPropertyNames</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">Point</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">prototype</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#BDC4CC;">// [&quot;constructor&quot;,&quot;toString&quot;]</span></span></code></pre></div><p>上面代码中，<code>toString</code>方法是<code>Point</code>类内部定义的方法，它是不可枚举的。这一点与ES5的行为不一致。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">var</span><span style="color:#DBB7FF;"> Point</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> function</span><span style="color:#F0F3F6;"> (</span><span style="color:#FFB757;">x</span><span style="color:#F0F3F6;">, </span><span style="color:#FFB757;">y</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#BDC4CC;">  // ...</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span>
<span class="line"><span style="color:#91CBFF;">Point</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">prototype</span><span style="color:#F0F3F6;">.</span><span style="color:#DBB7FF;">toString</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> function</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#BDC4CC;">  // ...</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span>
<span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">keys</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">Point</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">prototype</span><span style="color:#F0F3F6;">) </span><span style="color:#BDC4CC;">// [&quot;toString&quot;]</span></span>
<span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">getOwnPropertyNames</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">Point</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">prototype</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#BDC4CC;">// [&quot;constructor&quot;,&quot;toString&quot;]</span></span></code></pre></div><p>上面代码采用 ES5 的写法，<code>toString</code>方法就是可枚举的。</p><h2 id="constructor-方法" tabindex="-1"><a class="header-anchor" href="#constructor-方法"><span>constructor()方法</span></a></h2><p><code>constructor</code>方法是类的默认方法，通过<code>new</code>命令生成对象实例时，自动调用该方法。一个类必须有<code>constructor</code>方法，如果没有显式定义，一个空的<code>constructor</code>方法会被默认添加。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Point</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#BDC4CC;">// 等同于</span></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Point</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  constructor</span><span style="color:#F0F3F6;">() {}</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面代码中，定义了一个空的类<code>Point</code>，JavaScript引擎会自动为它添加一个空的<code>constructor</code>方法。</p><p><code>constructor</code>方法默认返回实例对象（即<code>this</code>），完全可以指定返回另外一个对象。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Foo</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  constructor</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#FF9492;">    return</span><span style="color:#F0F3F6;"> Object.</span><span style="color:#DBB7FF;">create</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">null</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#FF9492;">new</span><span style="color:#DBB7FF;"> Foo</span><span style="color:#F0F3F6;">() </span><span style="color:#FF9492;">instanceof</span><span style="color:#FFB757;"> Foo</span><span style="color:#BDC4CC;"> // false</span></span></code></pre></div><p>上面代码中，<code>constructor</code>函数返回一个全新的对象，结果导致实例对象不是<code>Foo</code>类的实例。</p><p>类必须使用<code>new</code>调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用<code>new</code>也可以执行。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Foo</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  constructor</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#FF9492;">    return</span><span style="color:#F0F3F6;"> Object.</span><span style="color:#DBB7FF;">create</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">null</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#DBB7FF;">Foo</span><span style="color:#F0F3F6;">()</span></span>
<span class="line"><span style="color:#BDC4CC;">// TypeError: Class constructor Foo cannot be invoked without &#39;new&#39;</span></span></code></pre></div><h2 id="类的实例" tabindex="-1"><a class="header-anchor" href="#类的实例"><span>类的实例</span></a></h2><p>生成类的实例写法与 ES5 完全一样，也是使用<code>new</code>命令。如果忘记加上<code>new</code>，像函数那样调用<code>Class</code>，将会报错。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Point</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#BDC4CC;">  // ...</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#BDC4CC;">// 报错</span></span>
<span class="line"><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> point </span><span style="color:#FF9492;">=</span><span style="color:#DBB7FF;"> Point</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">3</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#BDC4CC;">// 正确</span></span>
<span class="line"><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> point </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> Point</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">3</span><span style="color:#F0F3F6;">);</span></span></code></pre></div><p>与ES5一样，实例的属性除非显式定义在其本身（即定义在<code>this</code>对象上），否则都是定义在原型上（即定义在<code>class</code>上）。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">//定义类</span></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Point</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  constructor</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">x</span><span style="color:#F0F3F6;">, </span><span style="color:#FFB757;">y</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#91CBFF;">    this</span><span style="color:#F0F3F6;">.x </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> x;</span></span>
<span class="line"><span style="color:#91CBFF;">    this</span><span style="color:#F0F3F6;">.y </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> y;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#DBB7FF;">  toString</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#FF9492;">    return</span><span style="color:#ADDCFF;"> &#39;(&#39;</span><span style="color:#FF9492;"> +</span><span style="color:#91CBFF;"> this</span><span style="color:#F0F3F6;">.x </span><span style="color:#FF9492;">+</span><span style="color:#ADDCFF;"> &#39;, &#39;</span><span style="color:#FF9492;"> +</span><span style="color:#91CBFF;"> this</span><span style="color:#F0F3F6;">.y </span><span style="color:#FF9492;">+</span><span style="color:#ADDCFF;"> &#39;)&#39;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> point </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> Point</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">3</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#F0F3F6;">point.</span><span style="color:#DBB7FF;">toString</span><span style="color:#F0F3F6;">() </span><span style="color:#BDC4CC;">// (2, 3)</span></span>
<span class="line"><span style="color:#F0F3F6;">point.</span><span style="color:#DBB7FF;">hasOwnProperty</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;x&#39;</span><span style="color:#F0F3F6;">) </span><span style="color:#BDC4CC;">// true</span></span>
<span class="line"><span style="color:#F0F3F6;">point.</span><span style="color:#DBB7FF;">hasOwnProperty</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;y&#39;</span><span style="color:#F0F3F6;">) </span><span style="color:#BDC4CC;">// true</span></span>
<span class="line"><span style="color:#F0F3F6;">point.</span><span style="color:#DBB7FF;">hasOwnProperty</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;toString&#39;</span><span style="color:#F0F3F6;">) </span><span style="color:#BDC4CC;">// false</span></span>
<span class="line"><span style="color:#F0F3F6;">point.</span><span style="color:#91CBFF;">__proto__</span><span style="color:#F0F3F6;">.</span><span style="color:#DBB7FF;">hasOwnProperty</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;toString&#39;</span><span style="color:#F0F3F6;">) </span><span style="color:#BDC4CC;">// true</span></span></code></pre></div><p>上面代码中，<code>x</code>和<code>y</code>都是实例对象<code>point</code>自身的属性（因为定义在<code>this</code>变量上），所以<code>hasOwnProperty</code>方法返回<code>true</code>，而<code>toString</code>是原型对象的属性（因为定义在<code>Point</code>类上），所以<code>hasOwnProperty</code>方法返回<code>false</code>。这些都与 ES5 的行为保持一致。</p><p>与 ES5 一样，类的所有实例共享一个原型对象。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> p1 </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> Point</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">,</span><span style="color:#91CBFF;">3</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> p2 </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> Point</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">3</span><span style="color:#F0F3F6;">,</span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#F0F3F6;">p1.</span><span style="color:#91CBFF;">__proto__</span><span style="color:#FF9492;"> ===</span><span style="color:#F0F3F6;"> p2.</span><span style="color:#91CBFF;">__proto__</span><span style="color:#BDC4CC;"> // true</span></span></code></pre></div><p>上面代码中，<code>p1</code>和<code>p2</code>都是<code>Point</code>的实例，它们的原型都是<code>Point.prototype</code>，所以<code>__proto__</code>属性是相等的。</p><p>这也意味着，可以通过实例的<code>__proto__</code>属性为“类”添加方法。</p><p><code>__proto__</code>并不是语言本身的特性，这是各大厂商具体实现时添加的私有属性，虽然目前很多现代浏览器的JS引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环境中，我们可以使用<code>Object.getPrototypeOf</code>方法来获取实例对象的原型，然后再来为原型添加方法/属性。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> p1 </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> Point</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">,</span><span style="color:#91CBFF;">3</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> p2 </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> Point</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">3</span><span style="color:#F0F3F6;">,</span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#F0F3F6;">p1.</span><span style="color:#91CBFF;">__proto__</span><span style="color:#F0F3F6;">.</span><span style="color:#DBB7FF;">printName</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> function</span><span style="color:#F0F3F6;"> () { </span><span style="color:#FF9492;">return</span><span style="color:#ADDCFF;"> &#39;Oops&#39;</span><span style="color:#F0F3F6;"> };</span></span>
<span class="line"><span style="color:#F0F3F6;">p1.</span><span style="color:#DBB7FF;">printName</span><span style="color:#F0F3F6;">() </span><span style="color:#BDC4CC;">// &quot;Oops&quot;</span></span>
<span class="line"><span style="color:#F0F3F6;">p2.</span><span style="color:#DBB7FF;">printName</span><span style="color:#F0F3F6;">() </span><span style="color:#BDC4CC;">// &quot;Oops&quot;</span></span>
<span class="line"><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> p3 </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> Point</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">4</span><span style="color:#F0F3F6;">,</span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#F0F3F6;">p3.</span><span style="color:#DBB7FF;">printName</span><span style="color:#F0F3F6;">() </span><span style="color:#BDC4CC;">// &quot;Oops&quot;</span></span></code></pre></div><p>上面代码在<code>p1</code>的原型上添加了一个<code>printName</code>方法，由于<code>p1</code>的原型就是<code>p2</code>的原型，因此<code>p2</code>也可以调用这个方法。而且，此后新建的实例<code>p3</code>也可以调用这个方法。这意味着，使用实例的<code>__proto__</code>属性改写原型，必须相当谨慎，不推荐使用，因为这会改变“类”的原始定义，影响到所有实例。</p><h2 id="实例属性的新写法" tabindex="-1"><a class="header-anchor" href="#实例属性的新写法"><span>实例属性的新写法</span></a></h2><p>ES2022 为类的实例属性，又规定了一种新写法。实例属性现在除了可以定义在<code>constructor()</code>方法里面的<code>this</code>上面，也可以定义在类内部的最顶层。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">// 原来的写法</span></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> IncreasingCounter</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  constructor</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#91CBFF;">    this</span><span style="color:#F0F3F6;">._count </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 0</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#FF9492;">  get</span><span style="color:#DBB7FF;"> value</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#F0F3F6;">    console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;Getting the current value!&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#FF9492;">    return</span><span style="color:#91CBFF;"> this</span><span style="color:#F0F3F6;">._count;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#DBB7FF;">  increment</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#91CBFF;">    this</span><span style="color:#F0F3F6;">._count</span><span style="color:#FF9492;">++</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面示例中，实例属性<code>_count</code>定义在<code>constructor()</code>方法里面的<code>this</code>上面。</p><p>现在的新写法是，这个属性也可以定义在类的最顶层，其他都不变。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> IncreasingCounter</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FFB757;">  _count</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> 0</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">  get</span><span style="color:#DBB7FF;"> value</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#F0F3F6;">    console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;Getting the current value!&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#FF9492;">    return</span><span style="color:#91CBFF;"> this</span><span style="color:#F0F3F6;">._count;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#DBB7FF;">  increment</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#91CBFF;">    this</span><span style="color:#F0F3F6;">._count</span><span style="color:#FF9492;">++</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面代码中，实例属性<code>_count</code>与取值函数<code>value()</code>和<code>increment()</code>方法，处于同一个层级。这时，不需要在实例属性前面加上<code>this</code>。</p><p>注意，新写法定义的属性是实例对象自身的属性，而不是定义在实例对象的原型上面。</p><p>这种新写法的好处是，所有实例对象自身的属性都定义在类的头部，看上去比较整齐，一眼就能看出这个类有哪些实例属性。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> foo</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FFB757;">  bar</span><span style="color:#FF9492;"> =</span><span style="color:#ADDCFF;"> &#39;hello&#39;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FFB757;">  baz</span><span style="color:#FF9492;"> =</span><span style="color:#ADDCFF;"> &#39;world&#39;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">  constructor</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#BDC4CC;">    // ...</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面的代码，一眼就能看出，<code>foo</code>类有两个实例属性，一目了然。另外，写起来也比较简洁。</p><h2 id="取值函数-getter-和存值函数-setter" tabindex="-1"><a class="header-anchor" href="#取值函数-getter-和存值函数-setter"><span>取值函数（getter）和存值函数（setter）</span></a></h2><p>与 ES5 一样，在“类”的内部可以使用<code>get</code>和<code>set</code>关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> MyClass</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  constructor</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#BDC4CC;">    // ...</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#FF9492;">  get</span><span style="color:#DBB7FF;"> prop</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#FF9492;">    return</span><span style="color:#ADDCFF;"> &#39;getter&#39;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#FF9492;">  set</span><span style="color:#DBB7FF;"> prop</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">value</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#F0F3F6;">    console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;setter: &#39;</span><span style="color:#FF9492;">+</span><span style="color:#F0F3F6;">value);</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> inst </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> MyClass</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">inst.prop </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 123</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#BDC4CC;">// setter: 123</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">inst.prop</span></span>
<span class="line"><span style="color:#BDC4CC;">// &#39;getter&#39;</span></span></code></pre></div><p>上面代码中，<code>prop</code>属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。</p><p>存值函数和取值函数是设置在属性的<code>Descriptor</code>对象上的。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> CustomHTMLElement</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  constructor</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">element</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#91CBFF;">    this</span><span style="color:#F0F3F6;">.element </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> element;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">  get</span><span style="color:#DBB7FF;"> html</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#FF9492;">    return</span><span style="color:#91CBFF;"> this</span><span style="color:#F0F3F6;">.element.innerHTML;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">  set</span><span style="color:#DBB7FF;"> html</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">value</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#91CBFF;">    this</span><span style="color:#F0F3F6;">.element.innerHTML </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> value;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> descriptor </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> Object.</span><span style="color:#DBB7FF;">getOwnPropertyDescriptor</span><span style="color:#F0F3F6;">(</span></span>
<span class="line"><span style="color:#91CBFF;">  CustomHTMLElement</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">prototype</span><span style="color:#F0F3F6;">, </span><span style="color:#ADDCFF;">&quot;html&quot;</span></span>
<span class="line"><span style="color:#F0F3F6;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ADDCFF;">&quot;get&quot;</span><span style="color:#FF9492;"> in</span><span style="color:#F0F3F6;"> descriptor  </span><span style="color:#BDC4CC;">// true</span></span>
<span class="line"><span style="color:#ADDCFF;">&quot;set&quot;</span><span style="color:#FF9492;"> in</span><span style="color:#F0F3F6;"> descriptor  </span><span style="color:#BDC4CC;">// true</span></span></code></pre></div><p>上面代码中，存值函数和取值函数是定义在<code>html</code>属性的描述对象上面，这与 ES5 完全一致。</p><h2 id="属性表达式" tabindex="-1"><a class="header-anchor" href="#属性表达式"><span>属性表达式</span></a></h2><p>类的属性名，可以采用表达式。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> methodName </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &#39;getArea&#39;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Square</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  constructor</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">length</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#BDC4CC;">    // ...</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">  [methodName]() {</span></span>
<span class="line"><span style="color:#BDC4CC;">    // ...</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面代码中，<code>Square</code>类的方法名<code>getArea</code>，是从表达式得到的。</p><h2 id="class表达式" tabindex="-1"><a class="header-anchor" href="#class表达式"><span>Class表达式</span></a></h2><p>与函数一样，类也可以使用表达式的形式定义。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> MyClass</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> class</span><span style="color:#FFB757;"> Me</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#DBB7FF;">  getClassName</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#FF9492;">    return</span><span style="color:#F0F3F6;"> Me.name;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span></code></pre></div><p>上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是<code>MyClass</code>而不是<code>Me</code>，<code>Me</code>只在<code>Class</code>的内部代码可用，指代当前类。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> inst </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> MyClass</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#F0F3F6;">inst.</span><span style="color:#DBB7FF;">getClassName</span><span style="color:#F0F3F6;">() </span><span style="color:#BDC4CC;">// Me</span></span>
<span class="line"><span style="color:#F0F3F6;">Me.name </span><span style="color:#BDC4CC;">// ReferenceError: Me is not defined</span></span></code></pre></div><p>上面代码表示，<code>Me</code>只在<code>Class</code>内部有定义。<br> 如果类的内部没用到的话，可以省略<code>Me</code>，也就是可以写成下面的形式。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> MyClass</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> class</span><span style="color:#F0F3F6;"> { </span><span style="color:#BDC4CC;">/* ... */</span><span style="color:#F0F3F6;"> };</span></span></code></pre></div><p>采用<code>Class</code>表达式，可以写出立即执行的<code>Class</code>。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> person </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> new</span><span style="color:#FF9492;"> class</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  constructor</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">name</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#91CBFF;">    this</span><span style="color:#F0F3F6;">.name </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> name;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#DBB7FF;">  sayName</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#F0F3F6;">    console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">this</span><span style="color:#F0F3F6;">.name);</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}(</span><span style="color:#ADDCFF;">&#39;张三&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#F0F3F6;">person.</span><span style="color:#DBB7FF;">sayName</span><span style="color:#F0F3F6;">(); </span><span style="color:#BDC4CC;">// &quot;张三&quot;</span></span></code></pre></div><p>上面代码中，<code>person</code>是一个立即执行的类的实例。</p><h2 id="静态方法" tabindex="-1"><a class="header-anchor" href="#静态方法"><span>静态方法</span></a></h2><p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上<code>static</code>关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Foo</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  static</span><span style="color:#DBB7FF;"> classMethod</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#FF9492;">    return</span><span style="color:#ADDCFF;"> &#39;hello&#39;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#F0F3F6;">Foo.</span><span style="color:#DBB7FF;">classMethod</span><span style="color:#F0F3F6;">() </span><span style="color:#BDC4CC;">// &#39;hello&#39;</span></span>
<span class="line"><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> foo </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> Foo</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#F0F3F6;">foo.</span><span style="color:#DBB7FF;">classMethod</span><span style="color:#F0F3F6;">()</span></span>
<span class="line"><span style="color:#BDC4CC;">// TypeError: foo.classMethod is not a function</span></span></code></pre></div><p>上面代码中，<code>Foo</code>类的<code>classMethod</code>方法前有<code>static</code>关键字，表明该方法是一个静态方法，可以直接在<code>Foo</code>类上调用（<code>Foo.classMethod()</code>），而不是在<code>Foo</code>类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。</p><p>注意，如果静态方法包含<code>this</code>关键字，这个<code>this</code>指的是类，而不是实例。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Foo</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  static</span><span style="color:#DBB7FF;"> bar</span><span style="color:#F0F3F6;"> () {</span></span>
<span class="line"><span style="color:#91CBFF;">    this</span><span style="color:#F0F3F6;">.</span><span style="color:#DBB7FF;">baz</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#FF9492;">  static</span><span style="color:#DBB7FF;"> baz</span><span style="color:#F0F3F6;"> () {</span></span>
<span class="line"><span style="color:#F0F3F6;">    console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;hello&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#DBB7FF;">  baz</span><span style="color:#F0F3F6;"> () {</span></span>
<span class="line"><span style="color:#F0F3F6;">    console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;world&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#F0F3F6;">Foo.</span><span style="color:#DBB7FF;">bar</span><span style="color:#F0F3F6;">() </span><span style="color:#BDC4CC;">// hello</span></span></code></pre></div><p>上面代码中，静态方法<code>bar</code>调用了<code>this.baz</code>，这里的<code>this</code>指的是<code>Foo</code>类，而不是<code>Foo</code>的实例，等同于调用<code>Foo.baz</code>。另外，从这个例子还可以看出，静态方法可以与非静态方法重名。</p><p>父类的静态方法，可以被子类继承。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Foo</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  static</span><span style="color:#DBB7FF;"> classMethod</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#FF9492;">    return</span><span style="color:#ADDCFF;"> &#39;hello&#39;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Bar</span><span style="color:#FF9492;"> extends</span><span style="color:#91CBFF;"> Foo</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#F0F3F6;">Bar.</span><span style="color:#DBB7FF;">classMethod</span><span style="color:#F0F3F6;">() </span><span style="color:#BDC4CC;">// &#39;hello&#39;</span></span></code></pre></div><p>上面代码中，父类<code>Foo</code>有一个静态方法，子类<code>Bar</code>可以调用这个方法。</p><p>静态方法也是可以从<code>super</code>对象上调用的。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Foo</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  static</span><span style="color:#DBB7FF;"> classMethod</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#FF9492;">    return</span><span style="color:#ADDCFF;"> &#39;hello&#39;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Bar</span><span style="color:#FF9492;"> extends</span><span style="color:#91CBFF;"> Foo</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  static</span><span style="color:#DBB7FF;"> classMethod</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#FF9492;">    return</span><span style="color:#91CBFF;"> super</span><span style="color:#F0F3F6;">.</span><span style="color:#DBB7FF;">classMethod</span><span style="color:#F0F3F6;">() </span><span style="color:#FF9492;">+</span><span style="color:#ADDCFF;"> &#39;, too&#39;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#F0F3F6;">Bar.</span><span style="color:#DBB7FF;">classMethod</span><span style="color:#F0F3F6;">() </span><span style="color:#BDC4CC;">// &quot;hello, too&quot;</span></span></code></pre></div><h2 id="静态属性" tabindex="-1"><a class="header-anchor" href="#静态属性"><span>静态属性</span></a></h2><p>静态属性指的是<code>Class</code>本身的属性，即<code>Class.propName</code>，而不是定义在实例对象（<code>this</code>）上的属性。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Foo</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#F0F3F6;">Foo.prop </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 1</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">Foo.prop </span><span style="color:#BDC4CC;">// 1</span></span></code></pre></div><p>上面的写法为<code>Foo</code>类定义了一个静态属性<code>prop</code>。</p><p>目前，只有这种写法可行，因为 ES6 明确规定，<code>Class</code>内部只有静态方法，没有静态属性。现在有一个提案提供了类的静态属性，写法是在实例属性的前面，加上<code>static</code>关键字。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> MyClass</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  static</span><span style="color:#FFB757;"> myStaticProp</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> 42</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">  constructor</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#F0F3F6;">    console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(MyClass.myStaticProp); </span><span style="color:#BDC4CC;">// 42</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>这个新写法大大方便了静态属性的表达。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">// 老写法</span></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Foo</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#BDC4CC;">  // ...</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#F0F3F6;">Foo.prop </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 1</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;">// 新写法</span></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Foo</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  static</span><span style="color:#FFB757;"> prop</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> 1</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面代码中，老写法的静态属性定义在类的外部。整个类生成以后，再生成静态属性。这样让人很容易忽略这个静态属性，也不符合相关代码应该放在一起的代码组织原则。另外，新写法是显式声明，而不是赋值处理，语义更好。</p><h2 id="私有方法和私有属性" tabindex="-1"><a class="header-anchor" href="#私有方法和私有属性"><span>私有方法和私有属性</span></a></h2><h3 id="早期解决方案" tabindex="-1"><a class="header-anchor" href="#早期解决方案"><span>早期解决方案</span></a></h3><p>私有方法和私有属性，是只能在类的内部访问的方法和属性，外部不能访问。这是常见需求，有利于代码的封装，但早期的 ES6 不提供，只能通过变通方法模拟实现。</p><p>一种做法是在命名上加以区别。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Widget</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#BDC4CC;">  // 公有方法</span></span>
<span class="line"><span style="color:#DBB7FF;">  foo</span><span style="color:#F0F3F6;"> (</span><span style="color:#FFB757;">baz</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#91CBFF;">    this</span><span style="color:#F0F3F6;">.</span><span style="color:#DBB7FF;">_bar</span><span style="color:#F0F3F6;">(baz);</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#BDC4CC;">  // 私有方法</span></span>
<span class="line"><span style="color:#DBB7FF;">  _bar</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">baz</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#FF9492;">    return</span><span style="color:#91CBFF;"> this</span><span style="color:#F0F3F6;">.snaf </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> baz;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#BDC4CC;">  // ...</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面代码中，<code>_bar</code>方法前面的下划线，表示这是一个只限于内部使用的私有方法。但是，这种命名是不保险的，在类的外部，还是可以调用到这个方法。</p><p>另一种方法就是索性将私有方法移出模块，因为模块内部的所有方法都是对外可见的。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Widget</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#DBB7FF;">  foo</span><span style="color:#F0F3F6;"> (</span><span style="color:#FFB757;">baz</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#F0F3F6;">    bar.</span><span style="color:#DBB7FF;">call</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">this</span><span style="color:#F0F3F6;">, baz);</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#BDC4CC;">  // ...</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#FF9492;">function</span><span style="color:#DBB7FF;"> bar</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">baz</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#FF9492;">  return</span><span style="color:#91CBFF;"> this</span><span style="color:#F0F3F6;">.snaf </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> baz;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面代码中，<code>foo</code>是公有方法，内部调用了<code>bar.call(this, baz)</code>。这使得<code>bar</code>实际上成为了当前模块的私有方法。</p><p>还有一种方法是利用<code>Symbol</code>值的唯一性，将私有方法的名字命名为一个<code>Symbol</code>值。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> bar</span><span style="color:#FF9492;"> =</span><span style="color:#DBB7FF;"> Symbol</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;bar&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> snaf</span><span style="color:#FF9492;"> =</span><span style="color:#DBB7FF;"> Symbol</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;snaf&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#FF9492;">export</span><span style="color:#FF9492;"> default</span><span style="color:#FF9492;"> class</span><span style="color:#FFB757;"> myClass{</span></span>
<span class="line"><span style="color:#BDC4CC;">  // 公有方法</span></span>
<span class="line"><span style="color:#DBB7FF;">  foo</span><span style="color:#FFB757;">(baz) </span><span style="color:#F0F3F6;">{</span></span>
<span class="line"><span style="color:#91CBFF;">    this</span><span style="color:#F0F3F6;">[bar](baz);</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#BDC4CC;">  // 私有方法</span></span>
<span class="line"><span style="color:#FFB757;">  [</span><span style="color:#F0F3F6;">bar</span><span style="color:#FFB757;">](baz) </span><span style="color:#F0F3F6;">{</span></span>
<span class="line"><span style="color:#FF9492;">    return</span><span style="color:#91CBFF;"> this</span><span style="color:#F0F3F6;">[snaf] </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> baz;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#BDC4CC;">  // ...</span></span>
<span class="line"><span style="color:#FFB757;">}</span><span style="color:#F0F3F6;">;</span></span></code></pre></div><p>上面代码中，bar和snaf都是Symbol值，一般情况下无法获取到它们，因此达到了私有方法和私有属性的效果。但是也不是绝对不行，Reflect.ownKeys()依然可以拿到它们。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> inst</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> myClass</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">Reflect.</span><span style="color:#DBB7FF;">ownKeys</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">myClass</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">prototype</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#BDC4CC;">// [ &#39;constructor&#39;, &#39;foo&#39;, Symbol(bar) ]</span></span></code></pre></div><h3 id="私有属性的正式写法" tabindex="-1"><a class="header-anchor" href="#私有属性的正式写法"><span>私有属性的正式写法</span></a></h3><p>ES2022正式为<code>class</code>添加了私有属性，方法是在属性名之前使用#表示。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> IncreasingCounter</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FFB757;">    #count</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> 0</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">    get</span><span style="color:#DBB7FF;"> value</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#F0F3F6;">        console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;Getting the current value!&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#FF9492;">        return</span><span style="color:#91CBFF;"> this</span><span style="color:#F0F3F6;">.#count;</span></span>
<span class="line"><span style="color:#F0F3F6;">    }</span></span>
<span class="line"><span style="color:#DBB7FF;">    increment</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#91CBFF;">        this</span><span style="color:#F0F3F6;">.#count</span><span style="color:#FF9492;">++</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">    }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面代码中，#count就是私有属性，只能在类的内部使用（this.#count）。如果在类的外部使用，就会报错。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> counter</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> IncreasingCounter</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#F0F3F6;">counter.#count </span><span style="color:#BDC4CC;">// 报错</span></span>
<span class="line"><span style="color:#F0F3F6;">counter.#count </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 42</span><span style="color:#BDC4CC;"> // 报错</span></span></code></pre></div><p>上面示例中，在类的外部，读取或写入私有属性#count，都会报错。</p><p>注意，从 Chrome 111 开始，开发者工具里面可以读写私有属性，不会报错，原因是 Chrome 团队认为这样方便调试。</p><p>另外，不管在类的内部或外部，读取一个不存在的私有属性，也都会报错。这跟公开属性的行为完全不同，如果读取一个不存在的公开属性，不会报错，只会返回undefined。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> IncreasingCounter</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FFB757;">  #count</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> 0</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">  get</span><span style="color:#DBB7FF;"> value</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#F0F3F6;">    console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;Getting the current value!&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#FF9492;">    return</span><span style="color:#91CBFF;"> this</span><span style="color:#F0F3F6;">.#myCount; </span><span style="color:#BDC4CC;">// 报错</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#DBB7FF;">  increment</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#91CBFF;">    this</span><span style="color:#F0F3F6;">.#count</span><span style="color:#FF9492;">++</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> counter</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> IncreasingCounter</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#F0F3F6;">counter.#myCount </span><span style="color:#BDC4CC;">// 报错</span></span></code></pre></div><p>上面示例中，#myCount是一个不存在的私有属性，不管在函数内部或外部，读取该属性都会导致报错。</p><p>注意，私有属性的属性名必须包括#，如果不带#，会被当作另一个属性。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Point</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FFB757;">  #x</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">  constructor</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">x</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> 0</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#91CBFF;">    this</span><span style="color:#F0F3F6;">.#x </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> +</span><span style="color:#F0F3F6;">x;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">  get</span><span style="color:#DBB7FF;"> x</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#FF9492;">    return</span><span style="color:#91CBFF;"> this</span><span style="color:#F0F3F6;">.#x;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">  set</span><span style="color:#DBB7FF;"> x</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">value</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#91CBFF;">    this</span><span style="color:#F0F3F6;">.#x </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> +</span><span style="color:#F0F3F6;">value;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面代码中，#x就是私有属性，在Point类之外是读取不到这个属性的。由于井号#是属性名的一部分，使用时必须带有#一起使用，所以#x和x是两个不同的属性。</p><p>这种写法不仅可以写私有属性，还可以用来写私有方法。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Foo</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FFB757;">  #a</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FFB757;">  #b</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">  constructor</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">a</span><span style="color:#F0F3F6;">, </span><span style="color:#FFB757;">b</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#91CBFF;">    this</span><span style="color:#F0F3F6;">.#a </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> a;</span></span>
<span class="line"><span style="color:#91CBFF;">    this</span><span style="color:#F0F3F6;">.#b </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> b;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">  #</span><span style="color:#DBB7FF;">sum</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#FF9492;">    return</span><span style="color:#91CBFF;"> this</span><span style="color:#F0F3F6;">.#a </span><span style="color:#FF9492;">+</span><span style="color:#91CBFF;"> this</span><span style="color:#F0F3F6;">.#b;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#DBB7FF;">  printSum</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#F0F3F6;">    console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">this</span><span style="color:#F0F3F6;">.</span><span style="color:#DBB7FF;">#sum</span><span style="color:#F0F3F6;">());</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面示例中，<code>#sum()</code>就是一个私有方法。</p><p>另外，私有属性也可以设置<code>getter</code>和<code>setter</code>方法。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Counter</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FFB757;">  #xValue</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> 0</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">  constructor</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#F0F3F6;">    console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">this</span><span style="color:#F0F3F6;">.#x);</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">  get</span><span style="color:#F0F3F6;"> #</span><span style="color:#DBB7FF;">x</span><span style="color:#F0F3F6;">() { </span><span style="color:#FF9492;">return</span><span style="color:#91CBFF;"> this</span><span style="color:#F0F3F6;">.#xValue; }</span></span>
<span class="line"><span style="color:#FF9492;">  set</span><span style="color:#F0F3F6;"> #</span><span style="color:#DBB7FF;">x</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">value</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#91CBFF;">    this</span><span style="color:#F0F3F6;">.#xValue </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> value;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面代码中，<code>#x</code>是一个私有属性，它的读写都通过<code>get #x()</code>和<code>set #x()</code>操作另一个私有属性<code>#xValue</code>来完成。</p><p>私有属性不限于从<code>this</code>引用，只要是在类的内部，实例也可以引用私有属性。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Foo</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FFB757;">  #privateValue</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> 42</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">  static</span><span style="color:#DBB7FF;"> getPrivateValue</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">foo</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#FF9492;">    return</span><span style="color:#F0F3F6;"> foo.#privateValue;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">Foo.</span><span style="color:#DBB7FF;">getPrivateValue</span><span style="color:#F0F3F6;">(</span><span style="color:#FF9492;">new</span><span style="color:#DBB7FF;"> Foo</span><span style="color:#F0F3F6;">()); </span><span style="color:#BDC4CC;">// 42</span></span></code></pre></div><p>上面代码允许从实例<code>foo</code>上面引用私有属性。</p><p>私有属性和私有方法前面，也可以加上<code>static</code>关键字，表示这是一个静态的私有属性或私有方法。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> FakeMath</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  static</span><span style="color:#FFB757;"> PI</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> 22</span><span style="color:#FF9492;"> /</span><span style="color:#91CBFF;"> 7</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">  static</span><span style="color:#FFB757;"> #totallyRandomNumber</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> 4</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">  static</span><span style="color:#F0F3F6;"> #</span><span style="color:#DBB7FF;">computeRandomNumber</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#FF9492;">    return</span><span style="color:#F0F3F6;"> FakeMath.#totallyRandomNumber;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">  static</span><span style="color:#DBB7FF;"> random</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#F0F3F6;">    console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;I heard you like random numbers…&#39;</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#FF9492;">    return</span><span style="color:#F0F3F6;"> FakeMath.</span><span style="color:#DBB7FF;">#computeRandomNumber</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">FakeMath.</span><span style="color:#91CBFF;">PI</span><span style="color:#BDC4CC;"> // 3.142857142857143</span></span>
<span class="line"><span style="color:#F0F3F6;">FakeMath.</span><span style="color:#DBB7FF;">random</span><span style="color:#F0F3F6;">()</span></span>
<span class="line"><span style="color:#BDC4CC;">// I heard you like random numbers…</span></span>
<span class="line"><span style="color:#BDC4CC;">// 4</span></span>
<span class="line"><span style="color:#F0F3F6;">FakeMath.#totallyRandomNumber </span><span style="color:#BDC4CC;">// 报错</span></span>
<span class="line"><span style="color:#F0F3F6;">FakeMath.</span><span style="color:#DBB7FF;">#computeRandomNumber</span><span style="color:#F0F3F6;">() </span><span style="color:#BDC4CC;">// 报错</span></span></code></pre></div><p>上面代码中，<code>#totallyRandomNumber</code>是私有属性，<code>#computeRandomNumber()</code>是私有方法，只能在<code>FakeMath</code>这个类的内部调用，外部调用就会报错。</p><h2 id="静态块" tabindex="-1"><a class="header-anchor" href="#静态块"><span>静态块</span></a></h2><p>静态属性的一个问题是，如果它有初始化逻辑，这个逻辑要么写在类的外部，要么写在<code>constructor()</code>方法里面。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> C</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  static</span><span style="color:#FFB757;"> x</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> 234</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">  static</span><span style="color:#FFB757;"> y</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">  static</span><span style="color:#FFB757;"> z</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">try</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  const</span><span style="color:#91CBFF;"> obj</span><span style="color:#FF9492;"> =</span><span style="color:#DBB7FF;"> doSomethingWith</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">C</span><span style="color:#F0F3F6;">.x);</span></span>
<span class="line"><span style="color:#91CBFF;">  C</span><span style="color:#F0F3F6;">.y </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> obj.y</span></span>
<span class="line"><span style="color:#91CBFF;">  C</span><span style="color:#F0F3F6;">.z </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> obj.z;</span></span>
<span class="line"><span style="color:#F0F3F6;">} </span><span style="color:#FF9492;">catch</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#91CBFF;">  C</span><span style="color:#F0F3F6;">.y </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> ...</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#91CBFF;">  C</span><span style="color:#F0F3F6;">.z </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> ...</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面示例中，静态属性<code>y</code>和<code>z</code>的值依赖于静态属性<code>x</code>的运算结果，这段初始化逻辑写在类的外部（上例的<code>try...catch</code>代码块）。另一种方法是写到类的<code>constructor()</code>方法里面。这两种方法都不是很理想，前者是将类的内部逻辑写到了外部，后者则是每次新建实例都会运行一次。</p><p>为了解决这个问题，ES2022 引入了静态块（<code>static block</code>），允许在类的内部设置一个代码块，在类生成时运行且只运行一次，主要作用是对静态属性进行初始化。以后，新建类的实例时，这个块就不运行了。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> C</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  static</span><span style="color:#FFB757;"> x</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> ...</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">  static</span><span style="color:#FFB757;"> y</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">  static</span><span style="color:#FFB757;"> z</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">  static</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">    try</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">      const</span><span style="color:#91CBFF;"> obj</span><span style="color:#FF9492;"> =</span><span style="color:#DBB7FF;"> doSomethingWith</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">this</span><span style="color:#F0F3F6;">.x);</span></span>
<span class="line"><span style="color:#91CBFF;">      this</span><span style="color:#F0F3F6;">.y </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> obj.y;</span></span>
<span class="line"><span style="color:#91CBFF;">      this</span><span style="color:#F0F3F6;">.z </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> obj.z;</span></span>
<span class="line"><span style="color:#F0F3F6;">    }</span></span>
<span class="line"><span style="color:#FF9492;">    catch</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#91CBFF;">      this</span><span style="color:#F0F3F6;">.y </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> ...</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#91CBFF;">      this</span><span style="color:#F0F3F6;">.z </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> ...</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">    }</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面代码中，类的内部有一个<code>static</code>代码块，这就是静态块。它的好处是将静态属性<code>y</code>和<code>z</code>的初始化逻辑，写入了类的内部，而且只运行一次。</p><p>每个类允许有多个静态块，每个静态块中只能访问之前声明的静态属性。另外，静态块的内部不能有<code>return</code>语句。</p><p>静态块内部可以使用类名或<code>this</code>，指代当前类。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> C</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  static</span><span style="color:#FFB757;"> x</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> 1</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">  static</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#91CBFF;">    this</span><span style="color:#F0F3F6;">.x; </span><span style="color:#BDC4CC;">// 1</span></span>
<span class="line"><span style="color:#BDC4CC;">    // 或者</span></span>
<span class="line"><span style="color:#91CBFF;">    C</span><span style="color:#F0F3F6;">.x; </span><span style="color:#BDC4CC;">// 1</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面示例中，<code>this.x</code>和<code>C.x</code>都能获取静态属性<code>x</code>。</p><p>除了静态属性的初始化，静态块还有一个作用，就是将私有属性与类的外部代码分享。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> getX;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">export</span><span style="color:#FF9492;"> class</span><span style="color:#FFB757;"> C</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FFB757;">  #x</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> 1</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">  static</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#DBB7FF;">    getX</span><span style="color:#FF9492;"> =</span><span style="color:#FFB757;"> obj</span><span style="color:#FF9492;"> =&gt;</span><span style="color:#F0F3F6;"> obj.#x;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(</span><span style="color:#DBB7FF;">getX</span><span style="color:#F0F3F6;">(</span><span style="color:#FF9492;">new</span><span style="color:#DBB7FF;"> C</span><span style="color:#F0F3F6;">())); </span><span style="color:#BDC4CC;">// 1</span></span></code></pre></div><p>上面示例中，<code>#x</code>是类的私有属性，如果类外部的<code>getX()</code>方法希望获取这个属性，以前是要写在类的<code>constructor()</code>方法里面，这样的话，每次新建实例都会定义一次<code>getX()</code>方法。现在可以写在静态块里面，这样的话，只在类生成时定义一次。</p><h2 id="类的注意点" tabindex="-1"><a class="header-anchor" href="#类的注意点"><span>类的注意点</span></a></h2><h3 id="严格模式" tabindex="-1"><a class="header-anchor" href="#严格模式"><span>严格模式</span></a></h3><p>类和模块的内部，默认就是严格模式，所以不需要使用<code>use strict</code>指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。考虑到未来所有的代码，其实都是运行在模块之中，所以 ES6 实际上把整个语言升级到了严格模式。</p><h3 id="不存在变量提升" tabindex="-1"><a class="header-anchor" href="#不存在变量提升"><span>不存在变量提升</span></a></h3><p>类不存在变量提升（<code>hoist</code>），这一点与ES5完全不同。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">new</span><span style="color:#DBB7FF;"> Foo</span><span style="color:#F0F3F6;">(); </span><span style="color:#BDC4CC;">// ReferenceError</span></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Foo</span><span style="color:#F0F3F6;"> {}</span></span></code></pre></div><p>上面代码中，<code>Foo</code>类使用在前，定义在后，这样会报错，因为 ES6 不会把类的声明提升到代码头部。这种规定的原因与下文要提到的继承有关，必须保证子类在父类之后定义。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">{</span></span>
<span class="line"><span style="color:#FF9492;">  let</span><span style="color:#F0F3F6;"> Foo </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> class</span><span style="color:#F0F3F6;"> {};</span></span>
<span class="line"><span style="color:#FF9492;">  class</span><span style="color:#FFB757;"> Bar</span><span style="color:#FF9492;"> extends</span><span style="color:#91CBFF;"> Foo</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面的代码不会报错，因为<code>Bar</code>继承<code>Foo</code>的时候，<code>Foo</code>已经有定义了。但是，如果存在<code>class</code>的提升，上面代码就会报错，因为<code>class</code>会被提升到代码头部，而<code>let</code>命令是不提升的，所以导致<code>Bar</code>继承<code>Foo</code>的时候，<code>Foo</code>还没有定义。</p><h3 id="name属性" tabindex="-1"><a class="header-anchor" href="#name属性"><span>name属性</span></a></h3><p>由于本质上，ES6 的类只是 ES5 的构造函数的一层包装，所以函数的许多特性都被<code>Class</code>继承，包括<code>name</code>属性。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Point</span><span style="color:#F0F3F6;"> {}</span></span>
<span class="line"><span style="color:#F0F3F6;">Point.name </span><span style="color:#BDC4CC;">// &quot;Point&quot;</span></span></code></pre></div><p><code>name</code>属性总是返回紧跟在<code>class</code>关键字后面的类名。</p><h2 id="generator方法" tabindex="-1"><a class="header-anchor" href="#generator方法"><span>Generator方法</span></a></h2><p>如果某个方法之前加上星号（*），就表示该方法是一个<code>Generator</code>函数。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Foo</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  constructor</span><span style="color:#F0F3F6;">(</span><span style="color:#FF9492;">...</span><span style="color:#FFB757;">args</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#91CBFF;">    this</span><span style="color:#F0F3F6;">.args </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> args;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#FF9492;">  *</span><span style="color:#F0F3F6;"> [Symbol.iterator]() {</span></span>
<span class="line"><span style="color:#FF9492;">    for</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> arg </span><span style="color:#FF9492;">of</span><span style="color:#91CBFF;"> this</span><span style="color:#F0F3F6;">.args) {</span></span>
<span class="line"><span style="color:#FF9492;">      yield</span><span style="color:#F0F3F6;"> arg;</span></span>
<span class="line"><span style="color:#F0F3F6;">    }</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#FF9492;">for</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> x </span><span style="color:#FF9492;">of</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> Foo</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;hello&#39;</span><span style="color:#F0F3F6;">, </span><span style="color:#ADDCFF;">&#39;world&#39;</span><span style="color:#F0F3F6;">)) {</span></span>
<span class="line"><span style="color:#F0F3F6;">  console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(x);</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#BDC4CC;">// hello</span></span>
<span class="line"><span style="color:#BDC4CC;">// world</span></span></code></pre></div><p>上面代码中，<code>Foo</code>类的<code>Symbol.iterator</code>方法前有一个星号，表示该方法是一个<code>Generator</code>函数。<code>Symbol.iterator</code>方法返回一个<code>Foo</code>类的默认遍历器，<code>for...of</code>循环会自动调用这个遍历器。</p><h3 id="this的指向" tabindex="-1"><a class="header-anchor" href="#this的指向"><span>this的指向</span></a></h3><p>类的方法内部如果含有<code>this</code>，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Logger</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#DBB7FF;">  printName</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">name</span><span style="color:#FF9492;"> =</span><span style="color:#ADDCFF;"> &#39;there&#39;</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#91CBFF;">    this</span><span style="color:#F0F3F6;">.</span><span style="color:#DBB7FF;">print</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">\`Hello \${</span><span style="color:#F0F3F6;">name</span><span style="color:#ADDCFF;">}\`</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#DBB7FF;">  print</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">text</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#F0F3F6;">    console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(text);</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> logger</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> Logger</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#F0F3F6;"> { </span><span style="color:#91CBFF;">printName</span><span style="color:#F0F3F6;"> } </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> logger;</span></span>
<span class="line"><span style="color:#DBB7FF;">printName</span><span style="color:#F0F3F6;">(); </span><span style="color:#BDC4CC;">// TypeError: Cannot read property &#39;print&#39; of undefined</span></span></code></pre></div><p>上面代码中，<code>printName</code>方法中的<code>this</code>，默认指向<code>Logger</code>类的实例。但是，如果将这个方法提取出来单独使用，<code>this</code>会指向该方法运行时所在的环境，因为找不到<code>print</code>方法而导致报错。<br> 一个比较简单的解决方法是，在构造方法中绑定<code>this</code>，这样就不会找不到<code>print</code>方法了。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Logger</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  constructor</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#91CBFF;">    this</span><span style="color:#F0F3F6;">.printName </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> this</span><span style="color:#F0F3F6;">.printName.</span><span style="color:#DBB7FF;">bind</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">this</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#BDC4CC;">  // ...</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>另一种解决方法是使用箭头函数。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Logger</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  constructor</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#91CBFF;">    this</span><span style="color:#F0F3F6;">.</span><span style="color:#DBB7FF;">printName</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> (</span><span style="color:#FFB757;">name</span><span style="color:#FF9492;"> =</span><span style="color:#ADDCFF;"> &#39;there&#39;</span><span style="color:#F0F3F6;">) </span><span style="color:#FF9492;">=&gt;</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#91CBFF;">      this</span><span style="color:#F0F3F6;">.</span><span style="color:#DBB7FF;">print</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">\`Hello \${</span><span style="color:#F0F3F6;">name</span><span style="color:#ADDCFF;">}\`</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#F0F3F6;">    };</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#BDC4CC;">  // ...</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>还有一种解决方法是使用<code>Proxy</code>，获取方法的时候，自动绑定<code>this</code>。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">function</span><span style="color:#DBB7FF;"> selfish</span><span style="color:#F0F3F6;"> (</span><span style="color:#FFB757;">target</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#FF9492;">  const</span><span style="color:#91CBFF;"> cache</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> WeakMap</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#FF9492;">  const</span><span style="color:#91CBFF;"> handler</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#DBB7FF;">    get</span><span style="color:#F0F3F6;"> (</span><span style="color:#FFB757;">target</span><span style="color:#F0F3F6;">, </span><span style="color:#FFB757;">key</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#FF9492;">      const</span><span style="color:#91CBFF;"> value</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> Reflect.</span><span style="color:#DBB7FF;">get</span><span style="color:#F0F3F6;">(target, key);</span></span>
<span class="line"><span style="color:#FF9492;">      if</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">typeof</span><span style="color:#F0F3F6;"> value </span><span style="color:#FF9492;">!==</span><span style="color:#ADDCFF;"> &#39;function&#39;</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#FF9492;">        return</span><span style="color:#F0F3F6;"> value;</span></span>
<span class="line"><span style="color:#F0F3F6;">      }</span></span>
<span class="line"><span style="color:#FF9492;">      if</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">!</span><span style="color:#F0F3F6;">cache.</span><span style="color:#DBB7FF;">has</span><span style="color:#F0F3F6;">(value)) {</span></span>
<span class="line"><span style="color:#F0F3F6;">        cache.</span><span style="color:#DBB7FF;">set</span><span style="color:#F0F3F6;">(value, value.</span><span style="color:#DBB7FF;">bind</span><span style="color:#F0F3F6;">(target));</span></span>
<span class="line"><span style="color:#F0F3F6;">      }</span></span>
<span class="line"><span style="color:#FF9492;">      return</span><span style="color:#F0F3F6;"> cache.</span><span style="color:#DBB7FF;">get</span><span style="color:#F0F3F6;">(value);</span></span>
<span class="line"><span style="color:#F0F3F6;">    }</span></span>
<span class="line"><span style="color:#F0F3F6;">  };</span></span>
<span class="line"><span style="color:#FF9492;">  const</span><span style="color:#91CBFF;"> proxy</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> Proxy</span><span style="color:#F0F3F6;">(target, handler);</span></span>
<span class="line"><span style="color:#FF9492;">  return</span><span style="color:#F0F3F6;"> proxy;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> logger</span><span style="color:#FF9492;"> =</span><span style="color:#DBB7FF;"> selfish</span><span style="color:#F0F3F6;">(</span><span style="color:#FF9492;">new</span><span style="color:#DBB7FF;"> Logger</span><span style="color:#F0F3F6;">());</span></span></code></pre></div><h2 id="new-target属性" tabindex="-1"><a class="header-anchor" href="#new-target属性"><span>new.target属性</span></a></h2><p><code>new</code>是从构造函数生成实例对象的命令。ES6为<code>new</code>命令引入了一个<code>new.target</code>属性，该属性一般用在构造函数之中，返回<code>new</code>命令作用于的那个构造函数。如果构造函数不是通过<code>new</code>命令调用的，<code>new.target</code>会返回<code>undefined</code>，因此这个属性可以用来确定构造函数是怎么调用的。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">function</span><span style="color:#DBB7FF;"> Person</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">name</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#FF9492;">  if</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">new</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">target</span><span style="color:#FF9492;"> !==</span><span style="color:#91CBFF;"> undefined</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#91CBFF;">    this</span><span style="color:#F0F3F6;">.name </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> name;</span></span>
<span class="line"><span style="color:#F0F3F6;">  } </span><span style="color:#FF9492;">else</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">    throw</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> Error</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;必须使用 new 命令生成实例&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#BDC4CC;">// 另一种写法</span></span>
<span class="line"><span style="color:#FF9492;">function</span><span style="color:#DBB7FF;"> Person</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">name</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#FF9492;">  if</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">new</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">target</span><span style="color:#FF9492;"> ===</span><span style="color:#F0F3F6;"> Person) {</span></span>
<span class="line"><span style="color:#91CBFF;">    this</span><span style="color:#F0F3F6;">.name </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> name;</span></span>
<span class="line"><span style="color:#F0F3F6;">  } </span><span style="color:#FF9492;">else</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">    throw</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> Error</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;必须使用 new 命令生成实例&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> person </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> Person</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;张三&#39;</span><span style="color:#F0F3F6;">); </span><span style="color:#BDC4CC;">// 正确</span></span>
<span class="line"><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> notAPerson </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> Person.</span><span style="color:#DBB7FF;">call</span><span style="color:#F0F3F6;">(person, </span><span style="color:#ADDCFF;">&#39;张三&#39;</span><span style="color:#F0F3F6;">);  </span><span style="color:#BDC4CC;">// 报错</span></span></code></pre></div><p>上面代码确保构造函数只能通过<code>new</code>命令调用。<br><code>Class</code>内部调用<code>new.target</code>，返回当前<code>Class</code>。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Rectangle</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  constructor</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">length</span><span style="color:#F0F3F6;">, </span><span style="color:#FFB757;">width</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#F0F3F6;">    console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(</span><span style="color:#FF9492;">new</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">target</span><span style="color:#FF9492;"> ===</span><span style="color:#F0F3F6;"> Rectangle);</span></span>
<span class="line"><span style="color:#91CBFF;">    this</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">length</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> length;</span></span>
<span class="line"><span style="color:#91CBFF;">    this</span><span style="color:#F0F3F6;">.width </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> width;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> obj </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> Rectangle</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">3</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">4</span><span style="color:#F0F3F6;">); </span><span style="color:#BDC4CC;">// 输出 true</span></span></code></pre></div><p>需要注意的是，子类继承父类时，<code>new.target</code>会返回子类。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Rectangle</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  constructor</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">length</span><span style="color:#F0F3F6;">, </span><span style="color:#FFB757;">width</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#F0F3F6;">    console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(</span><span style="color:#FF9492;">new</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">target</span><span style="color:#FF9492;"> ===</span><span style="color:#F0F3F6;"> Rectangle);</span></span>
<span class="line"><span style="color:#BDC4CC;">    // ...</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Square</span><span style="color:#FF9492;"> extends</span><span style="color:#91CBFF;"> Rectangle</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  constructor</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">length</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#91CBFF;">    super</span><span style="color:#F0F3F6;">(length, length);</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> obj </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> Square</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">3</span><span style="color:#F0F3F6;">); </span><span style="color:#BDC4CC;">// 输出 false</span></span></code></pre></div><p>上面代码中，<code>new.target</code>会返回子类。</p><p>利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Shape</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  constructor</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#FF9492;">    if</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">new</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">target</span><span style="color:#FF9492;"> ===</span><span style="color:#F0F3F6;"> Shape) {</span></span>
<span class="line"><span style="color:#FF9492;">      throw</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> Error</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;本类不能实例化&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#F0F3F6;">    }</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Rectangle</span><span style="color:#FF9492;"> extends</span><span style="color:#91CBFF;"> Shape</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  constructor</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">length</span><span style="color:#F0F3F6;">, </span><span style="color:#FFB757;">width</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#91CBFF;">    super</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#BDC4CC;">    // ...</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> x </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> Shape</span><span style="color:#F0F3F6;">();  </span><span style="color:#BDC4CC;">// 报错</span></span>
<span class="line"><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> y </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> Rectangle</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">3</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">4</span><span style="color:#F0F3F6;">);  </span><span style="color:#BDC4CC;">// 正确</span></span></code></pre></div><p>上面代码中，<code>Shape</code>类不能被实例化，只能用于继承。</p><p>注意，在函数外部，使用<code>new.target</code>会报错。</p>`,192)]))}const r=a(o,[["render",e],["__file","ES6 Class.html.vue"]]),y=JSON.parse('{"path":"/js/es6/ES6%20Class.html","title":"","lang":"zh-CN","frontmatter":{"description":"类的由来 JavaScript 中，生成实例对象的传统方法是通过构造函数。 ES6引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。 基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的...","head":[["meta",{"property":"og:url","content":"https://0oWSQo0.github.io/wsq-blog/js/es6/ES6%20Class.html"}],["meta",{"property":"og:description","content":"类的由来 JavaScript 中，生成实例对象的传统方法是通过构造函数。 ES6引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。 基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-11-01T01:55:29.000Z"}],["meta",{"property":"article:modified_time","content":"2024-11-01T01:55:29.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-11-01T01:55:29.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"WSQ\\",\\"url\\":\\"https://0oWSQo0.github.com\\"}]}"]]},"headers":[{"level":2,"title":"类的由来","slug":"类的由来","link":"#类的由来","children":[]},{"level":2,"title":"constructor()方法","slug":"constructor-方法","link":"#constructor-方法","children":[]},{"level":2,"title":"类的实例","slug":"类的实例","link":"#类的实例","children":[]},{"level":2,"title":"实例属性的新写法","slug":"实例属性的新写法","link":"#实例属性的新写法","children":[]},{"level":2,"title":"取值函数（getter）和存值函数（setter）","slug":"取值函数-getter-和存值函数-setter","link":"#取值函数-getter-和存值函数-setter","children":[]},{"level":2,"title":"属性表达式","slug":"属性表达式","link":"#属性表达式","children":[]},{"level":2,"title":"Class表达式","slug":"class表达式","link":"#class表达式","children":[]},{"level":2,"title":"静态方法","slug":"静态方法","link":"#静态方法","children":[]},{"level":2,"title":"静态属性","slug":"静态属性","link":"#静态属性","children":[]},{"level":2,"title":"私有方法和私有属性","slug":"私有方法和私有属性","link":"#私有方法和私有属性","children":[{"level":3,"title":"早期解决方案","slug":"早期解决方案","link":"#早期解决方案","children":[]},{"level":3,"title":"私有属性的正式写法","slug":"私有属性的正式写法","link":"#私有属性的正式写法","children":[]}]},{"level":2,"title":"静态块","slug":"静态块","link":"#静态块","children":[]},{"level":2,"title":"类的注意点","slug":"类的注意点","link":"#类的注意点","children":[{"level":3,"title":"严格模式","slug":"严格模式","link":"#严格模式","children":[]},{"level":3,"title":"不存在变量提升","slug":"不存在变量提升","link":"#不存在变量提升","children":[]},{"level":3,"title":"name属性","slug":"name属性","link":"#name属性","children":[]}]},{"level":2,"title":"Generator方法","slug":"generator方法","link":"#generator方法","children":[{"level":3,"title":"this的指向","slug":"this的指向","link":"#this的指向","children":[]}]},{"level":2,"title":"new.target属性","slug":"new-target属性","link":"#new-target属性","children":[]}],"git":{"createdTime":1730426129000,"updatedTime":1730426129000,"contributors":[{"name":"WSQ","email":"592786982@qq.com","commits":1}]},"readingTime":{"minutes":19.29,"words":5786},"filePathRelative":"js/es6/ES6 Class.md","localizedDate":"2024年11月1日","autoDesc":true}');export{r as comp,y as data};
