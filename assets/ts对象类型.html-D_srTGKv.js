import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as p,d as t,o as b}from"./app-ByvFWdWZ.js";const n={};function o(s,r){return b(),p("div",null,r[0]||(r[0]=[t('<p>除了原始类型，对象是 JavaScript 最基本的数据结构。TypeScript 对于对象类型有很多规则。</p><p>对象类型的最简单声明方法，就是使用大括号表示对象，在大括号内部声明每个属性和方法的类型。</p><p>const obj:{<br> x:number;<br> y:number;<br> } = { x: 1, y: 1 };<br> 上面示例中，对象obj的类型就写在变量名后面，使用大括号描述，内部声明每个属性的属性名和类型。</p><p>属性的类型可以用分号结尾，也可以用逗号结尾。</p><p>// 属性类型以分号结尾<br> type MyObj = {<br> x:number;<br> y:number;<br> };</p><p>// 属性类型以逗号结尾<br> type MyObj = {<br> x:number,<br> y:number,<br> };<br> 最后一个属性后面，可以写分号或逗号，也可以不写。</p><p>一旦声明了类型，对象赋值时，就不能缺少指定的属性，也不能有多余的属性。</p><p>type MyObj = {<br> x:number;<br> y:number;<br> };</p><p>const o1:MyObj = { x: 1 }; // 报错<br> const o2:MyObj = { x: 1, y: 1, z: 1 }; // 报错<br> 上面示例中，变量o1缺少了属性y，变量o2多出了属性z，都会报错。</p><p>读写不存在的属性也会报错。</p><p>const obj:{<br> x:number;<br> y:number;<br> } = { x: 1, y: 1 };</p><p>console.log(obj.z); // 报错<br> obj.z = 1; // 报错<br> 上面示例中，读写不存在的属性z都会报错。</p><p>同样地，也不能删除类型声明中存在的属性，修改属性值是可以的。</p><p>const myUser = {<br> name: &quot;Sabrina&quot;,<br> };</p><p>delete myUser.name // 报错<br> myUser.name = &quot;Cynthia&quot;; // 正确<br> 上面声明中，删除类型声明中存在的属性name会报错，但是可以修改它的值。</p><p>对象的方法使用函数类型描述。</p><p>const obj:{<br> x: number;<br> y: number;<br> add(x:number, y:number): number;<br> // 或者写成<br> // add: (x:number, y:number) =&gt; number;<br> } = {<br> x: 1,<br> y: 1,<br> add(x, y) {<br> return x + y;<br> }<br> };<br> 上面示例中，对象obj有一个方法add()，需要定义它的参数类型和返回值类型。</p><p>对象类型可以使用方括号读取属性的类型。</p><p>type User = {<br> name: string,<br> age: number<br> };<br> type Name = User[&#39;name&#39;]; // string<br> 上面示例中，对象类型User使用方括号，读取了属性name的类型（string）。</p><p>除了type命令可以为对象类型声明一个别名，TypeScript 还提供了interface命令，可以把对象类型提炼为一个接口。</p><p>// 写法一<br> type MyObj = {<br> x:number;<br> y:number;<br> };</p><p>const obj:MyObj = { x: 1, y: 1 };</p><p>// 写法二<br> interface MyObj {<br> x: number;<br> y: number;<br> }</p><p>const obj:MyObj = { x: 1, y: 1 };<br> 上面示例中，写法一是type命令的用法，写法二是interface命令的用法。interface命令的详细解释，以及与type命令的区别，详见《Interface》一章。</p><p>注意，TypeScript 不区分对象自身的属性和继承的属性，一律视为对象的属性。</p><p>interface MyInterface {<br> toString(): string; // 继承的属性<br> prop: number; // 自身的属性<br> }</p><p>const obj:MyInterface = { // 正确<br> prop: 123,<br> };<br> 上面示例中，obj只写了prop属性，但是不报错。因为它可以继承原型上面的toString()方法。</p><h2 id="可选属性" tabindex="-1"><a class="header-anchor" href="#可选属性"><span>可选属性</span></a></h2><p>如果某个属性是可选的（即可以忽略），需要在属性名后面加一个问号。</p><p>const obj: {<br> x: number;<br> y?: number;<br> } = { x: 1 };<br> 上面示例中，属性y是可选的。</p><p>可选属性等同于允许赋值为undefined，下面两种写法是等效的。</p><p>type User = {<br> firstName: string;<br> lastName?: string;<br> };</p><p>// 等同于<br> type User = {<br> firstName: string;<br> lastName?: string|undefined;<br> };<br> 上面示例中，类型User的可选属性lastName可以是字符串，也可以是undefined，即可选属性可以赋值为undefined。</p><p>const obj: {<br> x: number;<br> y?: number;<br> } = { x: 1, y: undefined };<br> 上面示例中，可选属性y赋值为undefined，不会报错。</p><p>同样地，读取一个没有赋值的可选属性时，返回undefined。</p><p>type MyObj = {<br> x: string,<br> y?: string<br> };</p><p>const obj:MyObj = { x: &#39;hello&#39; };<br> obj.y.toLowerCase() // 报错<br> 上面示例中，最后一行会报错，因为obj.y返回undefined，无法对其调用toLowerCase()。</p><p>所以，读取可选属性之前，必须检查一下是否为undefined。</p><p>const user:{<br> firstName: string;<br> lastName?: string;<br> } = { firstName: &#39;Foo&#39;};</p><p>if (user.lastName !== undefined) {<br> console.log(<code>hello ${user.firstName} ${user.lastName}</code>)<br> }<br> 上面示例中，lastName是可选属性，需要判断是否为undefined以后，才能使用。建议使用下面的写法。</p><p>// 写法一<br> let firstName = (user.firstName === undefined)<br> ? &#39;Foo&#39; : user.firstName;<br> let lastName = (user.lastName === undefined)<br> ? &#39;Bar&#39; : user.lastName;</p><p>// 写法二<br> let firstName = user.firstName ?? &#39;Foo&#39;;<br> let lastName = user.lastName ?? &#39;Bar&#39;;<br> 上面示例中，写法一使用三元运算符?:，判断是否为undefined，并设置默认值。写法二使用 Null 判断运算符??，与写法一的作用完全相同。</p><p>TypeScript 提供编译设置ExactOptionalPropertyTypes，只要同时打开这个设置和strictNullChecks，可选属性就不能设为undefined。</p><p>// 打开 ExactOptionsPropertyTypes 和 strictNullChecks<br> const obj: {<br> x: number;<br> y?: number;<br> } = { x: 1, y: undefined }; // 报错<br> 上面示例中，打开了这两个设置以后，可选属性就不能设为undefined了。</p><p>注意，可选属性与允许设为undefined的必选属性是不等价的。</p><p>type A = { x:number, y?:number };<br> type B = { x:number, y:number|undefined };</p><p>const ObjA:A = { x: 1 }; // 正确<br> const ObjB:B = { x: 1 }; // 报错<br> 上面示例中，属性y如果是一个可选属性，那就可以省略不写；如果是允许设为undefined的必选属性，一旦省略就会报错，必须显式写成{ x: 1, y: undefined }。</p><h2 id="只读属性" tabindex="-1"><a class="header-anchor" href="#只读属性"><span>只读属性</span></a></h2><p>属性名前面加上readonly关键字，表示这个属性是只读属性，不能修改。</p><p>interface MyInterface {<br> readonly prop: number;<br> }<br> 上面示例中，prop属性是只读属性，不能修改它的值。</p><p>const person:{<br> readonly age: number<br> } = { age: 20 };</p><p>person.age = 21; // 报错<br> 上面示例中，最后一行修改了只读属性age，就报错了。</p><p>只读属性只能在对象初始化期间赋值，此后就不能修改该属性。</p><p>type Point = {<br> readonly x: number;<br> readonly y: number;<br> };</p><p>const p:Point = { x: 0, y: 0 };</p><p>p.x = 100; // 报错<br> 上面示例中，类型Point的属性x和y都带有修饰符readonly，表示这两个属性只能在初始化期间赋值，后面再修改就会报错。</p><p>注意，如果属性值是一个对象，readonly修饰符并不禁止修改该对象的属性，只是禁止完全替换掉该对象。</p><p>interface Home {<br> readonly resident: {<br> name: string;<br> age: number<br> };<br> }</p><p>const h:Home = {<br> resident: {<br> name: &#39;Vicky&#39;,<br> age: 42<br> }<br> };</p><p>h.resident.age = 32; // 正确<br> h.resident = {<br> name: &#39;Kate&#39;,<br> age: 23<br> } // 报错<br> 上面示例中，h.resident是只读属性，它的值是一个对象。修改这个对象的age属性是可以的，但是整个替换掉h.resident属性会报错。</p><p>另一个需要注意的地方是，如果一个对象有两个引用，即两个变量对应同一个对象，其中一个变量是可写的，另一个变量是只读的，那么从可写变量修改属性，会影响到只读变量。</p><p>interface Person {<br> name: string;<br> age: number;<br> }</p><p>interface ReadonlyPerson {<br> readonly name: string;<br> readonly age: number;<br> }</p><p>let w:Person = {<br> name: &#39;Vicky&#39;,<br> age: 42,<br> };</p><p>let r:ReadonlyPerson = w;</p><p>w.age += 1;<br> r.age // 43<br> 上面示例中，变量w和r指向同一个对象，其中w是可写的，r是只读的。那么，对w的属性修改，会影响到r。</p><p>如果希望属性值是只读的，除了声明时加上readonly关键字，还有一种方法，就是在赋值时，在对象后面加上只读断言as const。</p><p>const myUser = {<br> name: &quot;Sabrina&quot;,<br> } as const;</p><p>myUser.name = &quot;Cynthia&quot;; // 报错<br> 上面示例中，对象后面加了只读断言as const，就变成只读对象了，不能修改属性了。</p><p>注意，上面的as const属于 TypeScript 的类型推断，如果变量明确地声明了类型，那么 TypeScript 会以声明的类型为准。</p><p>const myUser:{ name: string } = {<br> name: &quot;Sabrina&quot;,<br> } as const;</p><p>myUser.name = &quot;Cynthia&quot;; // 正确<br> 上面示例中，根据变量myUser的类型声明，name不是只读属性，但是赋值时又使用只读断言as const。这时会以声明的类型为准，因为name属性可以修改。</p><h2 id="属性名的索引类型" tabindex="-1"><a class="header-anchor" href="#属性名的索引类型"><span>属性名的索引类型</span></a></h2><p>如果对象的属性非常多，一个个声明类型就很麻烦，而且有些时候，无法事前知道对象会有多少属性，比如外部 API 返回的对象。这时 TypeScript 允许采用属性名表达式的写法来描述类型，称为“属性名的索引类型”。</p><p>索引类型里面，最常见的就是属性名的字符串索引。</p><p>type MyObj = {<br> [property: string]: string<br> };</p><p>const obj:MyObj = {<br> foo: &#39;a&#39;,<br> bar: &#39;b&#39;,<br> baz: &#39;c&#39;,<br> };<br> 上面示例中，类型MyObj的属性名类型就采用了表达式形式，写在方括号里面。[property: string]的property表示属性名，这个是可以随便起的，它的类型是string，即属性名类型为string。也就是说，不管这个对象有多少属性，只要属性名为字符串，且属性值也是字符串，就符合这个类型声明。</p><p>JavaScript 对象的属性名（即上例的property）的类型有三种可能，除了上例的string，还有number和symbol。</p><p>type T1 = {<br> [property: number]: string<br> };</p><p>type T2 = {<br> [property: symbol]: string<br> };<br> 上面示例中，对象属性名的类型分别为number和symbol。</p><p>type MyArr = {<br> [n:number]: number;<br> };</p><p>const arr:MyArr = [1, 2, 3];<br> // 或者<br> const arr:MyArr = {<br> 0: 1,<br> 1: 2,<br> 2: 3,<br> };<br> 上面示例中，对象类型MyArr的属性名是[n:number]，就表示它的属性名都是数值，比如0、1、2。</p><p>对象可以同时有多种类型的属性名索引，比如同时有数值索引和字符串索引。但是，数值索引不能与字符串索引发生冲突，必须服从后者，这是因为在 JavaScript 语言内部，所有的数值属性名都会自动转为字符串属性名。</p><p>type MyType = {<br> [x: number]: boolean; // 报错<br> [x: string]: string;<br> }<br> 上面示例中，类型MyType同时有两种属性名索引，但是数值索引与字符串索引冲突了，所以报错了。由于字符属性名的值类型是string，数值属性名的值类型只有同样为string，才不会报错。</p><p>同样地，可以既声明属性名索引，也声明具体的单个属性名。如果单个属性名不符合属性名索引的范围，两者发生冲突，就会报错。</p><p>type MyType = {<br> foo: boolean; // 报错<br> [x: string]: string;<br> }<br> 上面示例中，属性名foo符合属性名的字符串索引，但是两者的属性值类型不一样，所以报错了。</p><p>属性的索引类型写法，建议谨慎使用，因为属性名的声明太宽泛，约束太少。另外，属性名的数值索引不宜用来声明数组，因为采用这种方式声明数组，就不能使用各种数组方法以及length属性，因为类型里面没有定义这些东西。</p><p>type MyArr = {<br> [n:number]: number;<br> };</p><p>const arr:MyArr = [1, 2, 3];<br> arr.length // 报错<br> 上面示例中，读取arr.length属性会报错，因为类型MyArr没有这个属性。</p><h2 id="解构赋值" tabindex="-1"><a class="header-anchor" href="#解构赋值"><span>解构赋值</span></a></h2><p>解构赋值用于直接从对象中提取属性。</p><p>const {id, name, price} = product;<br> 上面语句从对象product提取了三个属性，并声明属性名的同名变量。</p><p>解构赋值的类型写法，跟为对象声明类型是一样的。</p><p>const {id, name, price}:{<br> id: string;<br> name: string;<br> price: number<br> } = product;<br> 注意，目前没法为解构变量指定类型，因为对象解构里面的冒号，JavaScript 指定了其他用途。</p><p>let { x: foo, y: bar } = obj;</p><p>// 等同于<br> let foo = obj.x;<br> let bar = obj.y;<br> 上面示例中，冒号不是表示属性x和y的类型，而是为这两个属性指定新的变量名。如果要为x和y指定类型，不得不写成下面这样。</p><p>let { x: foo, y: bar }<br> : { x: string; y: number } = obj;<br> 这一点要特别小心，TypeScript 里面很容易搞糊涂。</p><p>function draw({<br> shape: Shape,<br> xPos: number = 100<br> }) {<br> let myShape = shape; // 报错<br> let x = xPos; // 报错<br> }<br> 上面示例中，函数draw()的参数是一个对象解构，里面的冒号很像是为变量指定类型，其实是为对应的属性指定新的变量名。所以，TypeScript 就会解读成，函数体内不存在变量shape，而是属性shape的值被赋值给了变量Shape。</p><h2 id="结构类型原则" tabindex="-1"><a class="header-anchor" href="#结构类型原则"><span>结构类型原则</span></a></h2><p>只要对象 B 满足 对象 A 的结构特征，TypeScript 就认为对象 B 兼容对象 A 的类型，这称为“结构类型”原则（structural typing）。</p><p>type A = {<br> x: number;<br> };</p><p>type B = {<br> x: number;<br> y: number;<br> };<br> 上面示例中，对象A只有一个属性x，类型为number。对象B满足这个特征，因此兼容对象A，只要可以使用A的地方，就可以使用B。</p><p>const B = {<br> x: 1,<br> y: 1<br> };</p><p>const A:{ x: number } = B; // 正确<br> 上面示例中，A和B并不是同一个类型，但是B可以赋值给A，因为B满足A的结构特征。</p><p>根据“结构类型”原则，TypeScript 检查某个值是否符合指定类型时，并不是检查这个值的类型名（即“名义类型”），而是检查这个值的结构是否符合要求（即“结构类型”）。</p><p>TypeScript 之所以这样设计，是为了符合 JavaScript 的行为。JavaScript 并不关心对象是否严格相似，只要某个对象具有所要求的属性，就可以正确运行。</p><p>如果类型 B 可以赋值给类型 A，TypeScript 就认为 B 是 A 的子类型（subtyping），A 是 B 的父类型。子类型满足父类型的所有结构特征，同时还具有自己的特征。凡是可以使用父类型的地方，都可以使用子类型，即子类型兼容父类型。</p><p>这种设计有时会导致令人惊讶的结果。</p><p>type myObj = {<br> x: number,<br> y: number,<br> };</p><p>function getSum(obj:myObj) {<br> let sum = 0;</p><p>for (const n of Object.keys(obj)) {<br> const v = obj[n]; // 报错<br> sum += Math.abs(v);<br> }</p><p>return sum;<br> }<br> 上面示例中，函数getSum()要求传入参数的类型是myObj，但是实际上所有与myObj兼容的对象都可以传入。这会导致const v = obj[n]这一行报错，原因是obj[n]取出的属性值不一定是数值（number），使得变量v的类型被推断为any。如果项目设置为不允许变量类型推断为any，代码就会报错。写成下面这样，就不会报错。</p><p>type MyObj = {<br> x: number,<br> y: number,<br> };</p><p>function getSum(obj:MyObj) {<br> return Math.abs(obj.x) + Math.abs(obj.y);<br> }<br> 上面示例就不会报错，因为函数体内部只使用了属性x和y，这两个属性有明确的类型声明，保证obj.x和obj.y肯定是数值。虽然与MyObj兼容的任何对象都可以传入函数getSum()，但是只要不使用其他属性，就不会有类型报错。</p><h2 id="严格字面量检查" tabindex="-1"><a class="header-anchor" href="#严格字面量检查"><span>严格字面量检查</span></a></h2><p>如果对象使用字面量表示，会触发 TypeScript 的严格字面量检查（strict object literal checking）。如果字面量的结构跟类型定义的不一样（比如多出了未定义的属性），就会报错。</p><p>const point:{<br> x:number;<br> y:number;<br> } = {<br> x: 1,<br> y: 1,<br> z: 1 // 报错<br> };<br> 上面示例中，等号右边是一个对象的字面量，这时会触发严格字面量检查。只要有类型声明中不存在的属性（本例是z），就会导致报错。</p><p>如果等号右边不是字面量，而是一个变量，根据结构类型原则，是不会报错的。</p><p>const myPoint = {<br> x: 1,<br> y: 1,<br> z: 1<br> };</p><p>const point:{<br> x:number;<br> y:number;<br> } = myPoint; // 正确<br> 上面示例中，等号右边是一个变量，就不会触发严格字面量检查，从而不报错。</p><p>TypeScript 对字面量进行严格检查的目的，主要是防止拼写错误。一般来说，字面量大多数来自手写，容易出现拼写错误，或者误用 API。</p><p>type Options = {<br> title:string;<br> darkMode?:boolean;<br> };</p><p>const obj:Options = {<br> title: &#39;我的网页&#39;,<br> darkmode: true, // 报错<br> };<br> 上面示例中，属性darkMode拼写错了，成了darkmode。如果没有严格字面量规则，就不会报错，因为darkMode是可选属性，根据结构类型原则，任何对象只要有title属性，都认为符合Options类型。</p><p>规避严格字面量检查，可以使用中间变量。</p><p>let myOptions = {<br> title: &#39;我的网页&#39;,<br> darkmode: true,<br> };</p><p>const obj:Options = myOptions;<br> 上面示例中，创建了一个中间变量myOptions，就不会触发严格字面量规则，因为这时变量obj的赋值，不属于直接字面量赋值。</p><p>如果你确认字面量没有错误，也可以使用类型断言规避严格字面量检查。</p><p>const obj:Options = {<br> title: &#39;我的网页&#39;,<br> darkmode: true,<br> } as Options;<br> 上面示例使用类型断言as Options，告诉编译器，字面量符合 Options 类型，就能规避这条规则。</p><p>如果允许字面量有多余属性，可以像下面这样在类型里面定义一个通用属性。</p><p>let x: {<br> foo: number,<br> [x: string]: any<br> };</p><p>x = { foo: 1, baz: 2 }; // Ok<br> 上面示例中，变量x的类型声明里面，有一个属性的字符串索引（[x: string]），导致任何字符串属性名都是合法的。</p><p>由于严格字面量检查，字面量对象传入函数必须很小心，不能有多余的属性。</p><p>interface Point {<br> x: number;<br> y: number;<br> }</p><p>function computeDistance(point: Point) { /<em>...</em>/ }</p><p>computeDistance({ x: 1, y: 2, z: 3 }); // 报错<br> computeDistance({x: 1, y: 2}); // 正确<br> 上面示例中，对象字面量传入函数computeDistance()时，不能有多余的属性，否则就通不过严格字面量检查。</p><p>编译器选项suppressExcessPropertyErrors，可以关闭多余属性检查。下面是它在 tsconfig.json 文件里面的写法。</p><p>{<br> &quot;compilerOptions&quot;: {<br> &quot;suppressExcessPropertyErrors&quot;: true<br> }<br> }</p><h2 id="最小可选属性规则" tabindex="-1"><a class="header-anchor" href="#最小可选属性规则"><span>最小可选属性规则</span></a></h2><p>根据“结构类型”原则，如果一个对象的所有属性都是可选的，那么其他对象跟它都是结构类似的。</p><p>type Options = {<br> a?:number;<br> b?:number;<br> c?:number;<br> };<br> 上面示例中，类型Options的所有属性都是可选的，所以它可以是一个空对象，也就意味着任意对象都满足Options的结构。</p><p>为了避免这种情况，TypeScript 2.4 引入了一个“最小可选属性规则”，也称为“弱类型检测”（weak type detection）。</p><p>type Options = {<br> a?:number;<br> b?:number;<br> c?:number;<br> };</p><p>const opts = { d: 123 };</p><p>const obj:Options = opts; // 报错<br> 上面示例中，对象opts与类型Options没有共同属性，赋值给该类型的变量就会报错。</p><p>报错原因是，如果某个类型的所有属性都是可选的，那么该类型的对象必须至少存在一个可选属性，不能所有可选属性都不存在。这就叫做“最小可选属性规则”。</p><p>如果想规避这条规则，要么在类型里面增加一条索引属性（[propName: string]: someType），要么使用类型断言（opts as Options）。</p><h2 id="空对象" tabindex="-1"><a class="header-anchor" href="#空对象"><span>空对象</span></a></h2><p>空对象是 TypeScript 的一种特殊值，也是一种特殊类型。</p><p>const obj = {};<br> obj.prop = 123; // 报错<br> 上面示例中，变量obj的值是一个空对象，然后对obj.prop赋值就会报错。</p><p>原因是这时 TypeScript 会推断变量obj的类型为空对象，实际执行的是下面的代码。</p><p>const obj:{} = {};<br> 空对象没有自定义属性，所以对自定义属性赋值就会报错。空对象只能使用继承的属性，即继承自原型对象Object.prototype的属性。</p><p>obj.toString() // 正确<br> 上面示例中，toString()方法是一个继承自原型对象的方法，TypeScript 允许在空对象上使用。</p><p>回到本节开始的例子，这种写法其实在 JavaScript 很常见：先声明一个空对象，然后向空对象添加属性。但是，TypeScript 不允许动态添加属性，所以对象不能分步生成，必须生成时一次性声明所有属性。</p><p>// 错误<br> const pt = {};<br> pt.x = 3;<br> pt.y = 4;</p><p>// 正确<br> const pt = {<br> x: 3,<br> y: 4<br> };<br> 如果确实需要分步声明，一个比较好的方法是，使用扩展运算符（...）合成一个新对象。</p><p>const pt0 = {};<br> const pt1 = { x: 3 };<br> const pt2 = { y: 4 };</p><p>const pt = {<br> ...pt0, ...pt1, ...pt2<br> };<br> 上面示例中，对象pt是三个部分合成的，这样既可以分步声明，也符合 TypeScript 静态声明的要求。</p><p>空对象作为类型，其实是Object类型的简写形式。</p><p>let d:{};<br> // 等同于<br> // let d:Object;</p><p>d = {};<br> d = { x: 1 };<br> d = &#39;hello&#39;;<br> d = 2;<br> 上面示例中，各种类型的值（除了null和undefined）都可以赋值给空对象类型，跟Object类型的行为是一样的。</p><p>因为Object可以接受各种类型的值，而空对象是Object类型的简写，所以它不会有严格字面量检查，赋值时总是允许多余的属性，只是不能读取这些属性。</p><p>interface Empty { }<br> const b:Empty = {myProp: 1, anotherProp: 2}; // 正确<br> b.myProp // 报错<br> 上面示例中，变量b的类型是空对象，视同Object类型，不会有严格字面量检查，但是读取多余的属性会报错。</p><p>如果想强制使用没有任何属性的对象，可以采用下面的写法。</p><p>interface WithoutProperties {<br> [key: string]: never;<br> }</p><p>// 报错<br> const a:WithoutProperties = { prop: 1 };<br> 上面的示例中，[key: string]: never表示字符串属性名是不存在的，因此其他对象进行赋值时就会报错。</p>',165)]))}const y=e(n,[["render",o],["__file","ts对象类型.html.vue"]]),c=JSON.parse('{"path":"/js/ts/ts%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B.html","title":"","lang":"zh-CN","frontmatter":{"description":"除了原始类型，对象是 JavaScript 最基本的数据结构。TypeScript 对于对象类型有很多规则。 对象类型的最简单声明方法，就是使用大括号表示对象，在大括号内部声明每个属性和方法的类型。 const obj:{ x:number; y:number; } = { x: 1, y: 1 }; 上面示例中，对象obj的类型就写在变量名后面，使用...","head":[["meta",{"property":"og:url","content":"https://0oWSQo0.github.io/wsq-blog/js/ts/ts%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B.html"}],["meta",{"property":"og:description","content":"除了原始类型，对象是 JavaScript 最基本的数据结构。TypeScript 对于对象类型有很多规则。 对象类型的最简单声明方法，就是使用大括号表示对象，在大括号内部声明每个属性和方法的类型。 const obj:{ x:number; y:number; } = { x: 1, y: 1 }; 上面示例中，对象obj的类型就写在变量名后面，使用..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-09-11T05:57:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-09-11T05:57:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-09-11T05:57:00.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"WSQ\\",\\"url\\":\\"https://0oWSQo0.github.com\\"}]}"]]},"headers":[{"level":2,"title":"可选属性","slug":"可选属性","link":"#可选属性","children":[]},{"level":2,"title":"只读属性","slug":"只读属性","link":"#只读属性","children":[]},{"level":2,"title":"属性名的索引类型","slug":"属性名的索引类型","link":"#属性名的索引类型","children":[]},{"level":2,"title":"解构赋值","slug":"解构赋值","link":"#解构赋值","children":[]},{"level":2,"title":"结构类型原则","slug":"结构类型原则","link":"#结构类型原则","children":[]},{"level":2,"title":"严格字面量检查","slug":"严格字面量检查","link":"#严格字面量检查","children":[]},{"level":2,"title":"最小可选属性规则","slug":"最小可选属性规则","link":"#最小可选属性规则","children":[]},{"level":2,"title":"空对象","slug":"空对象","link":"#空对象","children":[]}],"git":{"createdTime":1726034220000,"updatedTime":1726034220000,"contributors":[{"name":"WSQ","email":"592786982@qq.com","commits":1}]},"readingTime":{"minutes":17.41,"words":5222},"filePathRelative":"js/ts/ts对象类型.md","localizedDate":"2024年9月11日","autoDesc":true}');export{y as comp,c as data};
