import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,d as o,o as l}from"./app-CRBxQhNH.js";const p={};function e(F,s){return l(),n("div",null,s[0]||(s[0]=[o(`<h2 id="属性的简洁表示法" tabindex="-1"><a class="header-anchor" href="#属性的简洁表示法"><span>属性的简洁表示法</span></a></h2><p>ES6允许直接写入变量和函数，作为对象的属性和方法。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> foo</span><span style="color:#FF9492;"> =</span><span style="color:#ADDCFF;"> &#39;bar&#39;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> baz</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> {foo};</span></span>
<span class="line"><span style="color:#F0F3F6;">baz </span><span style="color:#BDC4CC;">// {foo: &quot;bar&quot;}</span></span>
<span class="line"><span style="color:#BDC4CC;">// 等同于</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> baz</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> {foo: foo};</span></span></code></pre></div><p>上面代码表明，ES6允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">function</span><span style="color:#DBB7FF;"> f</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">x</span><span style="color:#F0F3F6;">, </span><span style="color:#FFB757;">y</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#FF9492;">  return</span><span style="color:#F0F3F6;"> {x, y};</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#BDC4CC;">// 等同于</span></span>
<span class="line"><span style="color:#FF9492;">function</span><span style="color:#DBB7FF;"> f</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">x</span><span style="color:#F0F3F6;">, </span><span style="color:#FFB757;">y</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#FF9492;">  return</span><span style="color:#F0F3F6;"> {x: x, y: y};</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#DBB7FF;">f</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">) </span><span style="color:#BDC4CC;">// Object {x: 1, y: 2}</span></span></code></pre></div><p>除了属性简写，方法也可以简写。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> o</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#DBB7FF;">  method</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#FF9492;">    return</span><span style="color:#ADDCFF;"> &quot;Hello!&quot;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span>
<span class="line"><span style="color:#BDC4CC;">// 等同于</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> o</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#DBB7FF;">  method</span><span style="color:#F0F3F6;">: </span><span style="color:#FF9492;">function</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#FF9492;">    return</span><span style="color:#ADDCFF;"> &quot;Hello!&quot;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span></code></pre></div><p>下面是一个实际的例子。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> birth </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &#39;2000/01/01&#39;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> Person</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">  name: </span><span style="color:#ADDCFF;">&#39;张三&#39;</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#BDC4CC;">  //等同于birth: birth</span></span>
<span class="line"><span style="color:#F0F3F6;">  birth,</span></span>
<span class="line"><span style="color:#BDC4CC;">  // 等同于hello: function ()...</span></span>
<span class="line"><span style="color:#DBB7FF;">  hello</span><span style="color:#F0F3F6;">() { console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;我的名字是&#39;</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">this</span><span style="color:#F0F3F6;">.name); }</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span></code></pre></div><p>这种写法用于函数的返回值，将会非常方便。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">function</span><span style="color:#DBB7FF;"> getPoint</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#FF9492;">  const</span><span style="color:#91CBFF;"> x</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> 1</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">  const</span><span style="color:#91CBFF;"> y</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> 10</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">  return</span><span style="color:#F0F3F6;"> {x, y};</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#DBB7FF;">getPoint</span><span style="color:#F0F3F6;">() </span><span style="color:#BDC4CC;">// {x:1, y:10}</span></span></code></pre></div><p>CommonJS模块输出一组变量，就非常合适使用简洁写法。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> ms </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> {};</span></span>
<span class="line"><span style="color:#FF9492;">function</span><span style="color:#DBB7FF;"> getItem</span><span style="color:#F0F3F6;"> (</span><span style="color:#FFB757;">key</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#FF9492;">  return</span><span style="color:#F0F3F6;"> key </span><span style="color:#FF9492;">in</span><span style="color:#F0F3F6;"> ms </span><span style="color:#FF9492;">?</span><span style="color:#F0F3F6;"> ms[key] </span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;"> null</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#FF9492;">function</span><span style="color:#DBB7FF;"> setItem</span><span style="color:#F0F3F6;"> (</span><span style="color:#FFB757;">key</span><span style="color:#F0F3F6;">, </span><span style="color:#FFB757;">value</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#F0F3F6;">  ms[key] </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> value;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#FF9492;">function</span><span style="color:#DBB7FF;"> clear</span><span style="color:#F0F3F6;"> () {</span></span>
<span class="line"><span style="color:#F0F3F6;">  ms </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> {};</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#91CBFF;">module</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">exports</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> { getItem, setItem, clear };</span></span>
<span class="line"><span style="color:#BDC4CC;">// 等同于</span></span>
<span class="line"><span style="color:#91CBFF;">module</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">exports</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">  getItem: getItem,</span></span>
<span class="line"><span style="color:#F0F3F6;">  setItem: setItem,</span></span>
<span class="line"><span style="color:#F0F3F6;">  clear: clear</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span></code></pre></div><p>属性的赋值器（<code>setter</code>）和取值器（<code>getter</code>），事实上也是采用这种写法。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> cart</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">  _wheels: </span><span style="color:#91CBFF;">4</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#FF9492;">  get</span><span style="color:#DBB7FF;"> wheels</span><span style="color:#F0F3F6;"> () {</span></span>
<span class="line"><span style="color:#FF9492;">    return</span><span style="color:#91CBFF;"> this</span><span style="color:#F0F3F6;">._wheels;</span></span>
<span class="line"><span style="color:#F0F3F6;">  },</span></span>
<span class="line"><span style="color:#FF9492;">  set</span><span style="color:#DBB7FF;"> wheels</span><span style="color:#F0F3F6;"> (</span><span style="color:#FFB757;">value</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#FF9492;">    if</span><span style="color:#F0F3F6;"> (value </span><span style="color:#FF9492;">&lt;</span><span style="color:#91CBFF;"> this</span><span style="color:#F0F3F6;">._wheels) {</span></span>
<span class="line"><span style="color:#FF9492;">      throw</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> Error</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;数值太小了！&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#F0F3F6;">    }</span></span>
<span class="line"><span style="color:#91CBFF;">    this</span><span style="color:#F0F3F6;">._wheels </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> value;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>注意，简洁写法的属性名总是字符串，这会导致一些看上去比较奇怪的结果。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> obj</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#DBB7FF;">  class</span><span style="color:#F0F3F6;"> () {}</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span>
<span class="line"><span style="color:#BDC4CC;">// 等同于</span></span>
<span class="line"><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> obj </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#ADDCFF;">  &#39;class&#39;</span><span style="color:#F0F3F6;">: </span><span style="color:#FF9492;">function</span><span style="color:#F0F3F6;">() {}</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span></code></pre></div><p>上面代码中，<code>class</code>是字符串，所以不会因为它属于关键字，而导致语法解析报错。<br> 如果某个方法的值是一个<code>Generator</code>函数，前面需要加上星号。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> obj</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  *</span><span style="color:#DBB7FF;"> m</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#FF9492;">    yield</span><span style="color:#ADDCFF;"> &#39;hello world&#39;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span></code></pre></div><h2 id="属性名表达式" tabindex="-1"><a class="header-anchor" href="#属性名表达式"><span>属性名表达式</span></a></h2><p>JavaScript定义对象的属性，有两种方法。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">// 方法一</span></span>
<span class="line"><span style="color:#F0F3F6;">obj.foo </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> true</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#BDC4CC;">// 方法二</span></span>
<span class="line"><span style="color:#F0F3F6;">obj[</span><span style="color:#ADDCFF;">&#39;a&#39;</span><span style="color:#FF9492;"> +</span><span style="color:#ADDCFF;"> &#39;bc&#39;</span><span style="color:#F0F3F6;">] </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 123</span><span style="color:#F0F3F6;">;</span></span></code></pre></div><p>上面代码的方法一是直接用标识符作为属性名，方法二是用表达式作为属性名，这时要将表达式放在方括号之内。<br> 但是，如果使用字面量方式定义对象（使用大括号），在 ES5中只能使用方法一（标识符）定义属性。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> obj </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">  foo: </span><span style="color:#91CBFF;">true</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#F0F3F6;">  abc: </span><span style="color:#91CBFF;">123</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span></code></pre></div><p>ES6允许字面量定义对象时，用方法二（表达式）作为对象的属性名，即把表达式放在方括号内。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> propKey </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &#39;foo&#39;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> obj </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">  [propKey]: </span><span style="color:#91CBFF;">true</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#F0F3F6;">  [</span><span style="color:#ADDCFF;">&#39;a&#39;</span><span style="color:#FF9492;"> +</span><span style="color:#ADDCFF;"> &#39;bc&#39;</span><span style="color:#F0F3F6;">]: </span><span style="color:#91CBFF;">123</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span></code></pre></div><p>下面是另一个例子。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> lastWord </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &#39;last word&#39;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> a</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#ADDCFF;">  &#39;first word&#39;</span><span style="color:#F0F3F6;">: </span><span style="color:#ADDCFF;">&#39;hello&#39;</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#F0F3F6;">  [lastWord]: </span><span style="color:#ADDCFF;">&#39;world&#39;</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span>
<span class="line"><span style="color:#F0F3F6;">a[</span><span style="color:#ADDCFF;">&#39;first word&#39;</span><span style="color:#F0F3F6;">] </span><span style="color:#BDC4CC;">// &quot;hello&quot;</span></span>
<span class="line"><span style="color:#F0F3F6;">a[lastWord] </span><span style="color:#BDC4CC;">// &quot;world&quot;</span></span>
<span class="line"><span style="color:#F0F3F6;">a[</span><span style="color:#ADDCFF;">&#39;last word&#39;</span><span style="color:#F0F3F6;">] </span><span style="color:#BDC4CC;">// &quot;world&quot;</span></span></code></pre></div><p>表达式还可以用于定义方法名。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> obj </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">  [</span><span style="color:#ADDCFF;">&#39;h&#39;</span><span style="color:#FF9492;"> +</span><span style="color:#ADDCFF;"> &#39;ello&#39;</span><span style="color:#F0F3F6;">]() {</span></span>
<span class="line"><span style="color:#FF9492;">    return</span><span style="color:#ADDCFF;"> &#39;hi&#39;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span>
<span class="line"><span style="color:#F0F3F6;">obj.</span><span style="color:#DBB7FF;">hello</span><span style="color:#F0F3F6;">() </span><span style="color:#BDC4CC;">// hi</span></span></code></pre></div><p>注意，属性名表达式与简洁表示法，不能同时使用，会报错。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">// 报错</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> foo</span><span style="color:#FF9492;"> =</span><span style="color:#ADDCFF;"> &#39;bar&#39;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> bar</span><span style="color:#FF9492;"> =</span><span style="color:#ADDCFF;"> &#39;abc&#39;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> baz</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> { [foo] };</span></span>
<span class="line"><span style="color:#BDC4CC;">// 正确</span></span>
<span class="line"><span style="color:#F0F3F6;">const foo = &#39;bar&#39;;</span></span>
<span class="line"><span style="color:#F0F3F6;">const baz = { [foo]: </span><span style="color:#ADDCFF;">&#39;abc&#39;</span><span style="color:#F0F3F6;">};</span></span></code></pre></div><p>注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串<code>[object Object]</code>，这一点要特别小心。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> keyA</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> {a: </span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">};</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> keyB</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> {b: </span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">};</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> myObject</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">  [keyA]: </span><span style="color:#ADDCFF;">&#39;valueA&#39;</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#F0F3F6;">  [keyB]: </span><span style="color:#ADDCFF;">&#39;valueB&#39;</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span>
<span class="line"><span style="color:#F0F3F6;">myObject </span><span style="color:#BDC4CC;">// Object {[object Object]: &quot;valueB&quot;}</span></span></code></pre></div><p>上面代码中，<code>[keyA]</code>和<code>[keyB]</code>得到的都是<code>[object Object]</code>，所以<code>[keyB]</code>会把<code>[keyA]</code>覆盖掉，而<code>myObject</code>最后只有一个<code>[object Object]</code>属性。</p><h2 id="方法的name属性" tabindex="-1"><a class="header-anchor" href="#方法的name属性"><span>方法的name属性</span></a></h2><p>函数的<code>name</code>属性，返回函数名。对象方法也是函数，因此也有<code>name</code>属性。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> person</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#DBB7FF;">  sayName</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#F0F3F6;">    console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;hello!&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#F0F3F6;">  },</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span>
<span class="line"><span style="color:#F0F3F6;">person.sayName.name   </span><span style="color:#BDC4CC;">// &quot;sayName&quot;</span></span></code></pre></div><p>如果对象的方法使用了取值函数（<code>getter</code>）和存值函数（<code>setter</code>），则<code>name</code>属性不是在该方法上面，而是该方法的属性的描述对象的<code>get</code>和<code>set</code>属性上面，返回值是方法名前加上<code>get</code>和<code>set</code>。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> obj</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  get</span><span style="color:#DBB7FF;"> foo</span><span style="color:#F0F3F6;">() {},</span></span>
<span class="line"><span style="color:#FF9492;">  set</span><span style="color:#DBB7FF;"> foo</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">x</span><span style="color:#F0F3F6;">) {}</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span>
<span class="line"><span style="color:#F0F3F6;">obj.foo.name</span></span>
<span class="line"><span style="color:#BDC4CC;">// TypeError: Cannot read property &#39;name&#39; of undefined</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> descriptor</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> Object.</span><span style="color:#DBB7FF;">getOwnPropertyDescriptor</span><span style="color:#F0F3F6;">(obj, </span><span style="color:#ADDCFF;">&#39;foo&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#F0F3F6;">descriptor.get.name </span><span style="color:#BDC4CC;">// &quot;get foo&quot;</span></span>
<span class="line"><span style="color:#F0F3F6;">descriptor.set.name </span><span style="color:#BDC4CC;">// &quot;set foo&quot;</span></span></code></pre></div><p>有两种特殊情况：<code>bind</code>方法创造的函数，<code>name</code>属性返回<code>bound</code>加上原函数的名字；<code>Function</code>构造函数创造的函数，<code>name</code>属性返回<code>anonymous</code>。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">(</span><span style="color:#FF9492;">new</span><span style="color:#DBB7FF;"> Function</span><span style="color:#F0F3F6;">()).name </span><span style="color:#BDC4CC;">// &quot;anonymous&quot;</span></span>
<span class="line"><span style="color:#FF9492;">var</span><span style="color:#DBB7FF;"> doSomething</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> function</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#BDC4CC;">  // ...</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span>
<span class="line"><span style="color:#F0F3F6;">doSomething.</span><span style="color:#DBB7FF;">bind</span><span style="color:#F0F3F6;">().name </span><span style="color:#BDC4CC;">// &quot;bound doSomething&quot;</span></span></code></pre></div><p>如果对象的方法是一个<code>Symbol</code>值，那么<code>name</code>属性返回的是这个<code>Symbol</code>值的描述。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> key1</span><span style="color:#FF9492;"> =</span><span style="color:#DBB7FF;"> Symbol</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;description&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> key2</span><span style="color:#FF9492;"> =</span><span style="color:#DBB7FF;"> Symbol</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> obj </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">  [key1]() {},</span></span>
<span class="line"><span style="color:#F0F3F6;">  [key2]() {},</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span>
<span class="line"><span style="color:#F0F3F6;">obj[key1].name </span><span style="color:#BDC4CC;">// &quot;[description]&quot;</span></span>
<span class="line"><span style="color:#F0F3F6;">obj[key2].name </span><span style="color:#BDC4CC;">// &quot;&quot;</span></span></code></pre></div><p>上面代码中，<code>key1</code>对应的<code>Symbol</code>值有描述，<code>key2</code>没有。</p><h2 id="object-is" tabindex="-1"><a class="header-anchor" href="#object-is"><span>Object.is()</span></a></h2><p>ES5比较两个值是否相等，只有两个运算符：相等运算符（<mark>）和严格相等运算符（</mark>=）。它们都有缺点，前者会自动转换数据类型，后者的<code>NaN</code>不等于自身，以及+0等于-0。JavaScript缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。<br> ES6提出同值相等算法，用来解决这个问题。<code>Object.is</code>就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">is</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;foo&#39;</span><span style="color:#F0F3F6;">, </span><span style="color:#ADDCFF;">&#39;foo&#39;</span><span style="color:#F0F3F6;">) </span><span style="color:#BDC4CC;">// true</span></span>
<span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">is</span><span style="color:#F0F3F6;">({}, {}) </span><span style="color:#BDC4CC;">// false</span></span></code></pre></div><p>不同之处只有两个：一是+0不等于-0，二是<code>NaN</code>等于自身。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">+</span><span style="color:#91CBFF;">0</span><span style="color:#FF9492;"> ===</span><span style="color:#FF9492;"> -</span><span style="color:#91CBFF;">0</span><span style="color:#BDC4CC;"> //true</span></span>
<span class="line"><span style="color:#91CBFF;">NaN</span><span style="color:#FF9492;"> ===</span><span style="color:#91CBFF;"> NaN</span><span style="color:#BDC4CC;"> // false</span></span>
<span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">is</span><span style="color:#F0F3F6;">(</span><span style="color:#FF9492;">+</span><span style="color:#91CBFF;">0</span><span style="color:#F0F3F6;">, </span><span style="color:#FF9492;">-</span><span style="color:#91CBFF;">0</span><span style="color:#F0F3F6;">) </span><span style="color:#BDC4CC;">// false</span></span>
<span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">is</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">NaN</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">NaN</span><span style="color:#F0F3F6;">) </span><span style="color:#BDC4CC;">// true</span></span></code></pre></div><p>ES5可以通过下面的代码，部署<code>Object.is</code>。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">defineProperty</span><span style="color:#F0F3F6;">(Object, </span><span style="color:#ADDCFF;">&#39;is&#39;</span><span style="color:#F0F3F6;">, {</span></span>
<span class="line"><span style="color:#DBB7FF;">  value</span><span style="color:#F0F3F6;">: </span><span style="color:#FF9492;">function</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">x</span><span style="color:#F0F3F6;">, </span><span style="color:#FFB757;">y</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#FF9492;">    if</span><span style="color:#F0F3F6;"> (x </span><span style="color:#FF9492;">===</span><span style="color:#F0F3F6;"> y) {</span></span>
<span class="line"><span style="color:#BDC4CC;">      // 针对+0 不等于 -0的情况</span></span>
<span class="line"><span style="color:#FF9492;">      return</span><span style="color:#F0F3F6;"> x </span><span style="color:#FF9492;">!==</span><span style="color:#91CBFF;"> 0</span><span style="color:#FF9492;"> ||</span><span style="color:#91CBFF;"> 1</span><span style="color:#FF9492;"> /</span><span style="color:#F0F3F6;"> x </span><span style="color:#FF9492;">===</span><span style="color:#91CBFF;"> 1</span><span style="color:#FF9492;"> /</span><span style="color:#F0F3F6;"> y;</span></span>
<span class="line"><span style="color:#F0F3F6;">    }</span></span>
<span class="line"><span style="color:#BDC4CC;">    // 针对NaN的情况</span></span>
<span class="line"><span style="color:#FF9492;">    return</span><span style="color:#F0F3F6;"> x </span><span style="color:#FF9492;">!==</span><span style="color:#F0F3F6;"> x </span><span style="color:#FF9492;">&amp;&amp;</span><span style="color:#F0F3F6;"> y </span><span style="color:#FF9492;">!==</span><span style="color:#F0F3F6;"> y;</span></span>
<span class="line"><span style="color:#F0F3F6;">  },</span></span>
<span class="line"><span style="color:#F0F3F6;">  configurable: </span><span style="color:#91CBFF;">true</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#F0F3F6;">  enumerable: </span><span style="color:#91CBFF;">false</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#F0F3F6;">  writable: </span><span style="color:#91CBFF;">true</span></span>
<span class="line"><span style="color:#F0F3F6;">});</span></span></code></pre></div><h2 id="object-assign" tabindex="-1"><a class="header-anchor" href="#object-assign"><span>Object.assign()</span></a></h2><h3 id="基本用法" tabindex="-1"><a class="header-anchor" href="#基本用法"><span>基本用法</span></a></h3><p><code>Object.assign</code>方法用于对象的合并，将源对象的所有可枚举属性，复制到目标对象。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> target</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> { a: </span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;"> };</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> source1</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> { b: </span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;"> };</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> source2</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> { c: </span><span style="color:#91CBFF;">3</span><span style="color:#F0F3F6;"> };</span></span>
<span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">assign</span><span style="color:#F0F3F6;">(target, source1, source2);</span></span>
<span class="line"><span style="color:#F0F3F6;">target </span><span style="color:#BDC4CC;">// {a:1, b:2, c:3}</span></span></code></pre></div><p><code>Object.assign</code>方法的第一个参数是目标对象，后面的参数都是源对象。<br> 注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> target</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> { a: </span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">, b: </span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;"> };</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> source1</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> { b: </span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">, c: </span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;"> };</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> source2</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> { c: </span><span style="color:#91CBFF;">3</span><span style="color:#F0F3F6;"> };</span></span>
<span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">assign</span><span style="color:#F0F3F6;">(target, source1, source2);</span></span>
<span class="line"><span style="color:#F0F3F6;">target </span><span style="color:#BDC4CC;">// {a:1, b:2, c:3}</span></span></code></pre></div><p>如果只有一个参数，<code>Object.assign</code>会直接返回该参数。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> obj</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> {a: </span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">};</span></span>
<span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">assign</span><span style="color:#F0F3F6;">(obj) </span><span style="color:#FF9492;">===</span><span style="color:#F0F3F6;"> obj </span><span style="color:#BDC4CC;">// true</span></span></code></pre></div><p>如果该参数不是对象，则会先转成对象，然后返回。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">typeof</span><span style="color:#F0F3F6;"> Object.</span><span style="color:#DBB7FF;">assign</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">) </span><span style="color:#BDC4CC;">// &quot;object&quot;</span></span></code></pre></div><p>由于<code>undefined</code>和<code>null</code>无法转成对象，所以如果它们作为参数，就会报错。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">assign</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">undefined</span><span style="color:#F0F3F6;">) </span><span style="color:#BDC4CC;">// 报错</span></span>
<span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">assign</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">null</span><span style="color:#F0F3F6;">) </span><span style="color:#BDC4CC;">// 报错</span></span></code></pre></div><p>如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会跳过。这意味着，如果<code>undefined</code>和<code>null</code>不在首参数，就不会报错。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> obj </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> {a: </span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">};</span></span>
<span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">assign</span><span style="color:#F0F3F6;">(obj, </span><span style="color:#91CBFF;">undefined</span><span style="color:#F0F3F6;">) </span><span style="color:#FF9492;">===</span><span style="color:#F0F3F6;"> obj </span><span style="color:#BDC4CC;">// true</span></span>
<span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">assign</span><span style="color:#F0F3F6;">(obj, </span><span style="color:#91CBFF;">null</span><span style="color:#F0F3F6;">) </span><span style="color:#FF9492;">===</span><span style="color:#F0F3F6;"> obj </span><span style="color:#BDC4CC;">// true</span></span></code></pre></div><p>其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。但是，除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> v1</span><span style="color:#FF9492;"> =</span><span style="color:#ADDCFF;"> &#39;abc&#39;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> v2</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> true</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> v3</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> 10</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> obj</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> Object.</span><span style="color:#DBB7FF;">assign</span><span style="color:#F0F3F6;">({}, v1, v2, v3);</span></span>
<span class="line"><span style="color:#F0F3F6;">console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(obj); </span><span style="color:#BDC4CC;">// { &quot;0&quot;: &quot;a&quot;, &quot;1&quot;: &quot;b&quot;, &quot;2&quot;: &quot;c&quot; }</span></span></code></pre></div><p>上面代码中，<code>v1</code>、<code>v2</code>、<code>v3</code>分别是字符串、布尔值和数值，结果只有字符串合入目标对象（以字符数组的形式），数值和布尔值都会被忽略。这是因为只有字符串的包装对象，会产生可枚举属性。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#DBB7FF;">Object</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">true</span><span style="color:#F0F3F6;">) </span><span style="color:#BDC4CC;">// {[[PrimitiveValue]]: true}</span></span>
<span class="line"><span style="color:#DBB7FF;">Object</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">10</span><span style="color:#F0F3F6;">)  </span><span style="color:#BDC4CC;">//  {[[PrimitiveValue]]: 10}</span></span>
<span class="line"><span style="color:#DBB7FF;">Object</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;abc&#39;</span><span style="color:#F0F3F6;">) </span><span style="color:#BDC4CC;">// {0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, length: 3, [[PrimitiveValue]]: &quot;abc&quot;}</span></span></code></pre></div><p>上面代码中，布尔值、数值、字符串分别转成对应的包装对象，可以看到它们的原始值都在包装对象的内部属性<code>[[PrimitiveValue]]</code>上面，这个属性是不会被<code>Object.assign</code>拷贝的。只有字符串的包装对象，会产生可枚举的实义属性，那些属性则会被拷贝。<br><code>Object.assign</code>拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（<code>enumerable: false</code>）。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">assign</span><span style="color:#F0F3F6;">({b: </span><span style="color:#ADDCFF;">&#39;c&#39;</span><span style="color:#F0F3F6;">},</span></span>
<span class="line"><span style="color:#F0F3F6;">  Object.</span><span style="color:#DBB7FF;">defineProperty</span><span style="color:#F0F3F6;">({}, </span><span style="color:#ADDCFF;">&#39;invisible&#39;</span><span style="color:#F0F3F6;">, {</span></span>
<span class="line"><span style="color:#F0F3F6;">    enumerable: </span><span style="color:#91CBFF;">false</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#F0F3F6;">    value: </span><span style="color:#ADDCFF;">&#39;hello&#39;</span></span>
<span class="line"><span style="color:#F0F3F6;">  })</span></span>
<span class="line"><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#BDC4CC;">// { b: &#39;c&#39; }</span></span></code></pre></div><p>属性名为<code>Symbol</code>值的属性，也会被<code>Object.assign</code>拷贝。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">assign</span><span style="color:#F0F3F6;">({ a: </span><span style="color:#ADDCFF;">&#39;b&#39;</span><span style="color:#F0F3F6;"> }, { [</span><span style="color:#DBB7FF;">Symbol</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;c&#39;</span><span style="color:#F0F3F6;">)]: </span><span style="color:#ADDCFF;">&#39;d&#39;</span><span style="color:#F0F3F6;"> })</span></span>
<span class="line"><span style="color:#BDC4CC;">// { a: &#39;b&#39;, Symbol(c): &#39;d&#39; }</span></span></code></pre></div><h3 id="注意点" tabindex="-1"><a class="header-anchor" href="#注意点"><span>注意点</span></a></h3><h4 id="_1-浅拷贝" tabindex="-1"><a class="header-anchor" href="#_1-浅拷贝"><span>(1)浅拷贝</span></a></h4><p><code>Object.assign</code>方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> obj1</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> {a: {b: </span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">}};</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> obj2</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> Object.</span><span style="color:#DBB7FF;">assign</span><span style="color:#F0F3F6;">({}, obj1);</span></span>
<span class="line"><span style="color:#F0F3F6;">obj1.a.b </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 2</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">obj2.a.b </span><span style="color:#BDC4CC;">// 2</span></span></code></pre></div><p>上面代码中，源对象<code>obj1</code>的<code>a</code>属性的值是一个对象，<code>Object.assign</code>拷贝得到的是这个对象的引用。这个对象的任何变化，都会反映到目标对象上面。</p><h4 id="_2-同名属性的替换" tabindex="-1"><a class="header-anchor" href="#_2-同名属性的替换"><span>(2)同名属性的替换</span></a></h4><p>对于这种嵌套的对象，一旦遇到同名属性，<code>Object.assign</code>的处理方法是替换，而不是添加。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> target</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> { a: { b: </span><span style="color:#ADDCFF;">&#39;c&#39;</span><span style="color:#F0F3F6;">, d: </span><span style="color:#ADDCFF;">&#39;e&#39;</span><span style="color:#F0F3F6;"> } }</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> source</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> { a: { b: </span><span style="color:#ADDCFF;">&#39;hello&#39;</span><span style="color:#F0F3F6;"> } }</span></span>
<span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">assign</span><span style="color:#F0F3F6;">(target, source) </span><span style="color:#BDC4CC;">// { a: { b: &#39;hello&#39; } }</span></span></code></pre></div><p>上面代码中，<code>target</code>对象的<code>a</code>属性被<code>source</code>对象的<code>a</code>属性整个替换掉了，而不会得到<code>{a:{b:&#39;hello&#39;,d:&#39;e&#39; }}</code>的结果。这通常不是开发者想要的，需要特别小心。<br> 一些函数库提供<code>Object.assign</code>的定制版本（比如Lodash的<code>_.defaultsDeep</code>方法），可以得到深拷贝的合并。</p><h4 id="_3-数组的处理" tabindex="-1"><a class="header-anchor" href="#_3-数组的处理"><span>(3)数组的处理</span></a></h4><p><code>Object.assign</code>可以用来处理数组，但是会把数组视为对象。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">assign</span><span style="color:#F0F3F6;">([</span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">3</span><span style="color:#F0F3F6;">], [</span><span style="color:#91CBFF;">4</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">5</span><span style="color:#F0F3F6;">]) </span><span style="color:#BDC4CC;">// [4, 5, 3]</span></span></code></pre></div><p>上面代码中，<code>Object.assign</code>把数组视为属性名为0、1、2的对象，因此源数组的0号属性4覆盖了目标数组的0号属性1。</p><h4 id="_4-取值函数的处理" tabindex="-1"><a class="header-anchor" href="#_4-取值函数的处理"><span>(4)取值函数的处理</span></a></h4><p><code>Object.assign</code>只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> source</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  get</span><span style="color:#DBB7FF;"> foo</span><span style="color:#F0F3F6;">() { </span><span style="color:#FF9492;">return</span><span style="color:#91CBFF;"> 1</span><span style="color:#F0F3F6;"> }</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> target</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> {};</span></span>
<span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">assign</span><span style="color:#F0F3F6;">(target, source) </span><span style="color:#BDC4CC;">// { foo: 1 }</span></span></code></pre></div><p>上面代码中，<code>source</code>对象的<code>foo</code>属性是一个取值函数，<code>Object.assign</code>不会复制这个取值函数，只会拿到值以后，将这个值复制过去。</p><h3 id="常见用途" tabindex="-1"><a class="header-anchor" href="#常见用途"><span>常见用途</span></a></h3><p><code>Object.assign</code>方法有很多用处。</p><h4 id="_1-为对象添加属性" tabindex="-1"><a class="header-anchor" href="#_1-为对象添加属性"><span>(1)为对象添加属性</span></a></h4><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Point</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  constructor</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">x</span><span style="color:#F0F3F6;">, </span><span style="color:#FFB757;">y</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#F0F3F6;">    Object.</span><span style="color:#DBB7FF;">assign</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">this</span><span style="color:#F0F3F6;">, {x, y});</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面方法通过<code>Object.assign</code>方法，将<code>x</code>属性和<code>y</code>属性添加到<code>Point</code>类的对象实例。</p><h4 id="_2-为对象添加方法" tabindex="-1"><a class="header-anchor" href="#_2-为对象添加方法"><span>(2)为对象添加方法</span></a></h4><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">assign</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">SomeClass</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">prototype</span><span style="color:#F0F3F6;">, {</span></span>
<span class="line"><span style="color:#DBB7FF;">  someMethod</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">arg1</span><span style="color:#F0F3F6;">, </span><span style="color:#FFB757;">arg2</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#F0F3F6;">    ···</span></span>
<span class="line"><span style="color:#F0F3F6;">  },</span></span>
<span class="line"><span style="color:#DBB7FF;">  anotherMethod</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#F0F3F6;">    ···</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">});</span></span>
<span class="line"><span style="color:#BDC4CC;">// 等同于下面的写法</span></span>
<span class="line"><span style="color:#91CBFF;">SomeClass</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">prototype</span><span style="color:#F0F3F6;">.</span><span style="color:#DBB7FF;">someMethod</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> function</span><span style="color:#F0F3F6;"> (</span><span style="color:#FFB757;">arg1</span><span style="color:#F0F3F6;">, </span><span style="color:#FFB757;">arg2</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#F0F3F6;">  ···</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span>
<span class="line"><span style="color:#91CBFF;">SomeClass</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">prototype</span><span style="color:#F0F3F6;">.</span><span style="color:#DBB7FF;">anotherMethod</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> function</span><span style="color:#F0F3F6;"> () {</span></span>
<span class="line"><span style="color:#F0F3F6;">  ···</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span></code></pre></div><p>上面代码使用了对象属性的简洁表示法，直接将两个函数放在大括号中，再使用<code>assign</code>方法添加到<code>SomeClass.prototype</code>之中。</p><h4 id="_3-克隆对象" tabindex="-1"><a class="header-anchor" href="#_3-克隆对象"><span>(3)克隆对象</span></a></h4><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">function</span><span style="color:#DBB7FF;"> clone</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">origin</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#FF9492;">  return</span><span style="color:#F0F3F6;"> Object.</span><span style="color:#DBB7FF;">assign</span><span style="color:#F0F3F6;">({}, origin);</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面代码将原始对象拷贝到一个空对象，就得到了原始对象的克隆。<br> 不过，采用这种方法克隆，只能克隆原始对象自身的值，不能克隆它继承的值。如果想要保持继承链，可以采用下面的代码。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">function</span><span style="color:#DBB7FF;"> clone</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">origin</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#FF9492;">  let</span><span style="color:#F0F3F6;"> originProto </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> Object.</span><span style="color:#DBB7FF;">getPrototypeOf</span><span style="color:#F0F3F6;">(origin);</span></span>
<span class="line"><span style="color:#FF9492;">  return</span><span style="color:#F0F3F6;"> Object.</span><span style="color:#DBB7FF;">assign</span><span style="color:#F0F3F6;">(Object.</span><span style="color:#DBB7FF;">create</span><span style="color:#F0F3F6;">(originProto), origin);</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><h4 id="_4-合并多个对象" tabindex="-1"><a class="header-anchor" href="#_4-合并多个对象"><span>(4)合并多个对象</span></a></h4><p>将多个对象合并到某个对象。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#DBB7FF;"> merge</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">target</span><span style="color:#F0F3F6;">, </span><span style="color:#FF9492;">...</span><span style="color:#FFB757;">sources</span><span style="color:#F0F3F6;">) </span><span style="color:#FF9492;">=&gt;</span><span style="color:#F0F3F6;"> Object.</span><span style="color:#DBB7FF;">assign</span><span style="color:#F0F3F6;">(target, </span><span style="color:#FF9492;">...</span><span style="color:#F0F3F6;">sources);</span></span></code></pre></div><p>如果希望合并后返回一个新对象，可以改写上面函数，对一个空对象合并。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#DBB7FF;"> merge</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;">(</span><span style="color:#FF9492;">...</span><span style="color:#FFB757;">sources</span><span style="color:#F0F3F6;">) </span><span style="color:#FF9492;">=&gt;</span><span style="color:#F0F3F6;"> Object.</span><span style="color:#DBB7FF;">assign</span><span style="color:#F0F3F6;">({}, </span><span style="color:#FF9492;">...</span><span style="color:#F0F3F6;">sources);</span></span></code></pre></div><h4 id="_5-为属性指定默认值" tabindex="-1"><a class="header-anchor" href="#_5-为属性指定默认值"><span>(5)为属性指定默认值</span></a></h4><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> DEFAULTS</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">  logLevel: </span><span style="color:#91CBFF;">0</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#F0F3F6;">  outputFormat: </span><span style="color:#ADDCFF;">&#39;html&#39;</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span>
<span class="line"><span style="color:#FF9492;">function</span><span style="color:#DBB7FF;"> processContent</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">options</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#F0F3F6;">  options </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> Object.</span><span style="color:#DBB7FF;">assign</span><span style="color:#F0F3F6;">({}, </span><span style="color:#91CBFF;">DEFAULTS</span><span style="color:#F0F3F6;">, options);</span></span>
<span class="line"><span style="color:#F0F3F6;">  console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(options);</span></span>
<span class="line"><span style="color:#BDC4CC;">  // ...</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面代码中，<code>DEFAULTS</code>对象是默认值，<code>options</code>对象是用户提供的参数。<code>Object.assign</code>方法将<code>DEFAULTS</code>和<code>options</code>合并成一个新对象，如果两者有同名属性，则<code>option</code>的属性值会覆盖<code>DEFAULTS</code>的属性值。<br> 注意，由于存在浅拷贝的问题，<code>DEFAULTS</code>对象和<code>options</code>对象的所有属性的值，最好都是简单类型，不要指向另一个对象。否则，<code>DEFAULTS</code>对象的该属性很可能不起作用。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> DEFAULTS</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">  url: {</span></span>
<span class="line"><span style="color:#F0F3F6;">    host: </span><span style="color:#ADDCFF;">&#39;example.com&#39;</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#F0F3F6;">    port: </span><span style="color:#91CBFF;">7070</span></span>
<span class="line"><span style="color:#F0F3F6;">  },</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span>
<span class="line"><span style="color:#DBB7FF;">processContent</span><span style="color:#F0F3F6;">({ url: {port: </span><span style="color:#91CBFF;">8000</span><span style="color:#F0F3F6;">} })</span></span>
<span class="line"><span style="color:#BDC4CC;">// {</span></span>
<span class="line"><span style="color:#BDC4CC;">//   url: {port: 8000}</span></span>
<span class="line"><span style="color:#BDC4CC;">// }</span></span></code></pre></div><p>上面代码的原意是将<code>url.port</code>改成 8000，<code>url.host</code>不变。实际结果却是<code>options.url</code>覆盖掉<code>DEFAULTS.url</code>，所以<code>url.host</code>就不存在了。</p><h2 id="属性的可枚举性和遍历" tabindex="-1"><a class="header-anchor" href="#属性的可枚举性和遍历"><span>属性的可枚举性和遍历</span></a></h2><h3 id="可枚举性" tabindex="-1"><a class="header-anchor" href="#可枚举性"><span>可枚举性</span></a></h3><p>对象的每个属性都有一个描述对象，用来控制该属性的行为。<code>Object.getOwnPropertyDescriptor</code>方法可以获取该属性的描述对象。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> obj </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> { foo: </span><span style="color:#91CBFF;">123</span><span style="color:#F0F3F6;"> };</span></span>
<span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">getOwnPropertyDescriptor</span><span style="color:#F0F3F6;">(obj, </span><span style="color:#ADDCFF;">&#39;foo&#39;</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#BDC4CC;">//  {</span></span>
<span class="line"><span style="color:#BDC4CC;">//    value: 123,</span></span>
<span class="line"><span style="color:#BDC4CC;">//    writable: true,</span></span>
<span class="line"><span style="color:#BDC4CC;">//    enumerable: true,</span></span>
<span class="line"><span style="color:#BDC4CC;">//    configurable: true</span></span>
<span class="line"><span style="color:#BDC4CC;">//  }</span></span></code></pre></div><p>描述对象的<code>enumerable</code>属性，称为”可枚举性“，如果该属性为<code>false</code>，就表示某些操作会忽略当前属性。<br> 目前，有四个操作会忽略<code>enumerable</code>为<code>false</code>的属性。</p><ul><li><code>for...in</code>循环：只遍历对象自身的和继承的可枚举的属性。</li><li><code>Object.keys()</code>：返回对象自身的所有可枚举的属性的键名。</li><li><code>JSON.stringify()</code>：只串行化对象自身的可枚举的属性。</li><li><code>Object.assign()</code>： 忽略<code>enumerable</code>为<code>false</code>的属性，只拷贝对象自身的可枚举的属性。</li></ul><p>这四个操作之中，前三个是ES5就有的，最后一个<code>Object.assign()</code>是ES6新增的。其中，只有<code>for...in</code>会返回继承的属性，其他三个方法都会忽略继承的属性，只处理对象自身的属性。实际上，引入“可枚举”这个概念的最初目的，就是让某些属性可以规避掉<code>for...in</code>操作，不然所有内部属性和方法都会被遍历到。比如，对象原型的<code>toString</code>方法，以及数组的<code>length</code>属性，就通过“可枚举性”，从而避免被<code>for...in</code>遍历到。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">getOwnPropertyDescriptor</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">Object</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">prototype</span><span style="color:#F0F3F6;">, </span><span style="color:#ADDCFF;">&#39;toString&#39;</span><span style="color:#F0F3F6;">).enumerable </span><span style="color:#BDC4CC;">// false</span></span>
<span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">getOwnPropertyDescriptor</span><span style="color:#F0F3F6;">([], </span><span style="color:#ADDCFF;">&#39;length&#39;</span><span style="color:#F0F3F6;">).enumerable </span><span style="color:#BDC4CC;">// false</span></span></code></pre></div><p>上面代码中，<code>toString</code>和<code>length</code>属性的<code>enumerable</code>都是<code>false</code>，因此<code>for...in</code>不会遍历到这两个继承自原型的属性。<br> 另外，ES6 规定，所有<code>Class</code>的原型的方法都是不可枚举的。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">getOwnPropertyDescriptor</span><span style="color:#F0F3F6;">(</span><span style="color:#FF9492;">class</span><span style="color:#F0F3F6;"> {</span><span style="color:#DBB7FF;">foo</span><span style="color:#F0F3F6;">() {}}.</span><span style="color:#91CBFF;">prototype</span><span style="color:#F0F3F6;">, </span><span style="color:#ADDCFF;">&#39;foo&#39;</span><span style="color:#F0F3F6;">).enumerable</span></span>
<span class="line"><span style="color:#BDC4CC;">// false</span></span></code></pre></div><p>总的来说，操作中引入继承的属性会让问题复杂化，大多数时候，我们只关心对象自身的属性。所以，尽量不要用<code>for...in</code>循环，而用<code>Object.keys()</code>代替。</p><h2 id="属性的遍历" tabindex="-1"><a class="header-anchor" href="#属性的遍历"><span>属性的遍历</span></a></h2><p>ES6一共有5种方法可以遍历对象的属性。</p><h3 id="_1-for-in" tabindex="-1"><a class="header-anchor" href="#_1-for-in"><span>(1)for...in</span></a></h3><p><code>for...in</code>循环遍历对象自身的和继承的可枚举属性（不含<code>Symbol</code>属性）。</p><h3 id="_2-object-keys-obj" tabindex="-1"><a class="header-anchor" href="#_2-object-keys-obj"><span>(2)Object.keys(obj)</span></a></h3><p><code>Object.keys</code>返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含<code>Symbol</code>属性）的键名。</p><h3 id="_3-object-getownpropertynames-obj" tabindex="-1"><a class="header-anchor" href="#_3-object-getownpropertynames-obj"><span>(3)Object.getOwnPropertyNames(obj)</span></a></h3><p><code>Object.getOwnPropertyNames</code>返回一个数组，包含对象自身的所有属性（不含<code>Symbol</code>属性，但是包括不可枚举属性）的键名。</p><h3 id="_4-object-getownpropertysymbols-obj" tabindex="-1"><a class="header-anchor" href="#_4-object-getownpropertysymbols-obj"><span>(4)Object.getOwnPropertySymbols(obj)</span></a></h3><p><code>Object.getOwnPropertySymbols</code>返回一个数组，包含对象自身的所有<code>Symbol</code>属性的键名。</p><h3 id="_5-reflect-ownkeys-obj" tabindex="-1"><a class="header-anchor" href="#_5-reflect-ownkeys-obj"><span>(5)Reflect.ownKeys(obj)</span></a></h3><p><code>Reflect.ownKeys</code>返回一个数组，包含对象自身的所有键名，不管键名是<code>Symbol</code>或字符串，也不管是否可枚举。<br> 以上的5种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。<br> 首先遍历所有数值键，按照数值升序排列。<br> 其次遍历所有字符串键，按照加入时间升序排列。<br> 最后遍历所有<code>Symbol</code>键，按照加入时间升序排列。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">Reflect.</span><span style="color:#DBB7FF;">ownKeys</span><span style="color:#F0F3F6;">({ [</span><span style="color:#DBB7FF;">Symbol</span><span style="color:#F0F3F6;">()]:</span><span style="color:#91CBFF;">0</span><span style="color:#F0F3F6;">, b:</span><span style="color:#91CBFF;">0</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">10</span><span style="color:#F0F3F6;">:</span><span style="color:#91CBFF;">0</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">:</span><span style="color:#91CBFF;">0</span><span style="color:#F0F3F6;">, a:</span><span style="color:#91CBFF;">0</span><span style="color:#F0F3F6;"> })</span></span>
<span class="line"><span style="color:#BDC4CC;">// [&#39;2&#39;, &#39;10&#39;, &#39;b&#39;, &#39;a&#39;, Symbol()]</span></span></code></pre></div><p>上面代码中，<code>Reflect.ownKeys</code>方法返回一个数组，包含了参数对象的所有属性。这个数组的属性次序是这样的，首先是数值属性2和10，其次是字符串属性<code>b</code>和<code>a</code>，最后是<code>Symbol</code>属性。<br> ##Object.getOwnPropertyDescriptors()<br><code>Object.getOwnPropertyDescriptor</code>方法会返回某个对象属性的描述对象。<code>Object.getOwnPropertyDescriptors</code>方法返回指定对象所有自身属性（非继承属性）的描述对象。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> obj</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">  foo: </span><span style="color:#91CBFF;">123</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#FF9492;">  get</span><span style="color:#DBB7FF;"> bar</span><span style="color:#F0F3F6;">() { </span><span style="color:#FF9492;">return</span><span style="color:#ADDCFF;"> &#39;abc&#39;</span><span style="color:#F0F3F6;"> }</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span>
<span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">getOwnPropertyDescriptors</span><span style="color:#F0F3F6;">(obj)</span></span>
<span class="line"><span style="color:#BDC4CC;">// { foo:</span></span>
<span class="line"><span style="color:#BDC4CC;">//    { value: 123,</span></span>
<span class="line"><span style="color:#BDC4CC;">//      writable: true,</span></span>
<span class="line"><span style="color:#BDC4CC;">//      enumerable: true,</span></span>
<span class="line"><span style="color:#BDC4CC;">//      configurable: true },</span></span>
<span class="line"><span style="color:#BDC4CC;">//   bar:</span></span>
<span class="line"><span style="color:#BDC4CC;">//    { get: [Function: get bar],</span></span>
<span class="line"><span style="color:#BDC4CC;">//      set: undefined,</span></span>
<span class="line"><span style="color:#BDC4CC;">//      enumerable: true,</span></span>
<span class="line"><span style="color:#BDC4CC;">//      configurable: true } }</span></span></code></pre></div><p>上面代码中，<code>Object.getOwnPropertyDescriptors</code>方法返回一个对象，所有原对象的属性名都是该对象的属性名，对应的属性值就是该属性的描述对象。<br> 该方法的实现非常容易。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">function</span><span style="color:#DBB7FF;"> getOwnPropertyDescriptors</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">obj</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#FF9492;">  const</span><span style="color:#91CBFF;"> result</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> {};</span></span>
<span class="line"><span style="color:#FF9492;">  for</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> key </span><span style="color:#FF9492;">of</span><span style="color:#F0F3F6;"> Reflect.</span><span style="color:#DBB7FF;">ownKeys</span><span style="color:#F0F3F6;">(obj)) {</span></span>
<span class="line"><span style="color:#F0F3F6;">    result[key] </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> Object.</span><span style="color:#DBB7FF;">getOwnPropertyDescriptor</span><span style="color:#F0F3F6;">(obj, key);</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#FF9492;">  return</span><span style="color:#F0F3F6;"> result;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>该方法的引入目的，主要是为了解决<code>Object.assign()</code>无法正确拷贝<code>get</code>属性和<code>set</code>属性的问题。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> source</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  set</span><span style="color:#DBB7FF;"> foo</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">value</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#F0F3F6;">    console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(value);</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> target1</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> {};</span></span>
<span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">assign</span><span style="color:#F0F3F6;">(target1, source);</span></span>
<span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">getOwnPropertyDescriptor</span><span style="color:#F0F3F6;">(target1, </span><span style="color:#ADDCFF;">&#39;foo&#39;</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#BDC4CC;">// { value: undefined,</span></span>
<span class="line"><span style="color:#BDC4CC;">//   writable: true,</span></span>
<span class="line"><span style="color:#BDC4CC;">//   enumerable: true,</span></span>
<span class="line"><span style="color:#BDC4CC;">//   configurable: true }</span></span></code></pre></div><p>上面代码中，<code>source</code>对象的<code>foo</code>属性的值是一个赋值函数，<code>Object.assign</code>方法将这个属性拷贝给<code>target1</code>对象，结果该属性的值变成了<code>undefined</code>。这是因为<code>Object.assign</code>方法总是拷贝一个属性的值，而不会拷贝它背后的赋值方法或取值方法。<br> 这时，<code>Object.getOwnPropertyDescriptors</code>方法配合<code>Object.defineProperties</code>方法，就可以实现正确拷贝。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> source</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  set</span><span style="color:#DBB7FF;"> foo</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">value</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#F0F3F6;">    console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(value);</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> target2</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> {};</span></span>
<span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">defineProperties</span><span style="color:#F0F3F6;">(target2, Object.</span><span style="color:#DBB7FF;">getOwnPropertyDescriptors</span><span style="color:#F0F3F6;">(source));</span></span>
<span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">getOwnPropertyDescriptor</span><span style="color:#F0F3F6;">(target2, </span><span style="color:#ADDCFF;">&#39;foo&#39;</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#BDC4CC;">// { get: undefined,</span></span>
<span class="line"><span style="color:#BDC4CC;">//   set: [Function: set foo],</span></span>
<span class="line"><span style="color:#BDC4CC;">//   enumerable: true,</span></span>
<span class="line"><span style="color:#BDC4CC;">//   configurable: true }</span></span></code></pre></div><p>上面代码中，两个对象合并的逻辑可以写成一个函数。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#DBB7FF;"> shallowMerge</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> (</span><span style="color:#FFB757;">target</span><span style="color:#F0F3F6;">, </span><span style="color:#FFB757;">source</span><span style="color:#F0F3F6;">) </span><span style="color:#FF9492;">=&gt;</span><span style="color:#F0F3F6;"> Object.</span><span style="color:#DBB7FF;">defineProperties</span><span style="color:#F0F3F6;">(</span></span>
<span class="line"><span style="color:#F0F3F6;">  target,</span></span>
<span class="line"><span style="color:#F0F3F6;">  Object.</span><span style="color:#DBB7FF;">getOwnPropertyDescriptors</span><span style="color:#F0F3F6;">(source)</span></span>
<span class="line"><span style="color:#F0F3F6;">);</span></span></code></pre></div><p><code>Object.getOwnPropertyDescriptors</code>方法的另一个用处，是配合<code>Object.create</code>方法，将对象属性克隆到一个新对象。这属于浅拷贝。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> clone</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> Object.</span><span style="color:#DBB7FF;">create</span><span style="color:#F0F3F6;">(Object.</span><span style="color:#DBB7FF;">getPrototypeOf</span><span style="color:#F0F3F6;">(obj),</span></span>
<span class="line"><span style="color:#F0F3F6;">  Object.</span><span style="color:#DBB7FF;">getOwnPropertyDescriptors</span><span style="color:#F0F3F6;">(obj));</span></span>
<span class="line"><span style="color:#BDC4CC;">// 或者</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#DBB7FF;"> shallowClone</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> (</span><span style="color:#FFB757;">obj</span><span style="color:#F0F3F6;">) </span><span style="color:#FF9492;">=&gt;</span><span style="color:#F0F3F6;"> Object.</span><span style="color:#DBB7FF;">create</span><span style="color:#F0F3F6;">(</span></span>
<span class="line"><span style="color:#F0F3F6;">  Object.</span><span style="color:#DBB7FF;">getPrototypeOf</span><span style="color:#F0F3F6;">(obj),</span></span>
<span class="line"><span style="color:#F0F3F6;">  Object.</span><span style="color:#DBB7FF;">getOwnPropertyDescriptors</span><span style="color:#F0F3F6;">(obj)</span></span>
<span class="line"><span style="color:#F0F3F6;">);</span></span></code></pre></div><p>上面代码会克隆对象<code>obj</code>。<br> 另外，<code>Object.getOwnPropertyDescriptors</code>方法可以实现一个对象继承另一个对象。以前，继承另一个对象，常常写成下面这样。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> obj</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">  __proto__: prot,</span></span>
<span class="line"><span style="color:#F0F3F6;">  foo: </span><span style="color:#91CBFF;">123</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span></code></pre></div><p>ES6规定<code>__proto__</code>只有浏览器要部署，其他环境不用部署。如果去除<code>__proto__</code>，上面代码就要改成下面这样。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> obj</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> Object.</span><span style="color:#DBB7FF;">create</span><span style="color:#F0F3F6;">(prot);</span></span>
<span class="line"><span style="color:#F0F3F6;">obj.foo </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 123</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#BDC4CC;">// 或者</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> obj</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> Object.</span><span style="color:#DBB7FF;">assign</span><span style="color:#F0F3F6;">(</span></span>
<span class="line"><span style="color:#F0F3F6;">  Object.</span><span style="color:#DBB7FF;">create</span><span style="color:#F0F3F6;">(prot),</span></span>
<span class="line"><span style="color:#F0F3F6;">  {</span></span>
<span class="line"><span style="color:#F0F3F6;">    foo: </span><span style="color:#91CBFF;">123</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">);</span></span></code></pre></div><p>有了<code>Object.getOwnPropertyDescriptors</code>，我们就有了另一种写法。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> obj</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> Object.</span><span style="color:#DBB7FF;">create</span><span style="color:#F0F3F6;">(</span></span>
<span class="line"><span style="color:#F0F3F6;">  prot,</span></span>
<span class="line"><span style="color:#F0F3F6;">  Object.</span><span style="color:#DBB7FF;">getOwnPropertyDescriptors</span><span style="color:#F0F3F6;">({</span></span>
<span class="line"><span style="color:#F0F3F6;">    foo: </span><span style="color:#91CBFF;">123</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#F0F3F6;">  })</span></span>
<span class="line"><span style="color:#F0F3F6;">);</span></span></code></pre></div><p><code>Object.getOwnPropertyDescriptors</code>也可以用来实现<code>Mixin</code>（混入）模式。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#DBB7FF;"> mix</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> (</span><span style="color:#FFB757;">object</span><span style="color:#F0F3F6;">) </span><span style="color:#FF9492;">=&gt;</span><span style="color:#F0F3F6;"> ({</span></span>
<span class="line"><span style="color:#DBB7FF;">  with</span><span style="color:#F0F3F6;">: (</span><span style="color:#FF9492;">...</span><span style="color:#FFB757;">mixins</span><span style="color:#F0F3F6;">) </span><span style="color:#FF9492;">=&gt;</span><span style="color:#F0F3F6;"> mixins.</span><span style="color:#DBB7FF;">reduce</span><span style="color:#F0F3F6;">(</span></span>
<span class="line"><span style="color:#F0F3F6;">    (</span><span style="color:#FFB757;">c</span><span style="color:#F0F3F6;">, </span><span style="color:#FFB757;">mixin</span><span style="color:#F0F3F6;">) </span><span style="color:#FF9492;">=&gt;</span><span style="color:#F0F3F6;"> Object.</span><span style="color:#DBB7FF;">create</span><span style="color:#F0F3F6;">(</span></span>
<span class="line"><span style="color:#F0F3F6;">      c, Object.</span><span style="color:#DBB7FF;">getOwnPropertyDescriptors</span><span style="color:#F0F3F6;">(mixin)</span></span>
<span class="line"><span style="color:#F0F3F6;">    ), object)</span></span>
<span class="line"><span style="color:#F0F3F6;">});</span></span>
<span class="line"><span style="color:#BDC4CC;">// multiple mixins example</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> a </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> {a: </span><span style="color:#ADDCFF;">&#39;a&#39;</span><span style="color:#F0F3F6;">};</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> b </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> {b: </span><span style="color:#ADDCFF;">&#39;b&#39;</span><span style="color:#F0F3F6;">};</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> c </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> {c: </span><span style="color:#ADDCFF;">&#39;c&#39;</span><span style="color:#F0F3F6;">};</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> d </span><span style="color:#FF9492;">=</span><span style="color:#DBB7FF;"> mix</span><span style="color:#F0F3F6;">(c).</span><span style="color:#DBB7FF;">with</span><span style="color:#F0F3F6;">(a, b);</span></span>
<span class="line"><span style="color:#F0F3F6;">d.c </span><span style="color:#BDC4CC;">// &quot;c&quot;</span></span>
<span class="line"><span style="color:#F0F3F6;">d.b </span><span style="color:#BDC4CC;">// &quot;b&quot;</span></span>
<span class="line"><span style="color:#F0F3F6;">d.a </span><span style="color:#BDC4CC;">// &quot;a&quot;</span></span></code></pre></div><p>上面代码返回一个新的对象<code>d</code>，代表了对象<code>a</code>和<code>b</code>被混入了对象<code>c</code>的操作。<br> 出于完整性的考虑，<code>Object.getOwnPropertyDescriptors</code>进入标准以后，以后还会新增<code>Reflect.getOwnPropertyDescriptors</code>方法。</p><h2 id="proto-属性-object-setprototypeof-object-getprototypeof" tabindex="-1"><a class="header-anchor" href="#proto-属性-object-setprototypeof-object-getprototypeof"><span>__proto__属性,Object.setPrototypeOf(),Object.getPrototypeOf()</span></a></h2><h3 id="proto-属性" tabindex="-1"><a class="header-anchor" href="#proto-属性"><span>__proto__属性</span></a></h3><p><code>__proto__</code>属性（前后各两个下划线），用来读取或设置当前对象的<code>prototype</code>对象。目前，所有浏览器都部署了这个属性。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">// es5 的写法</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> obj</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#DBB7FF;">  method</span><span style="color:#F0F3F6;">: </span><span style="color:#FF9492;">function</span><span style="color:#F0F3F6;">() { </span><span style="color:#FF9492;">...</span><span style="color:#F0F3F6;"> }</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span>
<span class="line"><span style="color:#F0F3F6;">obj.</span><span style="color:#91CBFF;">__proto__</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> someOtherObj;</span></span>
<span class="line"><span style="color:#BDC4CC;">// es6 的写法</span></span>
<span class="line"><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> obj </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> Object.</span><span style="color:#DBB7FF;">create</span><span style="color:#F0F3F6;">(someOtherObj);</span></span>
<span class="line"><span style="color:#F0F3F6;">obj.</span><span style="color:#DBB7FF;">method</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> function</span><span style="color:#F0F3F6;">() { </span><span style="color:#FF9492;">...</span><span style="color:#F0F3F6;"> };</span></span></code></pre></div><p>该属性没有写入ES6的正文，而是写入了附录，原因是<code>__proto__</code>前后的双下划线，说明它本质上是一个内部属性，而不是一个正式的对外的API，只是由于浏览器广泛支持，才被加入了ES6。标准明确规定，只有浏览器必须部署这个属性，其他运行环境不一定需要部署，而且新的代码最好认为这个属性是不存在的。因此，无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的<code>Object.setPrototypeOf()</code>（写操作）、<code>Object.getPrototypeOf()</code>（读操作）、<code>Object.create()</code>（生成操作）代替。<br> 实现上，<code>__proto__</code>调用的是<code>Object.prototype.__proto__</code>，具体实现如下。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">defineProperty</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">Object</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">prototype</span><span style="color:#F0F3F6;">, </span><span style="color:#ADDCFF;">&#39;__proto__&#39;</span><span style="color:#F0F3F6;">, {</span></span>
<span class="line"><span style="color:#DBB7FF;">  get</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#FF9492;">    let</span><span style="color:#F0F3F6;"> _thisObj </span><span style="color:#FF9492;">=</span><span style="color:#DBB7FF;"> Object</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">this</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#FF9492;">    return</span><span style="color:#F0F3F6;"> Object.</span><span style="color:#DBB7FF;">getPrototypeOf</span><span style="color:#F0F3F6;">(_thisObj);</span></span>
<span class="line"><span style="color:#F0F3F6;">  },</span></span>
<span class="line"><span style="color:#DBB7FF;">  set</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">proto</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#FF9492;">    if</span><span style="color:#F0F3F6;"> (</span><span style="color:#91CBFF;">this</span><span style="color:#FF9492;"> ===</span><span style="color:#91CBFF;"> undefined</span><span style="color:#FF9492;"> ||</span><span style="color:#91CBFF;"> this</span><span style="color:#FF9492;"> ===</span><span style="color:#91CBFF;"> null</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#FF9492;">      throw</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> TypeError</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#F0F3F6;">    }</span></span>
<span class="line"><span style="color:#FF9492;">    if</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">!</span><span style="color:#DBB7FF;">isObject</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">this</span><span style="color:#F0F3F6;">)) {</span></span>
<span class="line"><span style="color:#FF9492;">      return</span><span style="color:#91CBFF;"> undefined</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">    }</span></span>
<span class="line"><span style="color:#FF9492;">    if</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">!</span><span style="color:#DBB7FF;">isObject</span><span style="color:#F0F3F6;">(proto)) {</span></span>
<span class="line"><span style="color:#FF9492;">      return</span><span style="color:#91CBFF;"> undefined</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">    }</span></span>
<span class="line"><span style="color:#FF9492;">    let</span><span style="color:#F0F3F6;"> status </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> Reflect.</span><span style="color:#DBB7FF;">setPrototypeOf</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">this</span><span style="color:#F0F3F6;">, proto);</span></span>
<span class="line"><span style="color:#FF9492;">    if</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">!</span><span style="color:#F0F3F6;">status) {</span></span>
<span class="line"><span style="color:#FF9492;">      throw</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> TypeError</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#F0F3F6;">    }</span></span>
<span class="line"><span style="color:#F0F3F6;">  },</span></span>
<span class="line"><span style="color:#F0F3F6;">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">function</span><span style="color:#DBB7FF;"> isObject</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">value</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#FF9492;">  return</span><span style="color:#DBB7FF;"> Object</span><span style="color:#F0F3F6;">(value) </span><span style="color:#FF9492;">===</span><span style="color:#F0F3F6;"> value;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>如果一个对象本身部署了<code>__proto__</code>属性，该属性的值就是对象的原型。</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>Object.getPrototypeOf({ __proto__: null }) // null</span></span></code></pre></div><h3 id="object-setprototypeof" tabindex="-1"><a class="header-anchor" href="#object-setprototypeof"><span>Object.setPrototypeOf()</span></a></h3><p><code>Object.setPrototypeOf</code>方法的作用与<code>__proto__</code>相同，用来设置一个对象的<code>prototype</code>对象，返回参数对象本身。它是ES6正式推荐的设置原型对象的方法。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">// 格式</span></span>
<span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">setPrototypeOf</span><span style="color:#F0F3F6;">(object, prototype)</span></span>
<span class="line"><span style="color:#BDC4CC;">// 用法</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> o</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> Object.</span><span style="color:#DBB7FF;">setPrototypeOf</span><span style="color:#F0F3F6;">({}, </span><span style="color:#91CBFF;">null</span><span style="color:#F0F3F6;">);</span></span></code></pre></div><p>该方法等同于下面的函数。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">function</span><span style="color:#F0F3F6;"> (</span><span style="color:#FFB757;">obj</span><span style="color:#F0F3F6;">, </span><span style="color:#FFB757;">proto</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#F0F3F6;">  obj.</span><span style="color:#91CBFF;">__proto__</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> proto;</span></span>
<span class="line"><span style="color:#FF9492;">  return</span><span style="color:#F0F3F6;"> obj;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>下面是一个例子。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> proto </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> {};</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> obj </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> { x: </span><span style="color:#91CBFF;">10</span><span style="color:#F0F3F6;"> };</span></span>
<span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">setPrototypeOf</span><span style="color:#F0F3F6;">(obj, proto);</span></span>
<span class="line"><span style="color:#F0F3F6;">proto.y </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 20</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">proto.z </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 40</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">obj.x </span><span style="color:#BDC4CC;">// 10</span></span>
<span class="line"><span style="color:#F0F3F6;">obj.y </span><span style="color:#BDC4CC;">// 20</span></span>
<span class="line"><span style="color:#F0F3F6;">obj.z </span><span style="color:#BDC4CC;">// 40</span></span></code></pre></div><p>上面代码将<code>proto</code>对象设为<code>obj</code>对象的原型，所以从<code>obj</code>对象可以读取<code>proto</code>对象的属性。<br> 如果第一个参数不是对象，会自动转为对象。但是由于返回的还是第一个参数，所以这个操作不会产生任何效果。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">setPrototypeOf</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">, {}) </span><span style="color:#FF9492;">===</span><span style="color:#91CBFF;"> 1</span><span style="color:#BDC4CC;"> // true</span></span>
<span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">setPrototypeOf</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;foo&#39;</span><span style="color:#F0F3F6;">, {}) </span><span style="color:#FF9492;">===</span><span style="color:#ADDCFF;"> &#39;foo&#39;</span><span style="color:#BDC4CC;"> // true</span></span>
<span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">setPrototypeOf</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">true</span><span style="color:#F0F3F6;">, {}) </span><span style="color:#FF9492;">===</span><span style="color:#91CBFF;"> true</span><span style="color:#BDC4CC;"> // true</span></span></code></pre></div><p>由于<code>undefined</code>和<code>null</code>无法转为对象，所以如果第一个参数是<code>undefined</code>或<code>null</code>，就会报错。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">setPrototypeOf</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">undefined</span><span style="color:#F0F3F6;">, {})</span></span>
<span class="line"><span style="color:#BDC4CC;">// TypeError: Object.setPrototypeOf called on null or undefined</span></span>
<span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">setPrototypeOf</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">null</span><span style="color:#F0F3F6;">, {})</span></span>
<span class="line"><span style="color:#BDC4CC;">// TypeError: Object.setPrototypeOf called on null or undefined</span></span></code></pre></div><h3 id="object-getprototypeof" tabindex="-1"><a class="header-anchor" href="#object-getprototypeof"><span>Object.getPrototypeOf()</span></a></h3><p>该方法与<code>Object.setPrototypeOf</code>方法配套，用于读取一个对象的原型对象。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">function</span><span style="color:#DBB7FF;"> Rectangle</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#BDC4CC;">  // ...</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> rec</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> Rectangle</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">getPrototypeOf</span><span style="color:#F0F3F6;">(rec) </span><span style="color:#FF9492;">===</span><span style="color:#91CBFF;"> Rectangle</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">prototype</span><span style="color:#BDC4CC;"> // true</span></span>
<span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">setPrototypeOf</span><span style="color:#F0F3F6;">(rec, </span><span style="color:#91CBFF;">Object</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">prototype</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">getPrototypeOf</span><span style="color:#F0F3F6;">(rec) </span><span style="color:#FF9492;">===</span><span style="color:#91CBFF;"> Rectangle</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">prototype</span><span style="color:#BDC4CC;"> // false</span></span></code></pre></div><p>如果参数不是对象，会被自动转为对象。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">// 等同于 Object.getPrototypeOf(Number(1))</span></span>
<span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">getPrototypeOf</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#BDC4CC;">// Number {[[PrimitiveValue]]: 0}</span></span>
<span class="line"><span style="color:#BDC4CC;">// 等同于 Object.getPrototypeOf(String(&#39;foo&#39;))</span></span>
<span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">getPrototypeOf</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;foo&#39;</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#BDC4CC;">// String {length: 0, [[PrimitiveValue]]: &quot;&quot;}</span></span>
<span class="line"><span style="color:#BDC4CC;">// 等同于 Object.getPrototypeOf(Boolean(true))</span></span>
<span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">getPrototypeOf</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">true</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#BDC4CC;">// Boolean {[[PrimitiveValue]]: false}</span></span>
<span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">getPrototypeOf</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">) </span><span style="color:#FF9492;">===</span><span style="color:#91CBFF;"> Number</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">prototype</span><span style="color:#BDC4CC;"> // true</span></span>
<span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">getPrototypeOf</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;foo&#39;</span><span style="color:#F0F3F6;">) </span><span style="color:#FF9492;">===</span><span style="color:#91CBFF;"> String</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">prototype</span><span style="color:#BDC4CC;"> // true</span></span>
<span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">getPrototypeOf</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">true</span><span style="color:#F0F3F6;">) </span><span style="color:#FF9492;">===</span><span style="color:#91CBFF;"> Boolean</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">prototype</span><span style="color:#BDC4CC;"> // true</span></span></code></pre></div><p>如果参数是<code>undefined</code>或<code>null</code>，它们无法转为对象，所以会报错。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">getPrototypeOf</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">null</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#BDC4CC;">// TypeError: Cannot convert undefined or null to object</span></span>
<span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">getPrototypeOf</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">undefined</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#BDC4CC;">// TypeError: Cannot convert undefined or null to object</span></span></code></pre></div><h2 id="super关键字" tabindex="-1"><a class="header-anchor" href="#super关键字"><span>super关键字</span></a></h2><p>我们知道，<code>this</code>关键字总是指向函数所在的当前对象，ES6又新增了另一个类似的关键字<code>super</code>，指向当前对象的原型对象。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> proto</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">  foo: </span><span style="color:#ADDCFF;">&#39;hello&#39;</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> obj</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">  foo: </span><span style="color:#ADDCFF;">&#39;world&#39;</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#DBB7FF;">  find</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#FF9492;">    return</span><span style="color:#91CBFF;"> super</span><span style="color:#F0F3F6;">.foo;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span>
<span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">setPrototypeOf</span><span style="color:#F0F3F6;">(obj, proto);</span></span>
<span class="line"><span style="color:#F0F3F6;">obj.</span><span style="color:#DBB7FF;">find</span><span style="color:#F0F3F6;">() </span><span style="color:#BDC4CC;">// &quot;hello&quot;</span></span></code></pre></div><p>上面代码中，对象<code>obj</code>的<code>find</code>方法之中，通过<code>super.foo</code>引用了原型对象<code>proto</code>的<code>foo</code>属性。<br> 注意，<code>super</code>关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">// 报错</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> obj</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">  foo: </span><span style="color:#91CBFF;">super</span><span style="color:#F0F3F6;">.foo</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#BDC4CC;">// 报错</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> obj</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#DBB7FF;">  foo</span><span style="color:#F0F3F6;">: () </span><span style="color:#FF9492;">=&gt;</span><span style="color:#91CBFF;"> super</span><span style="color:#F0F3F6;">.foo</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#BDC4CC;">// 报错</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> obj</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#DBB7FF;">  foo</span><span style="color:#F0F3F6;">: </span><span style="color:#FF9492;">function</span><span style="color:#F0F3F6;"> () {</span></span>
<span class="line"><span style="color:#FF9492;">    return</span><span style="color:#91CBFF;"> super</span><span style="color:#F0F3F6;">.foo</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面三种<code>super</code>的用法都会报错，因为对于JS引擎来说，这里的<code>super</code>都没有用在对象的方法之中。第一种写法是<code>super</code>用在属性里面，第二种和第三种写法是<code>super</code>用在一个函数里面，然后赋值给<code>foo</code>属性。目前，只有对象方法的简写法可以让JS引擎确认，定义的是对象的方法。<br> JavaScript引擎内部，<code>super.foo</code>等同于<code>Object.getPrototypeOf(this).foo</code>（属性）或<code>Object.getPrototypeOf(this).foo.call(this)</code>（方法）。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> proto</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">  x: </span><span style="color:#ADDCFF;">&#39;hello&#39;</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#DBB7FF;">  foo</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#F0F3F6;">    console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">this</span><span style="color:#F0F3F6;">.x);</span></span>
<span class="line"><span style="color:#F0F3F6;">  },</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> obj</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">  x: </span><span style="color:#ADDCFF;">&#39;world&#39;</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#DBB7FF;">  foo</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#91CBFF;">    super</span><span style="color:#F0F3F6;">.</span><span style="color:#DBB7FF;">foo</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">setPrototypeOf</span><span style="color:#F0F3F6;">(obj, proto);</span></span>
<span class="line"><span style="color:#F0F3F6;">obj.</span><span style="color:#DBB7FF;">foo</span><span style="color:#F0F3F6;">() </span><span style="color:#BDC4CC;">// &quot;world&quot;</span></span></code></pre></div><p>上面代码中，<code>super.foo</code>指向原型对象<code>proto</code>的<code>foo</code>方法，但是绑定的<code>this</code>却还是当前对象<code>obj</code>，因此输出的就是<code>world</code>。</p><h2 id="object-keys-object-values-object-entries" tabindex="-1"><a class="header-anchor" href="#object-keys-object-values-object-entries"><span>Object.keys(),Object.values(),Object.entries()</span></a></h2><h3 id="object-keys" tabindex="-1"><a class="header-anchor" href="#object-keys"><span>Object.keys()</span></a></h3><p><code>Object.keys()</code>方法返回一个数组，成员是参数对象自身的(不含继承的)所有可遍历属性的键名。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> obj </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> { foo: </span><span style="color:#ADDCFF;">&#39;bar&#39;</span><span style="color:#F0F3F6;">, baz: </span><span style="color:#91CBFF;">42</span><span style="color:#F0F3F6;"> };</span></span>
<span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">keys</span><span style="color:#F0F3F6;">(obj) </span><span style="color:#BDC4CC;">// [&quot;foo&quot;, &quot;baz&quot;]</span></span></code></pre></div><p>ES2017引入了跟<code>Object.keys</code>配套的<code>Object.values</code>和<code>Object.entries</code>，作为遍历一个对象的补充手段，供<code>for...of</code>循环使用。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> {keys, values, entries} </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> Object;</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> obj </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> { a: </span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">, b: </span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">, c: </span><span style="color:#91CBFF;">3</span><span style="color:#F0F3F6;"> };</span></span>
<span class="line"><span style="color:#FF9492;">for</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> key </span><span style="color:#FF9492;">of</span><span style="color:#DBB7FF;"> keys</span><span style="color:#F0F3F6;">(obj)) {</span></span>
<span class="line"><span style="color:#F0F3F6;">  console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(key); </span><span style="color:#BDC4CC;">// &#39;a&#39;, &#39;b&#39;, &#39;c&#39;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#FF9492;">for</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> value </span><span style="color:#FF9492;">of</span><span style="color:#DBB7FF;"> values</span><span style="color:#F0F3F6;">(obj)) {</span></span>
<span class="line"><span style="color:#F0F3F6;">  console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(value); </span><span style="color:#BDC4CC;">// 1, 2, 3</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#FF9492;">for</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> [key, value] </span><span style="color:#FF9492;">of</span><span style="color:#DBB7FF;"> entries</span><span style="color:#F0F3F6;">(obj)) {</span></span>
<span class="line"><span style="color:#F0F3F6;">  console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">([key, value]); </span><span style="color:#BDC4CC;">// [&#39;a&#39;, 1], [&#39;b&#39;, 2], [&#39;c&#39;, 3]</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><h3 id="object-values" tabindex="-1"><a class="header-anchor" href="#object-values"><span>Object.values()</span></a></h3><p><code>Object.values</code>方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历属性的键值。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> obj</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> { foo: </span><span style="color:#ADDCFF;">&#39;bar&#39;</span><span style="color:#F0F3F6;">, baz: </span><span style="color:#91CBFF;">42</span><span style="color:#F0F3F6;"> };</span></span>
<span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">values</span><span style="color:#F0F3F6;">(obj)</span><span style="color:#BDC4CC;">// [&quot;bar&quot;, 42]</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> obj</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> { </span><span style="color:#91CBFF;">100</span><span style="color:#F0F3F6;">: </span><span style="color:#ADDCFF;">&#39;a&#39;</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">: </span><span style="color:#ADDCFF;">&#39;b&#39;</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">7</span><span style="color:#F0F3F6;">: </span><span style="color:#ADDCFF;">&#39;c&#39;</span><span style="color:#F0F3F6;"> };</span></span>
<span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">values</span><span style="color:#F0F3F6;">(obj) </span><span style="color:#BDC4CC;">// [&quot;b&quot;, &quot;c&quot;, &quot;a&quot;]</span></span></code></pre></div><p>上面代码中，属性名为数值的属性，是按照数值大小，从小到大遍历的，因此返回的顺序是<code>b、c、a</code>。<br><code>Object.values</code>只返回对象自身的可遍历属性。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> obj</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> Object.</span><span style="color:#DBB7FF;">create</span><span style="color:#F0F3F6;">({}, {p: {value: </span><span style="color:#91CBFF;">42</span><span style="color:#F0F3F6;">}});</span></span>
<span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">values</span><span style="color:#F0F3F6;">(obj) </span><span style="color:#BDC4CC;">// []</span></span></code></pre></div><p>上面代码中，<code>Object.create</code>方法的第二个参数添加的对象属性（属性<code>p</code>），如果不显式声明，默认是不可遍历的，因为<code>p</code>的属性描述对象的<code>enumerable</code>默认是<code>false</code>，<code>Object.values</code>不会返回这个属性。只要把<code>enumerable</code>改成<code>true</code>，<code>Object.values</code>就会返回属性<code>p</code>的值。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> obj</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> Object.</span><span style="color:#DBB7FF;">create</span><span style="color:#F0F3F6;">({}, {p:</span></span>
<span class="line"><span style="color:#F0F3F6;">  {</span></span>
<span class="line"><span style="color:#F0F3F6;">    value: </span><span style="color:#91CBFF;">42</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#F0F3F6;">    enumerable: </span><span style="color:#91CBFF;">true</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">});</span></span>
<span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">values</span><span style="color:#F0F3F6;">(obj) </span><span style="color:#BDC4CC;">// [42]</span></span></code></pre></div><p><code>Object.values</code>会过滤属性名为<code>Symbol</code>值的属性。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">values</span><span style="color:#F0F3F6;">({ [</span><span style="color:#DBB7FF;">Symbol</span><span style="color:#F0F3F6;">()]: </span><span style="color:#91CBFF;">123</span><span style="color:#F0F3F6;">, foo: </span><span style="color:#ADDCFF;">&#39;abc&#39;</span><span style="color:#F0F3F6;"> }); </span><span style="color:#BDC4CC;">// [&#39;abc&#39;]</span></span></code></pre></div><p>如果<code>Object.values</code>方法的参数是一个字符串，会返回各个字符组成的一个数组。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">values</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;foo&#39;</span><span style="color:#F0F3F6;">) </span><span style="color:#BDC4CC;">// [&#39;f&#39;, &#39;o&#39;, &#39;o&#39;]</span></span></code></pre></div><p>上面代码中，字符串会先转成一个类似数组的对象。字符串的每个字符，就是该对象的一个属性。因此，<code>Object.values</code>返回每个属性的键值，就是各个字符组成的一个数组。<br> 如果参数不是对象，<code>Object.values</code>会先将其转为对象。由于数值和布尔值的包装对象，都不会为实例添加非继承的属性。所以，<code>Object.values</code>会返回空数组。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">values</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">42</span><span style="color:#F0F3F6;">) </span><span style="color:#BDC4CC;">// []</span></span>
<span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">values</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">true</span><span style="color:#F0F3F6;">) </span><span style="color:#BDC4CC;">// []</span></span></code></pre></div><h3 id="object-entries" tabindex="-1"><a class="header-anchor" href="#object-entries"><span>Object.entries</span></a></h3><p><code>Object.entries</code>方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历属性的键值对数组。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> obj</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> { foo: </span><span style="color:#ADDCFF;">&#39;bar&#39;</span><span style="color:#F0F3F6;">, baz: </span><span style="color:#91CBFF;">42</span><span style="color:#F0F3F6;"> };</span></span>
<span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">entries</span><span style="color:#F0F3F6;">(obj) </span><span style="color:#BDC4CC;">// [ [&quot;foo&quot;, &quot;bar&quot;], [&quot;baz&quot;, 42] ]</span></span></code></pre></div><p>除了返回值不一样，该方法的行为与<code>Object.values</code>基本一致。<br> 如果原对象的属性名是一个<code>Symbol</code>值，该属性会被忽略。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">entries</span><span style="color:#F0F3F6;">({[</span><span style="color:#DBB7FF;">Symbol</span><span style="color:#F0F3F6;">()]:</span><span style="color:#91CBFF;">123</span><span style="color:#F0F3F6;">,foo:</span><span style="color:#ADDCFF;">&#39;abc&#39;</span><span style="color:#F0F3F6;">}); </span><span style="color:#BDC4CC;">// [[&#39;foo&#39;,&#39;abc&#39;]]</span></span></code></pre></div><p><code>Object.entries</code>的基本用途是遍历对象的属性。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> obj </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> { one: </span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">, two: </span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;"> };</span></span>
<span class="line"><span style="color:#FF9492;">for</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> [k, v] </span><span style="color:#FF9492;">of</span><span style="color:#F0F3F6;"> Object.</span><span style="color:#DBB7FF;">entries</span><span style="color:#F0F3F6;">(obj)) {</span></span>
<span class="line"><span style="color:#F0F3F6;">  console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(</span></span>
<span class="line"><span style="color:#ADDCFF;">    \`\${</span><span style="color:#91CBFF;">JSON</span><span style="color:#ADDCFF;">.</span><span style="color:#DBB7FF;">stringify</span><span style="color:#ADDCFF;">(</span><span style="color:#F0F3F6;">k</span><span style="color:#ADDCFF;">)</span><span style="color:#ADDCFF;">}: \${</span><span style="color:#91CBFF;">JSON</span><span style="color:#ADDCFF;">.</span><span style="color:#DBB7FF;">stringify</span><span style="color:#ADDCFF;">(</span><span style="color:#F0F3F6;">v</span><span style="color:#ADDCFF;">)</span><span style="color:#ADDCFF;">}\`</span></span>
<span class="line"><span style="color:#F0F3F6;">  );</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#BDC4CC;">// &quot;one&quot;: 1</span></span>
<span class="line"><span style="color:#BDC4CC;">// &quot;two&quot;: 2</span></span></code></pre></div><p><code>Object.entries</code>方法的另一个用处是，将对象转为真正的<code>Map</code>结构。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> obj</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> { foo: </span><span style="color:#ADDCFF;">&#39;bar&#39;</span><span style="color:#F0F3F6;">, baz: </span><span style="color:#91CBFF;">42</span><span style="color:#F0F3F6;"> };</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> map</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> Map</span><span style="color:#F0F3F6;">(Object.</span><span style="color:#DBB7FF;">entries</span><span style="color:#F0F3F6;">(obj));</span></span>
<span class="line"><span style="color:#F0F3F6;">map </span><span style="color:#BDC4CC;">// Map { foo: &quot;bar&quot;, baz: 42 }</span></span></code></pre></div><p>实现<code>Object.entries</code>方法，非常简单。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">// Generator函数的版本</span></span>
<span class="line"><span style="color:#FF9492;">function*</span><span style="color:#DBB7FF;"> entries</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">obj</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#FF9492;">  for</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> key </span><span style="color:#FF9492;">of</span><span style="color:#F0F3F6;"> Object.</span><span style="color:#DBB7FF;">keys</span><span style="color:#F0F3F6;">(obj)) {</span></span>
<span class="line"><span style="color:#FF9492;">    yield</span><span style="color:#F0F3F6;"> [key, obj[key]];</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#BDC4CC;">// 非Generator函数的版本</span></span>
<span class="line"><span style="color:#FF9492;">function</span><span style="color:#DBB7FF;"> entries</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">obj</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#FF9492;">  let</span><span style="color:#F0F3F6;"> arr </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [];</span></span>
<span class="line"><span style="color:#FF9492;">  for</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> key </span><span style="color:#FF9492;">of</span><span style="color:#F0F3F6;"> Object.</span><span style="color:#DBB7FF;">keys</span><span style="color:#F0F3F6;">(obj)) {</span></span>
<span class="line"><span style="color:#F0F3F6;">    arr.</span><span style="color:#DBB7FF;">push</span><span style="color:#F0F3F6;">([key, obj[key]]);</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#FF9492;">  return</span><span style="color:#F0F3F6;"> arr;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><h2 id="对象的扩展运算符" tabindex="-1"><a class="header-anchor" href="#对象的扩展运算符"><span>对象的扩展运算符</span></a></h2><p>ES2018将这个运算符引入了对象。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#F0F3F6;"> [</span><span style="color:#91CBFF;">a</span><span style="color:#F0F3F6;">, </span><span style="color:#FF9492;">...</span><span style="color:#91CBFF;">b</span><span style="color:#F0F3F6;">] </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [</span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">3</span><span style="color:#F0F3F6;">];</span></span>
<span class="line"><span style="color:#F0F3F6;">a </span><span style="color:#BDC4CC;">// 1</span></span>
<span class="line"><span style="color:#F0F3F6;">b </span><span style="color:#BDC4CC;">// [2, 3]</span></span></code></pre></div><h3 id="解构赋值" tabindex="-1"><a class="header-anchor" href="#解构赋值"><span>解构赋值</span></a></h3><p>对象的解构赋值用于从一个对象取值，相当于将目标对象自身的所有可遍历的（<code>enumerable</code>）、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> { x, y, </span><span style="color:#FF9492;">...</span><span style="color:#F0F3F6;">z } </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> { x: </span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">, y: </span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">, a: </span><span style="color:#91CBFF;">3</span><span style="color:#F0F3F6;">, b: </span><span style="color:#91CBFF;">4</span><span style="color:#F0F3F6;"> };</span></span>
<span class="line"><span style="color:#F0F3F6;">x </span><span style="color:#BDC4CC;">// 1</span></span>
<span class="line"><span style="color:#F0F3F6;">y </span><span style="color:#BDC4CC;">// 2</span></span>
<span class="line"><span style="color:#F0F3F6;">z </span><span style="color:#BDC4CC;">// { a: 3, b: 4 }</span></span></code></pre></div><p>上面代码中，变量<code>z</code>是解构赋值所在的对象。它获取等号右边的所有尚未读取的键（<code>a</code>和<code>b</code>），将它们连同值一起拷贝过来。<br> 由于解构赋值要求等号右边是一个对象，所以如果等号右边是<code>undefined</code>或<code>null</code>，就会报错，因为它们无法转为对象。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> { x, y, </span><span style="color:#FF9492;">...</span><span style="color:#F0F3F6;">z } </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> null</span><span style="color:#F0F3F6;">; </span><span style="color:#BDC4CC;">// 运行时错误</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> { x, y, </span><span style="color:#FF9492;">...</span><span style="color:#F0F3F6;">z } </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> undefined</span><span style="color:#F0F3F6;">; </span><span style="color:#BDC4CC;">// 运行时错误</span></span></code></pre></div><p>解构赋值必须是最后一个参数，否则会报错。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> { </span><span style="color:#FF9492;">...</span><span style="color:#F0F3F6;">x, y, z } </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> obj; </span><span style="color:#BDC4CC;">// 句法错误</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> { x, </span><span style="color:#FF9492;">...</span><span style="color:#F0F3F6;">y, </span><span style="color:#FF9492;">...</span><span style="color:#F0F3F6;">z } </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> obj; </span><span style="color:#BDC4CC;">// 句法错误</span></span></code></pre></div><p>上面代码中，解构赋值不是最后一个参数，所以会报错。<br> 注意，解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> obj </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> { a: { b: </span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;"> } };</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> { </span><span style="color:#FF9492;">...</span><span style="color:#F0F3F6;">x } </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> obj;</span></span>
<span class="line"><span style="color:#F0F3F6;">obj.a.b </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 2</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">x.a.b </span><span style="color:#BDC4CC;">// 2</span></span></code></pre></div><p>上面代码中，<code>x</code>是解构赋值所在的对象，拷贝了对象<code>obj</code>的<code>a</code>属性。<code>a</code>属性引用了一个对象，修改这个对象的值，会影响到解构赋值对它的引用。<br> 另外，扩展运算符的解构赋值，不能复制继承自原型对象的属性。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> o1 </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> { a: </span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;"> };</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> o2 </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> { b: </span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;"> };</span></span>
<span class="line"><span style="color:#F0F3F6;">o2.</span><span style="color:#91CBFF;">__proto__</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> o1;</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> { </span><span style="color:#FF9492;">...</span><span style="color:#F0F3F6;">o3 } </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> o2;</span></span>
<span class="line"><span style="color:#F0F3F6;">o3 </span><span style="color:#BDC4CC;">// { b: 2 }</span></span>
<span class="line"><span style="color:#F0F3F6;">o3.a </span><span style="color:#BDC4CC;">// undefined</span></span></code></pre></div><p>上面代码中，对象<code>o3</code>复制了<code>o2</code>，但是只复制了<code>o2</code>自身的属性，没有复制它的原型对象<code>o1</code>的属性。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> o</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> Object.</span><span style="color:#DBB7FF;">create</span><span style="color:#F0F3F6;">({ x: </span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">, y: </span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;"> });</span></span>
<span class="line"><span style="color:#F0F3F6;">o.z </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 3</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> { x, </span><span style="color:#FF9492;">...</span><span style="color:#F0F3F6;">newObj } </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> o;</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> { y, z } </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> newObj;</span></span>
<span class="line"><span style="color:#F0F3F6;">x </span><span style="color:#BDC4CC;">// 1</span></span>
<span class="line"><span style="color:#F0F3F6;">y </span><span style="color:#BDC4CC;">// undefined</span></span>
<span class="line"><span style="color:#F0F3F6;">z </span><span style="color:#BDC4CC;">// 3</span></span></code></pre></div><p>上面代码中，变量<code>x</code>是单纯的解构赋值，所以可以读取对象<code>o</code>继承的属性；变量<code>y</code>和<code>z</code>是扩展运算符的解构赋值，只能读取对象<code>o</code>自身的属性，所以变量<code>z</code>可以赋值成功，变量<code>y</code>取不到值。ES6规定，变量声明语句之中，如果使用解构赋值，扩展运算符后面必须是一个变量名，而不能是一个解构赋值表达式，所以上面代码引入了中间变量<code>newObj</code>，如果写成下面这样会报错。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> { x, </span><span style="color:#FF9492;">...</span><span style="color:#F0F3F6;">{ y, z } } </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> o;</span></span>
<span class="line"><span style="color:#BDC4CC;">// SyntaxError: ... must be followed by an identifier in declaration contexts</span></span></code></pre></div><p>解构赋值的一个用处，是扩展某个函数的参数，引入其他操作。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">function</span><span style="color:#DBB7FF;"> baseFunction</span><span style="color:#F0F3F6;">({ </span><span style="color:#FFB757;">a</span><span style="color:#F0F3F6;">, </span><span style="color:#FFB757;">b</span><span style="color:#F0F3F6;"> }) {</span></span>
<span class="line"><span style="color:#BDC4CC;">  // ...</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#FF9492;">function</span><span style="color:#DBB7FF;"> wrapperFunction</span><span style="color:#F0F3F6;">({ </span><span style="color:#FFB757;">x</span><span style="color:#F0F3F6;">, </span><span style="color:#FFB757;">y</span><span style="color:#F0F3F6;">, </span><span style="color:#FF9492;">...</span><span style="color:#FFB757;">restConfig</span><span style="color:#F0F3F6;"> }) {</span></span>
<span class="line"><span style="color:#BDC4CC;">  // 使用x和y参数进行操作</span></span>
<span class="line"><span style="color:#BDC4CC;">  // 其余参数传给原始函数</span></span>
<span class="line"><span style="color:#FF9492;">  return</span><span style="color:#DBB7FF;"> baseFunction</span><span style="color:#F0F3F6;">(restConfig);</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面代码中，原始函数<code>baseFunction</code>接受<code>a</code>和<code>b</code>作为参数，函数<code>wrapperFunction</code>在<code>baseFunction</code>的基础上进行了扩展，能够接受多余的参数，并且保留原始函数的行为。</p><h3 id="扩展运算符" tabindex="-1"><a class="header-anchor" href="#扩展运算符"><span>扩展运算符</span></a></h3><p>对象的扩展运算符(<code>...</code>)用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> z </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> { a: </span><span style="color:#91CBFF;">3</span><span style="color:#F0F3F6;">, b: </span><span style="color:#91CBFF;">4</span><span style="color:#F0F3F6;"> };</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> n </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> { </span><span style="color:#FF9492;">...</span><span style="color:#F0F3F6;">z };</span></span>
<span class="line"><span style="color:#F0F3F6;">n </span><span style="color:#BDC4CC;">// { a: 3, b: 4 }</span></span></code></pre></div><p>这等同于使用<code>Object.assign</code>方法。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> aClone </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> { </span><span style="color:#FF9492;">...</span><span style="color:#F0F3F6;">a };</span></span>
<span class="line"><span style="color:#BDC4CC;">// 等同于</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> aClone </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> Object.</span><span style="color:#DBB7FF;">assign</span><span style="color:#F0F3F6;">({}, a);</span></span></code></pre></div><p>上面的例子只是拷贝了对象实例的属性，如果想完整克隆一个对象，还拷贝对象原型的属性，可以采用下面的写法。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">// 写法一</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> clone1</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">  __proto__: Object.</span><span style="color:#DBB7FF;">getPrototypeOf</span><span style="color:#F0F3F6;">(obj),</span></span>
<span class="line"><span style="color:#FF9492;">  ...</span><span style="color:#F0F3F6;">obj</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span>
<span class="line"><span style="color:#BDC4CC;">// 写法二</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> clone2</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> Object.</span><span style="color:#DBB7FF;">assign</span><span style="color:#F0F3F6;">(</span></span>
<span class="line"><span style="color:#F0F3F6;">  Object.</span><span style="color:#DBB7FF;">create</span><span style="color:#F0F3F6;">(Object.</span><span style="color:#DBB7FF;">getPrototypeOf</span><span style="color:#F0F3F6;">(obj)),</span></span>
<span class="line"><span style="color:#F0F3F6;">  obj</span></span>
<span class="line"><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#BDC4CC;">// 写法三</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> clone3</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> Object.</span><span style="color:#DBB7FF;">create</span><span style="color:#F0F3F6;">(</span></span>
<span class="line"><span style="color:#F0F3F6;">  Object.</span><span style="color:#DBB7FF;">getPrototypeOf</span><span style="color:#F0F3F6;">(obj),</span></span>
<span class="line"><span style="color:#F0F3F6;">  Object.</span><span style="color:#DBB7FF;">getOwnPropertyDescriptors</span><span style="color:#F0F3F6;">(obj)</span></span>
<span class="line"><span style="color:#F0F3F6;">)</span></span></code></pre></div><p>上面代码中，写法一的<code>__proto__</code>属性在非浏览器的环境不一定部署，因此推荐使用写法二和写法三。<br> 扩展运算符可以用于合并两个对象。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> ab </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> { </span><span style="color:#FF9492;">...</span><span style="color:#F0F3F6;">a, </span><span style="color:#FF9492;">...</span><span style="color:#F0F3F6;">b };</span></span>
<span class="line"><span style="color:#BDC4CC;">// 等同于</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> ab </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> Object.</span><span style="color:#DBB7FF;">assign</span><span style="color:#F0F3F6;">({}, a, b);</span></span></code></pre></div><p>如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> aWithOverrides </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> { </span><span style="color:#FF9492;">...</span><span style="color:#F0F3F6;">a, x: </span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">, y: </span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;"> };</span></span>
<span class="line"><span style="color:#BDC4CC;">// 等同于</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> aWithOverrides </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> { </span><span style="color:#FF9492;">...</span><span style="color:#F0F3F6;">a, </span><span style="color:#FF9492;">...</span><span style="color:#F0F3F6;">{ x: </span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">, y: </span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;"> } };</span></span>
<span class="line"><span style="color:#BDC4CC;">// 等同于</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> x </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 1</span><span style="color:#F0F3F6;">, y </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 2</span><span style="color:#F0F3F6;">, aWithOverrides </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> { </span><span style="color:#FF9492;">...</span><span style="color:#F0F3F6;">a, x, y };</span></span>
<span class="line"><span style="color:#BDC4CC;">// 等同于</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> aWithOverrides </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> Object.</span><span style="color:#DBB7FF;">assign</span><span style="color:#F0F3F6;">({}, a, { x: </span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">, y: </span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;"> });</span></span></code></pre></div><p>上面代码中，<code>a</code>对象的<code>x</code>属性和<code>y</code>属性，拷贝到新对象后会被覆盖掉。<br> 这用来修改现有对象部分的属性就很方便了。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> newVersion </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  ...</span><span style="color:#F0F3F6;">previousVersion,</span></span>
<span class="line"><span style="color:#F0F3F6;">  name: </span><span style="color:#ADDCFF;">&#39;New Name&#39;</span><span style="color:#BDC4CC;"> // Override the name property</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span></code></pre></div><p>上面代码中，<code>newVersion</code>对象自定义了<code>name</code>属性，其他属性全部复制自<code>previousVersion</code>对象。<br> 如果把自定义属性放在扩展运算符前面，就变成了设置新对象的默认属性值。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> aWithDefaults </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> { x: </span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">, y: </span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">, </span><span style="color:#FF9492;">...</span><span style="color:#F0F3F6;">a };</span></span>
<span class="line"><span style="color:#BDC4CC;">// 等同于</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> aWithDefaults </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> Object.</span><span style="color:#DBB7FF;">assign</span><span style="color:#F0F3F6;">({}, { x: </span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">, y: </span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;"> }, a);</span></span>
<span class="line"><span style="color:#BDC4CC;">// 等同于</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> aWithDefaults </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> Object.</span><span style="color:#DBB7FF;">assign</span><span style="color:#F0F3F6;">({ x: </span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">, y: </span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;"> }, a);</span></span></code></pre></div><p>与数组的扩展运算符一样，对象的扩展运算符后面可以跟表达式。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> obj</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  ...</span><span style="color:#F0F3F6;">(x </span><span style="color:#FF9492;">&gt;</span><span style="color:#91CBFF;"> 1</span><span style="color:#FF9492;"> ?</span><span style="color:#F0F3F6;"> {a: </span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">} </span><span style="color:#FF9492;">:</span><span style="color:#F0F3F6;"> {}),</span></span>
<span class="line"><span style="color:#F0F3F6;">  b: </span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span></code></pre></div><p>如果扩展运算符后面是一个空对象，则没有任何效果。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">{</span><span style="color:#FF9492;">...</span><span style="color:#F0F3F6;">{}, </span><span style="color:#FFB757;">a</span><span style="color:#F0F3F6;">: </span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">} </span><span style="color:#BDC4CC;">// { a: 1 }</span></span></code></pre></div><p>如果扩展运算符的参数是<code>null</code>或<code>undefined</code>，这两个值会被忽略，不会报错。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> emptyObject </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> { </span><span style="color:#FF9492;">...</span><span style="color:#91CBFF;">null</span><span style="color:#F0F3F6;">, </span><span style="color:#FF9492;">...</span><span style="color:#91CBFF;">undefined</span><span style="color:#F0F3F6;"> }; </span><span style="color:#BDC4CC;">// 不报错</span></span></code></pre></div><p>扩展运算符的参数对象之中，如果有取值函数<code>get</code>，这个函数是会执行的。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">// 并不会抛出错误，因为x属性只是被定义，但没执行</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> aWithXGetter </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  ...</span><span style="color:#F0F3F6;">a,</span></span>
<span class="line"><span style="color:#FF9492;">  get</span><span style="color:#DBB7FF;"> x</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#FF9492;">    throw</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> Error</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;not throw yet&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span>
<span class="line"><span style="color:#BDC4CC;">// 会抛出错误，因为x属性被执行了</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> runtimeError </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  ...</span><span style="color:#F0F3F6;">a,</span></span>
<span class="line"><span style="color:#FF9492;">  ...</span><span style="color:#F0F3F6;">{</span></span>
<span class="line"><span style="color:#FF9492;">    get</span><span style="color:#DBB7FF;"> x</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#FF9492;">      throw</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> Error</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;throw now&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#F0F3F6;">    }</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span></code></pre></div>`,266)]))}const r=a(p,[["render",e],["__file","ES6对象.html.vue"]]),y=JSON.parse('{"path":"/js/es6/ES6%E5%AF%B9%E8%B1%A1.html","title":"ES6对象","lang":"zh-CN","frontmatter":{"title":"ES6对象","date":"2023-02-05T00:00:00.000Z","tags":"es6","categories":"前端","order":7,"description":"属性的简洁表示法 ES6允许直接写入变量和函数，作为对象的属性和方法。 上面代码表明，ES6允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值。 除了属性简写，方法也可以简写。 下面是一个实际的例子。 这种写法用于函数的返回值，将会非常方便。 CommonJS模块输出一组变量，就非常合适使用简洁写法。 属性的赋值器（setter）和取...","head":[["meta",{"property":"og:url","content":"https://0oWSQo0.github.io/wsq-blog/js/es6/ES6%E5%AF%B9%E8%B1%A1.html"}],["meta",{"property":"og:title","content":"ES6对象"}],["meta",{"property":"og:description","content":"属性的简洁表示法 ES6允许直接写入变量和函数，作为对象的属性和方法。 上面代码表明，ES6允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值。 除了属性简写，方法也可以简写。 下面是一个实际的例子。 这种写法用于函数的返回值，将会非常方便。 CommonJS模块输出一组变量，就非常合适使用简洁写法。 属性的赋值器（setter）和取..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-11-01T01:55:29.000Z"}],["meta",{"property":"article:published_time","content":"2023-02-05T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-11-01T01:55:29.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"ES6对象\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-02-05T00:00:00.000Z\\",\\"dateModified\\":\\"2024-11-01T01:55:29.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"WSQ\\",\\"url\\":\\"https://0oWSQo0.github.com\\"}]}"]]},"headers":[{"level":2,"title":"属性的简洁表示法","slug":"属性的简洁表示法","link":"#属性的简洁表示法","children":[]},{"level":2,"title":"属性名表达式","slug":"属性名表达式","link":"#属性名表达式","children":[]},{"level":2,"title":"方法的name属性","slug":"方法的name属性","link":"#方法的name属性","children":[]},{"level":2,"title":"Object.is()","slug":"object-is","link":"#object-is","children":[]},{"level":2,"title":"Object.assign()","slug":"object-assign","link":"#object-assign","children":[{"level":3,"title":"基本用法","slug":"基本用法","link":"#基本用法","children":[]},{"level":3,"title":"注意点","slug":"注意点","link":"#注意点","children":[]},{"level":3,"title":"常见用途","slug":"常见用途","link":"#常见用途","children":[]}]},{"level":2,"title":"属性的可枚举性和遍历","slug":"属性的可枚举性和遍历","link":"#属性的可枚举性和遍历","children":[{"level":3,"title":"可枚举性","slug":"可枚举性","link":"#可枚举性","children":[]}]},{"level":2,"title":"属性的遍历","slug":"属性的遍历","link":"#属性的遍历","children":[{"level":3,"title":"(1)for...in","slug":"_1-for-in","link":"#_1-for-in","children":[]},{"level":3,"title":"(2)Object.keys(obj)","slug":"_2-object-keys-obj","link":"#_2-object-keys-obj","children":[]},{"level":3,"title":"(3)Object.getOwnPropertyNames(obj)","slug":"_3-object-getownpropertynames-obj","link":"#_3-object-getownpropertynames-obj","children":[]},{"level":3,"title":"(4)Object.getOwnPropertySymbols(obj)","slug":"_4-object-getownpropertysymbols-obj","link":"#_4-object-getownpropertysymbols-obj","children":[]},{"level":3,"title":"(5)Reflect.ownKeys(obj)","slug":"_5-reflect-ownkeys-obj","link":"#_5-reflect-ownkeys-obj","children":[]}]},{"level":2,"title":"__proto__属性,Object.setPrototypeOf(),Object.getPrototypeOf()","slug":"proto-属性-object-setprototypeof-object-getprototypeof","link":"#proto-属性-object-setprototypeof-object-getprototypeof","children":[{"level":3,"title":"__proto__属性","slug":"proto-属性","link":"#proto-属性","children":[]},{"level":3,"title":"Object.setPrototypeOf()","slug":"object-setprototypeof","link":"#object-setprototypeof","children":[]},{"level":3,"title":"Object.getPrototypeOf()","slug":"object-getprototypeof","link":"#object-getprototypeof","children":[]}]},{"level":2,"title":"super关键字","slug":"super关键字","link":"#super关键字","children":[]},{"level":2,"title":"Object.keys(),Object.values(),Object.entries()","slug":"object-keys-object-values-object-entries","link":"#object-keys-object-values-object-entries","children":[{"level":3,"title":"Object.keys()","slug":"object-keys","link":"#object-keys","children":[]},{"level":3,"title":"Object.values()","slug":"object-values","link":"#object-values","children":[]},{"level":3,"title":"Object.entries","slug":"object-entries","link":"#object-entries","children":[]}]},{"level":2,"title":"对象的扩展运算符","slug":"对象的扩展运算符","link":"#对象的扩展运算符","children":[{"level":3,"title":"解构赋值","slug":"解构赋值","link":"#解构赋值","children":[]},{"level":3,"title":"扩展运算符","slug":"扩展运算符","link":"#扩展运算符","children":[]}]}],"git":{"createdTime":1726034220000,"updatedTime":1730426129000,"contributors":[{"name":"WSQ","email":"592786982@qq.com","commits":2}]},"readingTime":{"minutes":26.16,"words":7847},"filePathRelative":"js/es6/ES6对象.md","localizedDate":"2023年2月5日","autoDesc":true}');export{r as comp,y as data};
