import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,d as o,o as l}from"./app-ByvFWdWZ.js";const p={};function e(c,s){return l(),n("div",null,s[0]||(s[0]=[o(`<h2 id="any-类型" tabindex="-1"><a class="header-anchor" href="#any-类型"><span>any 类型</span></a></h2><h3 id="基本含义" tabindex="-1"><a class="header-anchor" href="#基本含义"><span>基本含义</span></a></h3><p><code>any</code>类型表示没有任何限制，该类型的变量可以赋予任意类型的值。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> x</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">any</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">x </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 1</span><span style="color:#F0F3F6;">; </span><span style="color:#BDC4CC;">// 正确</span></span>
<span class="line"><span style="color:#F0F3F6;">x </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &#39;foo&#39;</span><span style="color:#F0F3F6;">; </span><span style="color:#BDC4CC;">// 正确</span></span>
<span class="line"><span style="color:#F0F3F6;">x </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> true</span><span style="color:#F0F3F6;">; </span><span style="color:#BDC4CC;">// 正确</span></span></code></pre></div><p>上面示例中，变量<code>x</code>的类型是<code>any</code>，就可以被赋值为任意类型的值。</p><p>变量类型一旦设为<code>any</code>，TypeScript 实际上会关闭这个变量的类型检查。即使有明显的类型错误，只要句法正确，都不会报错。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> x</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">any</span><span style="color:#FF9492;"> =</span><span style="color:#ADDCFF;"> &#39;hello&#39;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#DBB7FF;">x</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">) </span><span style="color:#BDC4CC;">// 不报错</span></span>
<span class="line"><span style="color:#F0F3F6;">x.foo </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 100</span><span style="color:#F0F3F6;">; </span><span style="color:#BDC4CC;">// 不报错</span></span></code></pre></div><p>上面示例中，变量x的值是一个字符串，但是把它当作函数调用，或者当作对象读取任意属性，TypeScript 编译时都不报错。原因就是<code>x</code>的类型是<code>any</code>，TypeScript 不对其进行类型检查。</p><p>由于这个原因，应该尽量避免使用<code>any</code>类型，否则就失去了使用 TypeScript 的意义。</p><p>实际开发中，<code>any</code>类型主要适用以下两个场合。</p><ol><li>出于特殊原因，需要关闭某些变量的类型检查，就可以把该变量的类型设为<code>any</code>。</li><li>为了适配以前老的 JavaScript 项目，让代码快速迁移到 TypeScript，可以把变量类型设为any。有些年代很久的大型 JavaScript 项目，尤其是别人的代码，很难为每一行适配正确的类型，这时你为那些类型复杂的变量加上<code>any</code>，TypeScript 编译时就不会报错。</li></ol><p>总之，TypeScript 认为，只要开发者使用了<code>any</code>类型，就表示开发者想要自己来处理这些代码，所以就不对any类型进行任何限制，怎么使用都可以。</p><p>从集合论的角度看，<code>any</code>类型可以看成是所有其他类型的全集，包含了一切可能的类型。TypeScript 将这种类型称为“顶层类型”，意为涵盖了所有下层。</p><h3 id="类型推断问题" tabindex="-1"><a class="header-anchor" href="#类型推断问题"><span>类型推断问题</span></a></h3><p>对于开发者没有指定类型、TypeScript 必须自己推断类型的那些变量，如果无法推断出类型，TypeScript 就会认为该变量的类型是<code>any</code>。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">function</span><span style="color:#DBB7FF;"> add</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">x</span><span style="color:#F0F3F6;">, </span><span style="color:#FFB757;">y</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#FF9492;">  return</span><span style="color:#F0F3F6;"> x </span><span style="color:#FF9492;">+</span><span style="color:#F0F3F6;"> y;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#DBB7FF;">add</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">, [</span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">3</span><span style="color:#F0F3F6;">]) </span><span style="color:#BDC4CC;">// 不报错</span></span></code></pre></div><p>上面示例中，函数<code>add()</code>的参数变量<code>x</code>和<code>y</code>，都没有足够的信息，TypeScript 无法推断出它们的类型，就会认为这两个变量和函数返回值的类型都是<code>any</code>。以至于后面就不再对函数<code>add()</code>进行类型检查了，怎么用都可以。</p><p>这显然是很糟糕的情况，所以对于那些类型不明显的变量，一定要显式声明类型，防止被推断为<code>any</code>。</p><p>TypeScript 提供了一个编译选项<code>noImplicitAny</code>，打开该选项，只要推断出<code>any</code>类型就会报错。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FFB757;">$</span><span style="color:#ADDCFF;"> tsc</span><span style="color:#91CBFF;"> --noImplicitAny</span><span style="color:#ADDCFF;"> app.ts</span></span></code></pre></div><p>上面命令使用了<code>noImplicitAny</code>编译选项进行编译，这时上面的函数<code>add()</code>就会报错。</p><p>这里有一个特殊情况，即使打开了<code>noImplicitAny</code>，使用<code>let</code>和<code>var</code>命令声明变量，但不赋值也不指定类型，是不会报错的。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> x; </span><span style="color:#BDC4CC;">// 不报错</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> y; </span><span style="color:#BDC4CC;">// 不报错</span></span></code></pre></div><p>上面示例中，变量x和y声明时没有赋值，也没有指定类型，TypeScript 会推断它们的类型为<code>any</code>。这时即使打开了<code>noImplicitAny</code>，也不会报错。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> x;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">x </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 123</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">x </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> { foo: </span><span style="color:#ADDCFF;">&#39;hello&#39;</span><span style="color:#F0F3F6;"> };</span></span></code></pre></div><p>上面示例中，变量x的类型推断为<code>any</code>，但是不报错，可以顺利通过编译。</p><p>由于这个原因，建议使用<code>let</code>和<code>var</code>声明变量时，如果不赋值，就一定要显式声明类型，否则可能存在安全隐患。</p><p><code>const</code>命令没有这个问题，因为 JavaScript 语言规定<code>const</code>声明变量时，必须同时进行初始化（赋值）。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> x</span><span style="color:#F0F3F6;">; </span><span style="color:#BDC4CC;">// 报错</span></span></code></pre></div><p>上面示例中，<code>const</code>命令声明的<code>x</code>是不能改变值的，声明时必须同时赋值，否则报错，所以它不存在类型推断为<code>any</code>的问题。</p><h3 id="污染问题" tabindex="-1"><a class="header-anchor" href="#污染问题"><span>污染问题</span></a></h3><p><code>any</code>类型除了关闭类型检查，还有一个很大的问题，就是它会“污染”其他变量。它可以赋值给其他任何类型的变量（因为没有类型检查），导致其他变量出错。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> x</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">any</span><span style="color:#FF9492;"> =</span><span style="color:#ADDCFF;"> &#39;hello&#39;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> y</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">number</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">y </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> x; </span><span style="color:#BDC4CC;">// 不报错</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">y </span><span style="color:#FF9492;">*</span><span style="color:#91CBFF;"> 123</span><span style="color:#BDC4CC;"> // 不报错</span></span>
<span class="line"><span style="color:#F0F3F6;">y.</span><span style="color:#DBB7FF;">toFixed</span><span style="color:#F0F3F6;">() </span><span style="color:#BDC4CC;">// 不报错</span></span></code></pre></div><p>上面示例中，变量<code>x</code>的类型是<code>any</code>，实际的值是一个字符串。变量<code>y</code>的类型是<code>number</code>，表示这是一个数值变量，但是它被赋值为<code>x</code>，这时并不会报错。然后，变量<code>y</code>继续进行各种数值运算，TypeScript 也检查不出错误，问题就这样留到运行时才会暴露。</p><p>污染其他具有正确类型的变量，把错误留到运行时，这就是不宜使用<code>any</code>类型的另一个主要原因。</p><h2 id="unknown-类型" tabindex="-1"><a class="header-anchor" href="#unknown-类型"><span>unknown 类型</span></a></h2><p>为了解决<code>any</code>类型“污染”其他变量的问题，TypeScript 3.0 引入了<code>unknown</code>类型。它与<code>any</code>含义相同，表示类型不确定，可能是任意类型，但是它的使用有一些限制，不像<code>any</code>那样自由，可以视为严格版的<code>any</code>。</p><p><code>unknown</code>跟<code>any</code>的相似之处，在于所有类型的值都可以分配给<code>unknown</code>类型。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> x</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">unknown</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">x </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> true</span><span style="color:#F0F3F6;">; </span><span style="color:#BDC4CC;">// 正确</span></span>
<span class="line"><span style="color:#F0F3F6;">x </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 42</span><span style="color:#F0F3F6;">; </span><span style="color:#BDC4CC;">// 正确</span></span>
<span class="line"><span style="color:#F0F3F6;">x </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &#39;Hello World&#39;</span><span style="color:#F0F3F6;">; </span><span style="color:#BDC4CC;">// 正确</span></span></code></pre></div><p>上面示例中，变量<code>x</code>的类型是<code>unknown</code>，可以赋值为各种类型的值。这与<code>any</code>的行为一致。</p><p><code>unknown</code>类型跟<code>any</code>类型的不同之处在于，它不能直接使用。主要有以下几个限制。</p><p>首先，<code>unknown</code>类型的变量，不能直接赋值给其他类型的变量（除了<code>any</code>类型和<code>unknown</code>类型）。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> v</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">unknown</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> 123</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> v1</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">boolean</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> v; </span><span style="color:#BDC4CC;">// 报错</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> v2</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">number</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> v; </span><span style="color:#BDC4CC;">// 报错</span></span></code></pre></div><p>其次，不能直接调用<code>unknown</code>类型变量的方法和属性。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> v1</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">unknown</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> { foo: </span><span style="color:#91CBFF;">123</span><span style="color:#F0F3F6;"> };</span></span>
<span class="line"><span style="color:#F0F3F6;">v1.foo  </span><span style="color:#BDC4CC;">// 报错</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> v2</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">unknown</span><span style="color:#FF9492;"> =</span><span style="color:#ADDCFF;"> &#39;hello&#39;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">v2.</span><span style="color:#DBB7FF;">trim</span><span style="color:#F0F3F6;">() </span><span style="color:#BDC4CC;">// 报错</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#DBB7FF;"> v3</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">unknown</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> (</span><span style="color:#FFB757;">n</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> 0</span><span style="color:#F0F3F6;">) </span><span style="color:#FF9492;">=&gt;</span><span style="color:#F0F3F6;"> n </span><span style="color:#FF9492;">+</span><span style="color:#91CBFF;"> 1</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#DBB7FF;">v3</span><span style="color:#F0F3F6;">() </span><span style="color:#BDC4CC;">// 报错</span></span></code></pre></div><p>上面示例中，直接调用<code>unknown</code>类型变量的属性和方法，或者直接当作函数执行，都会报错。</p><p>再次，<code>unknown</code>类型变量能够进行的运算是有限的，只能进行比较运算（<code>==、===、!=、!==、||、&amp;&amp;、?</code>）、取反运算（<code>!</code>）、<code>typeof</code>运算符和<code>instanceof</code>运算符这几种，其他运算都会报错。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> a</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">unknown</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> 1</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">a </span><span style="color:#FF9492;">+</span><span style="color:#91CBFF;"> 1</span><span style="color:#BDC4CC;"> // 报错</span></span>
<span class="line"><span style="color:#F0F3F6;">a </span><span style="color:#FF9492;">===</span><span style="color:#91CBFF;"> 1</span><span style="color:#BDC4CC;"> // 正确</span></span></code></pre></div><p>那么，怎么才能使用<code>unknown</code>类型变量呢？</p><p>答案是只有经过“类型缩小”，<code>unknown</code>类型变量才可以使用。所谓“类型缩小”，就是缩小<code>unknown</code>变量的类型范围，确保不会出错。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> a</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">unknown</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> 1</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">if</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">typeof</span><span style="color:#F0F3F6;"> a </span><span style="color:#FF9492;">===</span><span style="color:#ADDCFF;"> &#39;number&#39;</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#FF9492;">  let</span><span style="color:#F0F3F6;"> r </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> a </span><span style="color:#FF9492;">+</span><span style="color:#91CBFF;"> 10</span><span style="color:#F0F3F6;">; </span><span style="color:#BDC4CC;">// 正确</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面示例中，<code>unknown</code>类型的变量<code>a</code>经过<code>typeof</code>运算以后，能够确定实际类型是<code>number</code>，就能用于加法运算了。这就是“类型缩小”，即将一个不确定的类型缩小为更明确的类型。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> s</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">unknown</span><span style="color:#FF9492;"> =</span><span style="color:#ADDCFF;"> &#39;hello&#39;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">if</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">typeof</span><span style="color:#F0F3F6;"> s </span><span style="color:#FF9492;">===</span><span style="color:#ADDCFF;"> &#39;string&#39;</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#F0F3F6;">  s.</span><span style="color:#91CBFF;">length</span><span style="color:#F0F3F6;">; </span><span style="color:#BDC4CC;">// 正确</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面示例中，确定变量<code>s</code>的类型为字符串以后，才能调用它的<code>length</code>属性。</p><p>这样设计的目的是，只有明确<code>unknown</code>变量的实际类型，才允许使用它，防止像<code>any</code>那样可以随意乱用，“污染”其他变量。类型缩小以后再使用，就不会报错。</p><p>总之，<code>unknown</code>可以看作是更安全的<code>any</code>。一般来说，凡是需要设为<code>any</code>类型的地方，通常都应该优先考虑设为<code>unknown</code>类型。</p><p>在集合论上，<code>unknown</code>也可以视为所有其他类型（除了<code>any</code>）的全集，所以它和<code>any</code>一样，也属于 TypeScript 的顶层类型。</p><h2 id="never-类型" tabindex="-1"><a class="header-anchor" href="#never-类型"><span>never 类型</span></a></h2><p>为了保持与集合论的对应关系，以及类型运算的完整性，TypeScript 还引入了“空类型”的概念，即该类型为空，不包含任何值。</p><p>由于不存在任何属于“空类型”的值，所以该类型被称为<code>never</code>，即不可能有这样的值。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> x</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">never</span><span style="color:#F0F3F6;">;</span></span></code></pre></div><p>上面示例中，变量<code>x</code>的类型是<code>never</code>，就不可能赋给它任何值，否则都会报错。</p><p><code>never</code>类型的使用场景，主要是在一些类型运算之中，保证类型运算的完整性。另外，不可能返回值的函数，返回值的类型就可以写成<code>never</code>。</p><p>如果一个变量可能有多种类型（即联合类型），通常需要使用分支处理每一种类型。这时，处理所有可能的类型之后，剩余的情况就属于<code>never</code>类型。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">function</span><span style="color:#DBB7FF;"> fn</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">x</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">string</span><span style="color:#FF9492;">|</span><span style="color:#91CBFF;">number</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#FF9492;">  if</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">typeof</span><span style="color:#F0F3F6;"> x </span><span style="color:#FF9492;">===</span><span style="color:#ADDCFF;"> &#39;string&#39;</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#BDC4CC;">    // ...</span></span>
<span class="line"><span style="color:#F0F3F6;">  } </span><span style="color:#FF9492;">else</span><span style="color:#FF9492;"> if</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">typeof</span><span style="color:#F0F3F6;"> x </span><span style="color:#FF9492;">===</span><span style="color:#ADDCFF;"> &#39;number&#39;</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#BDC4CC;">    // ...</span></span>
<span class="line"><span style="color:#F0F3F6;">  } </span><span style="color:#FF9492;">else</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">    x; </span><span style="color:#BDC4CC;">// never 类型</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面示例中，参数变量<code>x</code>可能是字符串，也可能是数值，判断了这两种情况后，剩下的最后那个<code>else</code>分支里面，<code>x</code>就是<code>never</code>类型了。</p><p><code>never</code>类型的一个重要特点是，可以赋值给任意其他类型。</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" data-title="ts" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">function</span><span style="color:#DBB7FF;"> f</span><span style="color:#F0F3F6;">()</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">never</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  throw</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> Error</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;Error&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> v1</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">number</span><span style="color:#FF9492;"> =</span><span style="color:#DBB7FF;"> f</span><span style="color:#F0F3F6;">(); </span><span style="color:#BDC4CC;">// 不报错</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> v2</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">string</span><span style="color:#FF9492;"> =</span><span style="color:#DBB7FF;"> f</span><span style="color:#F0F3F6;">(); </span><span style="color:#BDC4CC;">// 不报错</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> v3</span><span style="color:#FF9492;">:</span><span style="color:#91CBFF;">boolean</span><span style="color:#FF9492;"> =</span><span style="color:#DBB7FF;"> f</span><span style="color:#F0F3F6;">(); </span><span style="color:#BDC4CC;">// 不报错</span></span></code></pre></div><p>上面示例中，函数<code>f()</code>会抛出错误，所以返回值类型可以写成<code>never</code>，即不可能返回任何值。各种其他类型的变量都可以赋值为<code>f()</code>的运行结果（<code>never</code>类型）。</p><p>为什么<code>never</code>类型可以赋值给任意其他类型呢？这也跟集合论有关，空集是任何集合的子集。TypeScript 就相应规定，任何类型都包含了<code>never</code>类型。因此，<code>never</code>类型是任何其他类型所共有的，TypeScript 把这种情况称为“底层类型”。</p><p>总之，TypeScript 有两个“顶层类型”（<code>any</code>和<code>unknown</code>），但是“底层类型”只有<code>never</code>唯一一个。</p>`,71)]))}const r=a(p,[["render",e],["__file","ts三种特殊类型.html.vue"]]),y=JSON.parse('{"path":"/js/ts/ts%E4%B8%89%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%B1%BB%E5%9E%8B.html","title":"","lang":"zh-CN","frontmatter":{"description":"any 类型 基本含义 any类型表示没有任何限制，该类型的变量可以赋予任意类型的值。 上面示例中，变量x的类型是any，就可以被赋值为任意类型的值。 变量类型一旦设为any，TypeScript 实际上会关闭这个变量的类型检查。即使有明显的类型错误，只要句法正确，都不会报错。 上面示例中，变量x的值是一个字符串，但是把它当作函数调用，或者当作对象读取...","head":[["meta",{"property":"og:url","content":"https://0oWSQo0.github.io/wsq-blog/js/ts/ts%E4%B8%89%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%B1%BB%E5%9E%8B.html"}],["meta",{"property":"og:description","content":"any 类型 基本含义 any类型表示没有任何限制，该类型的变量可以赋予任意类型的值。 上面示例中，变量x的类型是any，就可以被赋值为任意类型的值。 变量类型一旦设为any，TypeScript 实际上会关闭这个变量的类型检查。即使有明显的类型错误，只要句法正确，都不会报错。 上面示例中，变量x的值是一个字符串，但是把它当作函数调用，或者当作对象读取..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-09-11T05:57:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-09-11T05:57:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-09-11T05:57:00.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"WSQ\\",\\"url\\":\\"https://0oWSQo0.github.com\\"}]}"]]},"headers":[{"level":2,"title":"any 类型","slug":"any-类型","link":"#any-类型","children":[{"level":3,"title":"基本含义","slug":"基本含义","link":"#基本含义","children":[]},{"level":3,"title":"类型推断问题","slug":"类型推断问题","link":"#类型推断问题","children":[]},{"level":3,"title":"污染问题","slug":"污染问题","link":"#污染问题","children":[]}]},{"level":2,"title":"unknown 类型","slug":"unknown-类型","link":"#unknown-类型","children":[]},{"level":2,"title":"never 类型","slug":"never-类型","link":"#never-类型","children":[]}],"git":{"createdTime":1726034220000,"updatedTime":1726034220000,"contributors":[{"name":"WSQ","email":"592786982@qq.com","commits":1}]},"readingTime":{"minutes":8.15,"words":2445},"filePathRelative":"js/ts/ts三种特殊类型.md","localizedDate":"2024年9月11日","autoDesc":true}');export{r as comp,y as data};
