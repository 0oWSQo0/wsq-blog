import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as l,d as n,o as t}from"./app-Coac0FJ0.js";const e={};function o(p,s){return t(),l("div",null,s[0]||(s[0]=[n(`<h2 id="cat-连接文件并打印输出到标准输出设备" tabindex="-1"><a class="header-anchor" href="#cat-连接文件并打印输出到标准输出设备"><span>cat：连接文件并打印输出到标准输出设备</span></a></h2><p><code>cat</code>命令可以用来显示文本文件的内容，也可以把几个文件内容附加到另一个文件中，即连接合并文件。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FFB757;">cat</span><span style="color:#F0F3F6;"> [选项] 文件名</span></span>
<span class="line"><span style="color:#FFB757;">或者</span></span>
<span class="line"><span style="color:#FFB757;">cat</span><span style="color:#ADDCFF;"> 文件1</span><span style="color:#ADDCFF;"> 文件2</span><span style="color:#FF9492;"> &gt;</span><span style="color:#ADDCFF;"> 文件3</span></span></code></pre></div><p>这两种格式中，前者用于显示文件的内容；后者用于连接合并文件。</p><table><thead><tr><th style="text-align:center;">选项</th><th style="text-align:left;">含义</th></tr></thead><tbody><tr><td style="text-align:center;">-A</td><td style="text-align:left;">相当于<code>-vET</code>选项的整合，用于列出所有隐藏符号</td></tr><tr><td style="text-align:center;">-E</td><td style="text-align:left;">列出每行结尾的回车符<code>$</code></td></tr><tr><td style="text-align:center;">-n</td><td style="text-align:left;">对输出的所有行进行编号</td></tr><tr><td style="text-align:center;">-b</td><td style="text-align:left;">与<code>-n</code>不同，此选项表示只对非空行进行编号</td></tr><tr><td style="text-align:center;">-T</td><td style="text-align:left;">把 Tab 键<code>^I</code>显示出来</td></tr><tr><td style="text-align:center;">-V</td><td style="text-align:left;">列出特殊字符</td></tr><tr><td style="text-align:center;">-s</td><td style="text-align:left;">当遇到有连续 2 行以上的空白行时，就替换为 1 行的空白行</td></tr></tbody></table><blockquote><p>注意，<code>cat</code>命令用于查看文件内容时，不论文件内容有多少，都会一次性显示。如果文件非常大，那么文件开头的内容就看不到了。不过 Linux 可以使用<code>PgUp+↑</code>组合键向上翻页，但是这种翻页是有极限的，如果文件足够长，那么还是无法看全文件的内容。因此，<code>cat</code>命令适合查看不太大的文件。</p></blockquote><p>如果使用<code>-A</code>选项，则相当于使用了<code>-vET</code>选项，可以查看文本中的所有隐藏符号，包括回车符（<code>$</code>）、Tab 键（<code>^I</code>）等。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# cat -A anaconda-ks.cfg</span></span>
<span class="line"><span style="color:#BDC4CC;"># Kickstart file automatically generated by anaconda.$</span></span>
<span class="line"><span style="color:#FFB757;">$</span></span>
<span class="line"><span style="color:#FFB757;">$</span></span>
<span class="line"><span style="color:#BDC4CC;">#version=DEVEL$</span></span>
<span class="line"><span style="color:#FFB757;">install$</span></span>
<span class="line"><span style="color:#FFB757;">cdrom$</span></span>
<span class="line"><span style="color:#FFB757;">…省略部分内容…</span></span></code></pre></div><p>将文件<code>file1.txt</code>和<code>file2.txt</code>的内容合并后输出到文件<code>file3.txt</code>中。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost base]# ls</span></span>
<span class="line"><span style="color:#FFB757;">file1.txt</span><span style="color:#ADDCFF;">    file2.txt</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost base]# cat file1.txt</span></span>
<span class="line"><span style="color:#FFB757;">hello</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost base]# cat file2.txt</span></span>
<span class="line"><span style="color:#FFB757;">world</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost base]# cat file1.txt file2.txt </span><span style="color:#FF9492;">&gt;</span><span style="color:#F0F3F6;"> file3.txt</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost base]# more file3.txt </span><span style="color:#BDC4CC;">#more 命令可查看文件中的内容</span></span>
<span class="line"><span style="color:#FFB757;">hello</span></span>
<span class="line"><span style="color:#FFB757;">world</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost base]# ls</span></span>
<span class="line"><span style="color:#FFB757;">file1.txt</span><span style="color:#ADDCFF;">    file2.txt</span><span style="color:#ADDCFF;">    file3.txt</span></span></code></pre></div><h2 id="more-分屏显示文件内容" tabindex="-1"><a class="header-anchor" href="#more-分屏显示文件内容"><span>more：分屏显示文件内容</span></a></h2><p><code>more</code>命令可以分页显示文本文件的内容，使用者可以逐页阅读文件中内容：</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FFB757;">more</span><span style="color:#F0F3F6;"> [选项] 文件名</span></span></code></pre></div><table><thead><tr><th style="text-align:center;">选项</th><th style="text-align:left;">含义</th></tr></thead><tbody><tr><td style="text-align:center;">-f</td><td style="text-align:left;">计算行数时，以实际的行数，而不是自动换行过后的行数</td></tr><tr><td style="text-align:center;">-p</td><td style="text-align:left;">不以卷动的方式显示每一页，而是先清除屏幕后再显示内容</td></tr><tr><td style="text-align:center;">-c</td><td style="text-align:left;">跟<code>-p</code>选项相似，不同的是先显示内容再清除其他旧资料</td></tr><tr><td style="text-align:center;">-s</td><td style="text-align:left;">当遇到有连续两行以上的空白行时，就替换为一行的空白行</td></tr><tr><td style="text-align:center;">-u</td><td style="text-align:left;">不显示下引号（根据环境变量 TERM 指定的终端而有所不同）</td></tr><tr><td style="text-align:center;">+n</td><td style="text-align:left;">从第 n 行开始显示文件内容，n 代表数字</td></tr><tr><td style="text-align:center;">-n</td><td style="text-align:left;">一次显示的行数，n 代表数字</td></tr></tbody></table><p><code>more</code>命令的执行会打开一个交互界面，常用的交互命令：</p><table><thead><tr><th style="text-align:center;">交互指令</th><th style="text-align:left;">功能</th></tr></thead><tbody><tr><td style="text-align:center;">h 或 ?</td><td style="text-align:left;">显示 more 命令交互命令帮助</td></tr><tr><td style="text-align:center;">q 或 Q</td><td style="text-align:left;">退出 more</td></tr><tr><td style="text-align:center;">v</td><td style="text-align:left;">在当前行启动一个编辑器</td></tr><tr><td style="text-align:center;">:f</td><td style="text-align:left;">显示当前文件的文件名和行号</td></tr><tr><td style="text-align:center;">!&lt;命令&gt; 或 :!&lt;命令&gt;</td><td style="text-align:left;">在子Shell中执行指定命令</td></tr><tr><td style="text-align:center;">回车键</td><td style="text-align:left;">向下移动一行</td></tr><tr><td style="text-align:center;">空格键</td><td style="text-align:left;">向下移动一页</td></tr><tr><td style="text-align:center;">Ctrl+l</td><td style="text-align:left;">刷新屏幕</td></tr><tr><td style="text-align:center;">=</td><td style="text-align:left;">显示当前行的行号</td></tr><tr><td style="text-align:center;">&#39;</td><td style="text-align:left;">转到上一次搜索开始的地方</td></tr><tr><td style="text-align:center;">Ctrf+f</td><td style="text-align:left;">向下滚动一页</td></tr><tr><td style="text-align:center;">.</td><td style="text-align:left;">重复上次输入的命令</td></tr><tr><td style="text-align:center;">/字符串</td><td style="text-align:left;">搜索指定的字符串</td></tr><tr><td style="text-align:center;">d</td><td style="text-align:left;">向下移动半页</td></tr><tr><td style="text-align:center;">b</td><td style="text-align:left;">向上移动一页</td></tr></tbody></table><p>显示文件<code>anaconda-ks.cfg</code>的内容，每 10 行显示一屏，同时清除屏幕：</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# more -c -10 anaconda-ks.cfg</span></span>
<span class="line"><span style="color:#BDC4CC;">#省略输出内容。</span></span></code></pre></div><h2 id="head-显示文件开头的内容" tabindex="-1"><a class="header-anchor" href="#head-显示文件开头的内容"><span>head：显示文件开头的内容</span></a></h2><p><code>head</code>命令可以显示指定文件前若干行的文件内容。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FFB757;">head</span><span style="color:#F0F3F6;"> [选项] 文件名</span></span></code></pre></div><table><thead><tr><th style="text-align:center;">选项</th><th style="text-align:left;">含义</th></tr></thead><tbody><tr><td style="text-align:center;">-n K</td><td style="text-align:left;">这里的 K 表示行数，该选项用来显示文件前 K 行的内容；如果使用 &quot;-K&quot; 作为参数，则表示除了文件最后 K 行外，显示剩余的全部内容。</td></tr><tr><td style="text-align:center;">-c K</td><td style="text-align:left;">这里的 K 表示字节数，该选项用来显示文件前 K 个字节的内容；如果使用 &quot;-K&quot;，则表示除了文件最后 K 字节的内容，显示剩余全部内容。</td></tr><tr><td style="text-align:center;">-v</td><td style="text-align:left;">显示文件名；注意，如不设置显示的具体行数，则默认显示 10 行的文本数据。</td></tr></tbody></table><p><code>head</code>命令默认显示文件的开头 10 行内容。如果想显示指定的行数，则只需使用<code>-n</code>选项即可：</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# head -n 20 anaconda-ks.cfg</span></span></code></pre></div><p>这是显示文件的开头 20 行内容，也可以直接写&quot;-行数&quot;：</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# head -20 anaconda-ks.cfg</span></span></code></pre></div><h2 id="less-查看文件内容" tabindex="-1"><a class="header-anchor" href="#less-查看文件内容"><span>less：查看文件内容</span></a></h2><p><code>less</code>命令的作用和<code>more</code>十分类似，都用来浏览文本文件中的内容，不同之处在于，使用<code>more</code>命令浏览文件内容时，只能不断向后翻看，而使用<code>less</code>命令浏览，既可以向后翻看，也可以向前翻看。</p><p>不仅如此，为了方面用户浏览文本内容，<code>less</code>命令还提供了以下几个功能：</p><ul><li>使用光标键可以在文本文件中前后（左后）滚屏；</li><li>用行号或百分比作为书签浏览文件；</li><li>提供更加友好的检索、高亮显示等操作；</li><li>兼容常用的字处理程序（如 Vim、Emacs）的键盘操作；</li><li>阅读到文件结束时，<code>less</code>命令不会退出；</li><li>屏幕底部的信息提示更容易控制使用，而且提供了更多的信息。</li></ul><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FFB757;">less</span><span style="color:#F0F3F6;"> [选项] 文件名</span></span></code></pre></div><table><thead><tr><th style="text-align:center;">选项</th><th style="text-align:center;">含义</th></tr></thead><tbody><tr><td style="text-align:center;">-N</td><td style="text-align:center;">显示每行的行号。</td></tr><tr><td style="text-align:center;">-S</td><td style="text-align:center;">行过长时将超出部分舍弃。</td></tr><tr><td style="text-align:center;">-e</td><td style="text-align:center;">当文件显示结束后，自动离开。</td></tr><tr><td style="text-align:center;">-g</td><td style="text-align:center;">只标志最后搜索到的关键同。</td></tr><tr><td style="text-align:center;">-Q</td><td style="text-align:center;">不使用警告音。</td></tr><tr><td style="text-align:center;">-i</td><td style="text-align:center;">忽略搜索时的大小写。</td></tr><tr><td style="text-align:center;">-m</td><td style="text-align:center;">显示类似 more 命令的百分比。</td></tr><tr><td style="text-align:center;">-f</td><td style="text-align:center;">强迫打开特殊文件，比如外围设备代号、目录和二进制文件。</td></tr><tr><td style="text-align:center;">-s</td><td style="text-align:center;">显示连续空行为一行。</td></tr><tr><td style="text-align:center;">-b</td><td style="text-align:center;">&lt;缓冲区大小&gt; 设置缓冲区的大小。</td></tr><tr><td style="text-align:center;">-o</td><td style="text-align:center;">&lt;文件名&gt; 将 less 输出的内容保存到指定文件中。</td></tr><tr><td style="text-align:center;">-x</td><td style="text-align:center;">&lt;数字&gt; 将【Tab】键显示为规定的数字空格。</td></tr></tbody></table><p>在使用<code>less</code>命令查看文件内容的过程中，和<code>more</code>命令一样，也会进入交互界面，因此需要掌握一些常用的交互指令。</p><table><thead><tr><th style="text-align:center;">交互指令</th><th style="text-align:center;">功能</th></tr></thead><tbody><tr><td style="text-align:center;">/字符串</td><td style="text-align:center;">向下搜索“字符串”的功能。</td></tr><tr><td style="text-align:center;">?字符串</td><td style="text-align:center;">向上搜索“字符串”的功能。</td></tr><tr><td style="text-align:center;">n</td><td style="text-align:center;">重复*前一个搜索（与 / 成 ? 有关）。</td></tr><tr><td style="text-align:center;">N</td><td style="text-align:center;">反向重复前一个搜索（与 / 或 ? 有关）。</td></tr><tr><td style="text-align:center;">b</td><td style="text-align:center;">向上移动一页。</td></tr><tr><td style="text-align:center;">d</td><td style="text-align:center;">向下移动半页。</td></tr><tr><td style="text-align:center;">h 或 H</td><td style="text-align:center;">显示帮助界面。</td></tr><tr><td style="text-align:center;">q 或 Q</td><td style="text-align:center;">退出 less 命令。</td></tr><tr><td style="text-align:center;">y</td><td style="text-align:center;">向上移动一行。</td></tr><tr><td style="text-align:center;">空格键</td><td style="text-align:center;">向下移动一页。</td></tr><tr><td style="text-align:center;">回车键</td><td style="text-align:center;">向下移动一行。</td></tr><tr><td style="text-align:center;">【PgDn】键</td><td style="text-align:center;">向下移动一页。</td></tr><tr><td style="text-align:center;">【PgUp】键</td><td style="text-align:center;">向上移动一页。</td></tr><tr><td style="text-align:center;">Ctrl+f</td><td style="text-align:center;">向下移动一页。</td></tr><tr><td style="text-align:center;">Ctrl+b</td><td style="text-align:center;">向上移动一页。</td></tr><tr><td style="text-align:center;">Ctrl+d</td><td style="text-align:center;">向下移动一页。</td></tr><tr><td style="text-align:center;">Ctrl+u</td><td style="text-align:center;">向上移动半页。</td></tr><tr><td style="text-align:center;">j</td><td style="text-align:center;">向下移动一行。</td></tr><tr><td style="text-align:center;">k</td><td style="text-align:center;">向上移动一行。</td></tr><tr><td style="text-align:center;">G</td><td style="text-align:center;">移动至最后一行。</td></tr><tr><td style="text-align:center;">g</td><td style="text-align:center;">移动到第一行。</td></tr><tr><td style="text-align:center;">ZZ</td><td style="text-align:center;">退出 less 命令。</td></tr><tr><td style="text-align:center;">v</td><td style="text-align:center;">使用配置的编辑器编辑当前文件。</td></tr><tr><td style="text-align:center;">[</td><td style="text-align:center;">移动到本文档的上一个节点。</td></tr><tr><td style="text-align:center;">]</td><td style="text-align:center;">移动到本文档的下一个节点。</td></tr><tr><td style="text-align:center;">p</td><td style="text-align:center;">移动到同级的上一个节点。</td></tr><tr><td style="text-align:center;">u</td><td style="text-align:center;">向上移动半页。</td></tr></tbody></table><p>使用<code>less</code>命令查看<code>/boot/grub/grub.cfg</code>文件中的内容。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# less /boot/grub/grub.cfg</span></span></code></pre></div><p>可以看到，<code>less</code>在屏幕底部显示一个冒号（<code>:</code>），等待用户输入命令，比如说，用户想向下翻一页，可以按空格键；如果想向上翻一页，可以按<code>b</code>键。</p><h2 id="tail-显示文件结尾的内容" tabindex="-1"><a class="header-anchor" href="#tail-显示文件结尾的内容"><span>tail：显示文件结尾的内容</span></a></h2><p><code>tail</code>命令和<code>head</code>命令正好相反，它用来查看文件末尾的数据：</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FFB757;">tail</span><span style="color:#F0F3F6;"> [选项] 文件名</span></span></code></pre></div><table><thead><tr><th style="text-align:center;">选项</th><th style="text-align:center;">含义</th></tr></thead><tbody><tr><td style="text-align:center;">-n K</td><td style="text-align:center;">这里的 K 指的是行数，该选项表示输出最后 K 行，在此基础上，如果使用 -n +K，则表示从文件的第 K 行开始输出。</td></tr><tr><td style="text-align:center;">-c K</td><td style="text-align:center;">这里的 K 指的是字节数，该选项表示输出文件最后 K 个字节的内容，在此基础上，使用 -c +K 则表示从文件第 K 个字节开始输出。</td></tr><tr><td style="text-align:center;">-f</td><td style="text-align:center;">输出文件变化后新增加的数据。</td></tr></tbody></table><p>查看<code>/etc/passwd</code>文件最后 3 行的数据内容。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# tail -n 3 /etc/passwd</span></span>
<span class="line"><span style="color:#FFB757;">sshd:x:74:74:Privilege-separated</span><span style="color:#ADDCFF;"> SSH:/var/empty/sshd:/sbin/nologin</span></span>
<span class="line"><span style="color:#FFB757;">oprofile:x:16:16:Special</span><span style="color:#ADDCFF;"> user</span><span style="color:#ADDCFF;"> account</span><span style="color:#ADDCFF;"> to</span><span style="color:#ADDCFF;"> be</span><span style="color:#ADDCFF;"> used</span><span style="color:#ADDCFF;"> by</span><span style="color:#ADDCFF;"> OProfile:/var/lib/oprofile:/sbin/nologin</span></span>
<span class="line"><span style="color:#FFB757;">tcpdump:x:72:72::/:/sbin/nologin</span></span></code></pre></div><p>除此之外，还可以采用如下这种形式：</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# tail -3 /etc/passwd</span></span>
<span class="line"><span style="color:#FFB757;">sshd:x:74:74:Privilege-separated</span><span style="color:#ADDCFF;"> SSH:/var/empty/sshd:/sbin/nologin</span></span>
<span class="line"><span style="color:#FFB757;">oprofile:x:16:16:Special</span><span style="color:#ADDCFF;"> user</span><span style="color:#ADDCFF;"> account</span><span style="color:#ADDCFF;"> to</span><span style="color:#ADDCFF;"> be</span><span style="color:#ADDCFF;"> used</span><span style="color:#ADDCFF;"> by</span><span style="color:#ADDCFF;"> OProfile:/var/lib/oprofile:/sbin/nologin</span></span>
<span class="line"><span style="color:#FFB757;">tcpdump:x:72:72::/:/sbin/nologin</span></span></code></pre></div><p>可以看到，使用<code>tail -n 3 /etc/passwd</code>命令和<code>tail -3 /etc/passwd</code>的效果是一样的。</p><p>查看<code>/etc/passwd</code>文件末尾 100 个字节的数据内容。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# tail -c 100 /etc/passwd</span></span>
<span class="line"><span style="color:#FFB757;">cpdump:x:72:72::/:/sbin/nologin</span></span></code></pre></div><p>可以使用<code>-f</code>选项来监听文件的新増内容：</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]#tail -f anaconda-ks.cfg</span></span>
<span class="line"><span style="color:#FFB757;">@server-platform</span></span>
<span class="line"><span style="color:#FFB757;">@server-policy</span></span>
<span class="line"><span style="color:#FFB757;">pax</span></span>
<span class="line"><span style="color:#FFB757;">oddjob</span></span>
<span class="line"><span style="color:#FFB757;">sgpio</span></span>
<span class="line"><span style="color:#FFB757;">certmonger</span></span>
<span class="line"><span style="color:#FFB757;">pam_krb5</span></span>
<span class="line"><span style="color:#FFB757;">krb5-workstation</span></span>
<span class="line"><span style="color:#FFB757;">perl-DBD-SQLite</span></span>
<span class="line"><span style="color:#FFB757;">%end</span></span>
<span class="line"><span style="color:#BDC4CC;">#光标不会退出文件，而会一直监听在文件的结尾处</span></span></code></pre></div><p>这条命令会显示文件的最后 10 行内容，而且光标不会退出命令，每隔一秒会检查一下文件是否增加新的内容，如果增加就追加到原来的输出结果后面并显示。</p><p>如果想终止输出，按<code>Ctrl+c</code>键中断<code>tail</code>命令即可。</p><h2 id="重定向-输入输出重定向" tabindex="-1"><a class="header-anchor" href="#重定向-输入输出重定向"><span>重定向（输入输出重定向）</span></a></h2><p>Linux 中标准的输入设备默认指的是键盘，标准的输出设备默认指的是显示器。而输入、输出重定向，完全可以从字面意思去理解，也就是：</p><ul><li>输入重定向：指的是重新指定设备来代替键盘作为新的输入设备；</li><li>输出重定向：指的是重新指定设备来代替显示器作为新的输出设备。</li></ul><p>通常是用文件或命令的执行结果来代替键盘作为新的输入设备，而新的输出设备通常指的就是文件。</p><h3 id="输入重定向" tabindex="-1"><a class="header-anchor" href="#输入重定向"><span>输入重定向</span></a></h3><p>对于输入重定向来说，其需要用到的符号以及作用如表。</p><table><thead><tr><th style="text-align:center;">命令符号格式</th><th style="text-align:left;">作用</th></tr></thead><tbody><tr><td style="text-align:center;">命令 &lt; 文件</td><td style="text-align:left;">将指定文件作为命令的输入设备</td></tr><tr><td style="text-align:center;">命令 &lt;&lt; 分界符</td><td style="text-align:left;">从标准输入设备（键盘）中读入，直到遇到分界符才停止（读入的数据不包括分界符）</td></tr><tr><td style="text-align:center;">命令 &lt; 文件 1 &gt; 文件 2</td><td style="text-align:left;">将文件 1 作为命令的输入设备，该命令的执行结果输出到文件 2 中</td></tr></tbody></table><p>默认情况下，<code>cat</code>命令会接受标准输入设备（键盘）的输入，并显示到控制台，但如果用文件代替键盘作为输入设备，那么该命令会以指定的文件作为输入设备，并将文件中的内容读取并显示到控制台。</p><p>以<code>/etc/passwd</code>文件（存储了系统中所有用户的基本信息）为例，执行如下命令：</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# cat /etc/passwd</span></span>
<span class="line"><span style="color:#BDC4CC;">#这里省略输出信息，读者可自行查看</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# cat </span><span style="color:#FF9492;">&lt;</span><span style="color:#F0F3F6;"> /etc/passwd</span></span>
<span class="line"><span style="color:#BDC4CC;">#输出结果同上面命令相同</span></span></code></pre></div><p>注意，虽然执行结果相同，但第一行代表是以键盘作为输入设备，而第二行代码是以<code>/etc/passwd</code>文件作为输入设备。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# cat </span><span style="color:#FF9492;">&lt;&lt;</span><span style="color:#F0F3F6;"> 0</span></span>
<span class="line"><span style="color:#ADDCFF;">\\&gt;linuxyz.cn</span></span>
<span class="line"><span style="color:#ADDCFF;">\\&gt;Linux</span></span>
<span class="line"><span style="color:#ADDCFF;">\\&gt;0</span></span>
<span class="line"><span style="color:#ADDCFF;">linuxyz.cn</span></span>
<span class="line"><span style="color:#ADDCFF;">Linux</span></span></code></pre></div><p>可以看到，当指定了 0 作为分界符之后，只要不输入 0，就可以一直输入数据。</p><p>首先，新建文本文件<code>a.txt</code>，然后执行如下命令：</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# cat a.txt</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# cat </span><span style="color:#FF9492;">&lt;</span><span style="color:#F0F3F6;"> /etc/passwd </span><span style="color:#FF9492;">&gt;</span><span style="color:#F0F3F6;"> a.txt</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# cat a.txt</span></span>
<span class="line"><span style="color:#BDC4CC;">#输出了和 /etc/passwd 文件内容相同的数据</span></span></code></pre></div><p>可以看到，通过重定向<code>/etc/passwd</code>作为输入设备，并输出重定向到<code>a.txt</code>，最终实现了将<code>/etc/passwd</code>文件中内容复制到<code>a.txt</code>中。</p><h3 id="输出重定向" tabindex="-1"><a class="header-anchor" href="#输出重定向"><span>输出重定向</span></a></h3><p>相较于输入重定向，我们使用输出重定向的频率更高。并且，和输入重定向不同的是，输出重定向还可以细分为标准输出重定向和错误输出重定向两种技术。</p><p>例如，使用<code>ls</code>命令分别查看两个文件的属性信息，但其中一个文件是不存在的，如下所示：</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# touch demo1.txt</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# ls -l demo1.txt</span></span>
<span class="line"><span style="color:#FFB757;">-rw-rw-r--.</span><span style="color:#91CBFF;"> 1</span><span style="color:#ADDCFF;"> root</span><span style="color:#ADDCFF;"> root</span><span style="color:#91CBFF;"> 0</span><span style="color:#ADDCFF;"> Oct</span><span style="color:#91CBFF;"> 12</span><span style="color:#ADDCFF;"> 15:02</span><span style="color:#ADDCFF;"> demo1.txt</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# ls -l demo2.txt  </span><span style="color:#FF9492;">&lt;</span><span style="color:#F0F3F6;">-- 不存在的文件</span></span>
<span class="line"><span style="color:#FFB757;">ls:</span><span style="color:#ADDCFF;"> cannot</span><span style="color:#ADDCFF;"> access</span><span style="color:#ADDCFF;"> demo2.txt:</span><span style="color:#ADDCFF;"> No</span><span style="color:#ADDCFF;"> such</span><span style="color:#ADDCFF;"> file</span><span style="color:#ADDCFF;"> or</span><span style="color:#ADDCFF;"> directory</span></span></code></pre></div><p>上述命令中，<code>demo1.txt</code>是存在的，因此正确输出了该文件的一些属性信息，这也是该命令执行的标准输出信息；而<code>demo2.txt</code>是不存在的，因此执行<code>ls</code>命令之后显示的报错信息，是该命令的错误输出信息。</p><p>再次强调，要想把原本输出到屏幕上的数据转而写入到文件中，这两种输出信息就要区别对待。</p><p>在此基础上，标准输出重定向和错误输出重定向又分别包含清空写入和追加写入两种模式。因此，对于输出重定向来说，其需要用到的符号以及作用如表。</p><table><thead><tr><th style="text-align:center;">命令符号格式</th><th style="text-align:left;">作用</th></tr></thead><tbody><tr><td style="text-align:center;">命令 &gt; 文件</td><td style="text-align:left;">将标准输出结果重定向到指定的文件中，清空原有文件数据</td></tr><tr><td style="text-align:center;">命令 2&gt; 文件</td><td style="text-align:left;">将错误输出结果重定向到指定的文件中，清空原有文件数据</td></tr><tr><td style="text-align:center;">命令 &gt;&gt; 文件</td><td style="text-align:left;">将标准输出结果重定向输出到指定的文件中，追加到原有内容的后面</td></tr><tr><td style="text-align:center;">命令 2&gt;&gt; 文件</td><td style="text-align:left;">将错误输出结果重定向到指定的文件中，追加到原有内容的后面</td></tr><tr><td style="text-align:center;">命令 &gt;&gt; 文件 2&gt;&amp;1</td><td style="text-align:left;">将标准输出和错误输出共同写入到指定文件，追加到原有内容的后面</td></tr></tbody></table><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# cat Linux.txt </span><span style="color:#FF9492;">&gt;</span><span style="color:#F0F3F6;"> demo.txt</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# cat demo.txt</span></span>
<span class="line"><span style="color:#FFB757;">Linux</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# cat Linux.txt </span><span style="color:#FF9492;">&gt;</span><span style="color:#F0F3F6;"> demo.txt</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# cat demo.txt</span></span>
<span class="line"><span style="color:#FFB757;">Linux</span><span style="color:#FF9492;">   &lt;</span><span style="color:#ADDCFF;">--这里的</span><span style="color:#ADDCFF;"> Linux</span><span style="color:#ADDCFF;"> 是清空原有的</span><span style="color:#ADDCFF;"> Linux</span><span style="color:#ADDCFF;"> 之后，写入的新的</span><span style="color:#ADDCFF;"> Linux</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# cat Linux.txt </span><span style="color:#FF9492;">&gt;&gt;</span><span style="color:#F0F3F6;"> demo.txt</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# cat demo.txt</span></span>
<span class="line"><span style="color:#FFB757;">Linux</span></span>
<span class="line"><span style="color:#FFB757;">Linux</span><span style="color:#FF9492;">   &lt;</span><span style="color:#ADDCFF;">--以追加的方式，新数据写入到原有数据之后</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# cat b.txt </span><span style="color:#FF9492;">&gt;</span><span style="color:#F0F3F6;"> demo.txt</span></span>
<span class="line"><span style="color:#FFB757;">cat:</span><span style="color:#ADDCFF;"> b.txt:</span><span style="color:#ADDCFF;"> No</span><span style="color:#ADDCFF;"> such</span><span style="color:#ADDCFF;"> file</span><span style="color:#ADDCFF;"> or</span><span style="color:#ADDCFF;"> directory</span><span style="color:#FF9492;"> &lt;</span><span style="color:#ADDCFF;">--</span><span style="color:#ADDCFF;"> 错误输出信息依然输出到了显示器中</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# cat b.txt </span><span style="color:#FF9492;">2&gt;</span><span style="color:#F0F3F6;"> demo.txt</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# cat demo.txt</span></span>
<span class="line"><span style="color:#FFB757;">cat:</span><span style="color:#ADDCFF;"> b.txt:</span><span style="color:#ADDCFF;"> No</span><span style="color:#ADDCFF;"> such</span><span style="color:#ADDCFF;"> file</span><span style="color:#ADDCFF;"> or</span><span style="color:#ADDCFF;"> directory</span><span style="color:#FF9492;"> &lt;</span><span style="color:#ADDCFF;">--清空文件，再将错误输出信息写入到该文件中</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# cat b.txt </span><span style="color:#FF9492;">2&gt;&gt;</span><span style="color:#F0F3F6;"> demo.txt</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# cat demo.txt</span></span>
<span class="line"><span style="color:#FFB757;">cat:</span><span style="color:#ADDCFF;"> b.txt:</span><span style="color:#ADDCFF;"> No</span><span style="color:#ADDCFF;"> such</span><span style="color:#ADDCFF;"> file</span><span style="color:#ADDCFF;"> or</span><span style="color:#ADDCFF;"> directory</span></span>
<span class="line"><span style="color:#FFB757;">cat:</span><span style="color:#ADDCFF;"> b.txt:</span><span style="color:#ADDCFF;"> No</span><span style="color:#ADDCFF;"> such</span><span style="color:#ADDCFF;"> file</span><span style="color:#ADDCFF;"> or</span><span style="color:#ADDCFF;"> directory</span><span style="color:#FF9492;"> &lt;</span><span style="color:#ADDCFF;">--追加写入错误输出信息</span></span></code></pre></div><h2 id="grep-查找文件内容" tabindex="-1"><a class="header-anchor" href="#grep-查找文件内容"><span>grep：查找文件内容</span></a></h2><p>很多时候，我们并不需要列出文件的全部内容，而是从文件中找到包含指定信息的那些行，要实现这个目的，可以使用<code>grep</code>命令。</p><p><code>grep</code>命令的由来可以追溯到 UNIX 诞生的早期，在 UNIX 系统中，搜索的模式被称为正则表达式（<code>regular expressions</code>），为了要彻底搜索一个文件，有的用户在要搜索的字符串前加上前缀<code>global</code>（全面的），一旦找到相匹配的内容，用户就像将其输出（<code>print</code>）到屏幕上，而将这一系列的操作整合到一起就是<code>global regular expressions print</code>，而这也就是<code>grep</code>命令的全称。</p><p><code>grep</code>命令能够在一个或多个文件中，搜索某一特定的字符模式（也就是正则表达式），此模式可以是单一的字符、字符串、单词或句子。</p><p>正则表达式是描述一组字符串的一个模式，通过使用操作符将较小的表达式组合成一个新的表达式。正则表达式可以是一些纯文本文字，也可以是用来产生模式的一些特殊字符。为了进一步定义一个搜索模式，<code>grep</code>命令支持如表所示的这几种正则表达式的元字符（也就是通配符）。</p><table><thead><tr><th style="text-align:center;">通配符</th><th style="text-align:left;">功能</th></tr></thead><tbody><tr><td style="text-align:center;">c*</td><td style="text-align:left;">将匹配 0 个（即空白）或多个字符 c（c 为任一字符）。</td></tr><tr><td style="text-align:center;">.</td><td style="text-align:left;">将匹配任何一个字符，且只能是一个字符。</td></tr><tr><td style="text-align:center;"><code>[xyz]</code></td><td style="text-align:left;">匹配方括号中的任意一个字符。</td></tr><tr><td style="text-align:center;">1</td><td style="text-align:left;">匹配除方括号中字符外的所有字符。</td></tr><tr><td style="text-align:center;">^</td><td style="text-align:left;">锁定行的开头。</td></tr><tr><td style="text-align:center;">$</td><td style="text-align:left;">锁定行的结尾。</td></tr></tbody></table><p>需要注意的是，在基本正则表达式中，如通配符<code>*、+、{、|、(</code>和<code>)</code>等，已经失去了它们原本的含义，而若要恢复它们原本的含义，则要在之前添加反斜杠<code>\\</code>，如<code>*、+、{、|、(</code>和<code>)</code>。</p><p><code>grep</code>命令是用来在每一个文件（或特定输出上）搜索特定的模式，当使用<code>grep</code>时，包含指定字符模式的每一行内容，都会被打印（显示）到屏幕上，但是使用<code>grep</code>命令并不改变文件中的内容。</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>grep [选项] 模式 文件名</span></span></code></pre></div><p>这里的模式，要么是字符（串），要么是正则表达式。</p><table><thead><tr><th style="text-align:center;">选项</th><th style="text-align:left;">含义</th></tr></thead><tbody><tr><td style="text-align:center;">-c, --count</td><td style="text-align:left;">仅列出文件中包含模式的行数</td></tr><tr><td style="text-align:center;">-i, --ignore-case</td><td style="text-align:left;">忽略模式中的字母大小写</td></tr><tr><td style="text-align:center;">-l, --files-with-matches</td><td style="text-align:left;">列出匹配行的文件名</td></tr><tr><td style="text-align:center;">-n, --line-number</td><td style="text-align:left;">在每一行的最前面列出行号</td></tr><tr><td style="text-align:center;">-v, --invert-match</td><td style="text-align:left;">列出没有匹配模式的行</td></tr><tr><td style="text-align:center;">-w, --word-regexp</td><td style="text-align:left;">把表达式当做一个完整的单字符来搜寻，忽略那些部分匹配的行</td></tr></tbody></table><p>注意，如果是搜索多个文件，<code>grep</code>命令的搜索结果只显示文件中发现匹配模式的文件名；而如果搜索单个文件，<code>grep</code>命令的结果将显示每一个包含匹配模式的行。</p><p>假设有一份<code>emp.data</code>员工清单，现在要搜索此文件，找出职位为<code>CLERK</code>的所有员工：</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# grep CLERK emp.data</span></span>
<span class="line"><span style="color:#BDC4CC;">#忽略输出内容</span></span></code></pre></div><p>而在此基础上，如果只想知道职位为<code>CLERK</code>的员工的人数，可以使用<code>-c</code>选项：</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# grep -c CLERK emp.data</span></span>
<span class="line"><span style="color:#BDC4CC;">#忽略输出内容</span></span></code></pre></div><p>搜索<code>emp.data</code>文件，找出以 78 开头的数据行：</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# grep ^78 emp.data</span></span>
<span class="line"><span style="color:#BDC4CC;">#忽略输出内容</span></span></code></pre></div><h2 id="管道命令符" tabindex="-1"><a class="header-anchor" href="#管道命令符"><span>管道命令符 |</span></a></h2><p>管道命令符可以将一个命令的输出作为另一个命令的输入，实现不同命令之间的数据传输与处理。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FFB757;">command1</span><span style="color:#FF9492;"> |</span><span style="color:#FFB757;"> command2</span></span></code></pre></div><p><code>command1</code>的输出会作为<code>command2</code>的输入，实现两个命令之间的数据传输。</p><h2 id="sed命令" tabindex="-1"><a class="header-anchor" href="#sed命令"><span>sed命令</span></a></h2><p><code>sed</code>会根据脚本命令来处理文本文件中的数据，这些命令要么从命令行中输入，要么存储在一个文本文件中，此命令执行数据的顺序如下：</p><ol><li>每次仅读取一行内容；</li><li>根据提供的规则命令匹配并修改数据。注意，<code>sed</code>默认不会直接修改源文件数据，而是会将数据复制到缓冲区中，修改也仅限于缓冲区中的数据；</li><li>将执行结果输出。</li></ol><p>当一行数据匹配完成后，它会继续读取下一行数据，并重复这个过程，直到将文件中所有数据处理完毕。</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FFB757;">sed</span><span style="color:#F0F3F6;"> [选项] [脚本命令] 文件名</span></span></code></pre></div><table><thead><tr><th style="text-align:center;">选项</th><th style="text-align:left;">含义</th></tr></thead><tbody><tr><td style="text-align:center;">-e</td><td style="text-align:left;">直接在命令行模式上进行 sed 动作编辑，此为默认选项</td></tr><tr><td style="text-align:center;">-f</td><td style="text-align:left;">将 sed 的动作写在一个文件内，用 –f filename 执行 filenam e内的 sed 动作</td></tr><tr><td style="text-align:center;">-n</td><td style="text-align:left;">只打印模式匹配的行</td></tr><tr><td style="text-align:center;">-i</td><td style="text-align:left;">直接修改文件内容</td></tr><tr><td style="text-align:center;">-r</td><td style="text-align:left;">支持扩展表达式</td></tr></tbody></table><h3 id="sed脚本命令" tabindex="-1"><a class="header-anchor" href="#sed脚本命令"><span>sed脚本命令</span></a></h3><h4 id="sed-s-替换脚本命令" tabindex="-1"><a class="header-anchor" href="#sed-s-替换脚本命令"><span>sed s 替换脚本命令</span></a></h4><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>[address]s/pattern/replacement/flags</span></span></code></pre></div><p>其中，<code>address</code>表示指定要操作的具体行，<code>pattern</code>指的是需要替换的内容，<code>replacement</code>指的是要替换的新内容。</p><table><thead><tr><th style="text-align:center;">flags标记</th><th style="text-align:left;">功能</th></tr></thead><tbody><tr><td style="text-align:center;">n</td><td style="text-align:left;">1~512 之间的数字，表示指定要替换的字符串出现第几次时才进行替换，例如，一行中有 3 个 A，但用户只想替换第二个 A，这是就用到这个标记</td></tr><tr><td style="text-align:center;">g</td><td style="text-align:left;">对数据中所有匹配到的内容进行替换，如果没有 g，则只会在第一次匹配成功时做替换操作。例如，一行数据中有 3 个 A，则只会替换第一个 A</td></tr><tr><td style="text-align:center;">p</td><td style="text-align:left;">会打印与替换命令中指定的模式匹配的行。此标记通常与 -n 选项一起使用</td></tr><tr><td style="text-align:center;">w file</td><td style="text-align:left;">将缓冲区中的内容写到指定的 file 文件中</td></tr><tr><td style="text-align:center;">&amp;</td><td style="text-align:left;">用正则表达式匹配的内容进行替换</td></tr><tr><td style="text-align:center;">\\n</td><td style="text-align:left;">匹配第 n 个子串，该子串之前在 pattern 中用 () 指定</td></tr><tr><td style="text-align:center;">\\</td><td style="text-align:left;">转义（转义替换部分包含：&amp;、\\ 等）</td></tr></tbody></table><p>比如，可以指定<code>sed</code>用新文本替换第几处模式匹配的地方：</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# sed </span><span style="color:#ADDCFF;">&#39;s/test/trial/2&#39;</span><span style="color:#F0F3F6;"> data4.txt</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> a</span><span style="color:#ADDCFF;"> test</span><span style="color:#ADDCFF;"> of</span><span style="color:#ADDCFF;"> the</span><span style="color:#ADDCFF;"> trial</span><span style="color:#ADDCFF;"> script.</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> the</span><span style="color:#ADDCFF;"> second</span><span style="color:#ADDCFF;"> test</span><span style="color:#ADDCFF;"> of</span><span style="color:#ADDCFF;"> the</span><span style="color:#ADDCFF;"> trial</span><span style="color:#ADDCFF;"> script.</span></span></code></pre></div><p>可以看到，使用数字 2 作为标记的结果就是，<code>sed</code>编辑器只替换每行中第 2 次出现的匹配模式。</p><p>如果要用新文件替换所有匹配的字符串，可以使用<code>g</code>标记：</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# sed </span><span style="color:#ADDCFF;">&#39;s/test/trial/g&#39;</span><span style="color:#F0F3F6;"> data4.txt</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> a</span><span style="color:#ADDCFF;"> trial</span><span style="color:#ADDCFF;"> of</span><span style="color:#ADDCFF;"> the</span><span style="color:#ADDCFF;"> trial</span><span style="color:#ADDCFF;"> script.</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> the</span><span style="color:#ADDCFF;"> second</span><span style="color:#ADDCFF;"> trial</span><span style="color:#ADDCFF;"> of</span><span style="color:#ADDCFF;"> the</span><span style="color:#ADDCFF;"> trial</span><span style="color:#ADDCFF;"> script.</span></span></code></pre></div><p>我们知道，<code>-n</code>选项会禁止<code>sed</code>输出，但<code>p</code>标记会输出修改过的行，将二者匹配使用的效果就是只输出被替换命令修改过的行，例如：</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# cat data5.txt</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> a</span><span style="color:#ADDCFF;"> test</span><span style="color:#ADDCFF;"> line.</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> a</span><span style="color:#ADDCFF;"> different</span><span style="color:#ADDCFF;"> line.</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# sed -n </span><span style="color:#ADDCFF;">&#39;s/test/trial/p&#39;</span><span style="color:#F0F3F6;"> data5.txt</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> a</span><span style="color:#ADDCFF;"> trial</span><span style="color:#ADDCFF;"> line.</span></span></code></pre></div><p><code>w</code>标记会将匹配后的结果保存到指定文件中：</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# sed </span><span style="color:#ADDCFF;">&#39;s/test/trial/w test.txt&#39;</span><span style="color:#F0F3F6;"> data5.txt</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> a</span><span style="color:#ADDCFF;"> trial</span><span style="color:#ADDCFF;"> line.</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> a</span><span style="color:#ADDCFF;"> different</span><span style="color:#ADDCFF;"> line.</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]#cat test.txt</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> a</span><span style="color:#ADDCFF;"> trial</span><span style="color:#ADDCFF;"> line.</span></span></code></pre></div><p>在使用<code>s</code>脚本命令时，替换类似文件路径的字符串会比较麻烦，需要将路径中的正斜线进行转义：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>[root@localhost ~]# sed &#39;s/\\/bin\\/bash/\\/bin\\/csh/&#39; /etc/passwd</span></span></code></pre></div><h4 id="sed-d-替换脚本命令" tabindex="-1"><a class="header-anchor" href="#sed-d-替换脚本命令"><span>sed d 替换脚本命令</span></a></h4><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>[address]d</span></span></code></pre></div><p>如果需要删除文本中的特定行，可以用<code>d</code>脚本命令，它会删除指定行中的所有内容。但使用该命令时要特别小心，如果你忘记指定具体行的话，文件中的所有内容都会被删除，举个例子：</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# cat data1.txt</span></span>
<span class="line"><span style="color:#FFB757;">The</span><span style="color:#ADDCFF;"> quick</span><span style="color:#ADDCFF;"> brown</span><span style="color:#ADDCFF;"> fox</span><span style="color:#ADDCFF;"> jumps</span><span style="color:#ADDCFF;"> over</span><span style="color:#ADDCFF;"> the</span><span style="color:#ADDCFF;"> lazy</span><span style="color:#ADDCFF;"> dog</span></span>
<span class="line"><span style="color:#FFB757;">The</span><span style="color:#ADDCFF;"> quick</span><span style="color:#ADDCFF;"> brown</span><span style="color:#ADDCFF;"> fox</span><span style="color:#ADDCFF;"> jumps</span><span style="color:#ADDCFF;"> over</span><span style="color:#ADDCFF;"> the</span><span style="color:#ADDCFF;"> lazy</span><span style="color:#ADDCFF;"> dog</span></span>
<span class="line"><span style="color:#FFB757;">The</span><span style="color:#ADDCFF;"> quick</span><span style="color:#ADDCFF;"> brown</span><span style="color:#ADDCFF;"> fox</span><span style="color:#ADDCFF;"> jumps</span><span style="color:#ADDCFF;"> over</span><span style="color:#ADDCFF;"> the</span><span style="color:#ADDCFF;"> lazy</span><span style="color:#ADDCFF;"> dog</span></span>
<span class="line"><span style="color:#FFB757;">The</span><span style="color:#ADDCFF;"> quick</span><span style="color:#ADDCFF;"> brown</span><span style="color:#ADDCFF;"> fox</span><span style="color:#ADDCFF;"> jumps</span><span style="color:#ADDCFF;"> over</span><span style="color:#ADDCFF;"> the</span><span style="color:#ADDCFF;"> lazy</span><span style="color:#ADDCFF;"> dog</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# sed </span><span style="color:#ADDCFF;">&#39;d&#39;</span><span style="color:#F0F3F6;"> data1.txt</span></span>
<span class="line"><span style="color:#BDC4CC;">#什么也不输出，证明成了空文件</span></span></code></pre></div><p>当和指定地址一起使用时，删除命令显然能发挥出大的功用。可以从数据流中删除特定的文本行。</p><p>通过行号指定，比如删除<code>data6.txt</code>文件内容中的第 3 行：</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# cat data6.txt</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> line</span><span style="color:#ADDCFF;"> number</span><span style="color:#ADDCFF;"> 1.</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> line</span><span style="color:#ADDCFF;"> number</span><span style="color:#ADDCFF;"> 2.</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> line</span><span style="color:#ADDCFF;"> number</span><span style="color:#ADDCFF;"> 3.</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> line</span><span style="color:#ADDCFF;"> number</span><span style="color:#ADDCFF;"> 4.</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# sed </span><span style="color:#ADDCFF;">&#39;3d&#39;</span><span style="color:#F0F3F6;"> data6.txt</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> line</span><span style="color:#ADDCFF;"> number</span><span style="color:#ADDCFF;"> 1.</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> line</span><span style="color:#ADDCFF;"> number</span><span style="color:#ADDCFF;"> 2.</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> line</span><span style="color:#ADDCFF;"> number</span><span style="color:#ADDCFF;"> 4.</span></span></code></pre></div><p>或者通过特定行区间指定，比如删除<code>data6.txt</code>文件内容中的第 2、3行：</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# sed </span><span style="color:#ADDCFF;">&#39;2,3d&#39;</span><span style="color:#F0F3F6;"> data6.txt</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> line</span><span style="color:#ADDCFF;"> number</span><span style="color:#ADDCFF;"> 1.</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> line</span><span style="color:#ADDCFF;"> number</span><span style="color:#ADDCFF;"> 4.</span></span></code></pre></div><p>也可以使用两个文本模式来删除某个区间内的行，但这么做时要小心，你指定的第一个模式会“打开”行删除功能，第二个模式会“关闭”行删除功能，因此，<code>sed</code>会删除两个指定行之间的所有行（包括指定的行），例如：</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]#sed </span><span style="color:#ADDCFF;">&#39;/1/,/3/d&#39;</span><span style="color:#F0F3F6;"> data6.txt</span></span>
<span class="line"><span style="color:#BDC4CC;">#删除第 1~3 行的文本数据</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> line</span><span style="color:#ADDCFF;"> number</span><span style="color:#ADDCFF;"> 4.</span></span></code></pre></div><p>或者通过特殊的文件结尾字符，比如删除<code>data6.txt</code>文件内容中第 3 行开始的所有的内容：</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# sed </span><span style="color:#ADDCFF;">&#39;3,$d&#39;</span><span style="color:#F0F3F6;"> data6.txt</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> line</span><span style="color:#ADDCFF;"> number</span><span style="color:#ADDCFF;"> 1.</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> line</span><span style="color:#ADDCFF;"> number</span><span style="color:#ADDCFF;"> 2.</span></span></code></pre></div><p>在此强调，在默认情况下<code>sed</code>并不会修改原始文件，这里被删除的行只是从<code>sed</code>的输出中消失了，原始文件没做任何改变。</p><h4 id="sed-a-和-i-脚本命令" tabindex="-1"><a class="header-anchor" href="#sed-a-和-i-脚本命令"><span>sed a 和 i 脚本命令</span></a></h4><p><code>a</code>命令表示在指定行的后面附加一行，<code>i</code>命令表示在指定行的前面插入一行，这里之所以要同时介绍这 2 个脚本命令，因为它们的基本格式完全相同，如下所示：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>[address]a（或 i）\\新文本内容</span></span></code></pre></div><p>下面分别就这 2 个命令，举几个例子。比如说，将一个新行插入到数据流第三行前，执行命令如下：</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# sed </span><span style="color:#ADDCFF;">&#39;3i\\</span></span>
<span class="line"><span style="color:#ADDCFF;">&gt; This is an inserted line.&#39;</span><span style="color:#F0F3F6;"> data6.txt</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> line</span><span style="color:#ADDCFF;"> number</span><span style="color:#ADDCFF;"> 1.</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> line</span><span style="color:#ADDCFF;"> number</span><span style="color:#ADDCFF;"> 2.</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> an</span><span style="color:#ADDCFF;"> inserted</span><span style="color:#ADDCFF;"> line.</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> line</span><span style="color:#ADDCFF;"> number</span><span style="color:#ADDCFF;"> 3.</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> line</span><span style="color:#ADDCFF;"> number</span><span style="color:#ADDCFF;"> 4.</span></span></code></pre></div><p>再比如说，将一个新行附加到数据流中第三行后，执行命令如下：</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# sed </span><span style="color:#ADDCFF;">&#39;3a\\</span></span>
<span class="line"><span style="color:#ADDCFF;">&gt; This is an appended line.&#39;</span><span style="color:#F0F3F6;"> data6.txt</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> line</span><span style="color:#ADDCFF;"> number</span><span style="color:#ADDCFF;"> 1.</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> line</span><span style="color:#ADDCFF;"> number</span><span style="color:#ADDCFF;"> 2.</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> line</span><span style="color:#ADDCFF;"> number</span><span style="color:#ADDCFF;"> 3.</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> an</span><span style="color:#ADDCFF;"> appended</span><span style="color:#ADDCFF;"> line.</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> line</span><span style="color:#ADDCFF;"> number</span><span style="color:#ADDCFF;"> 4.</span></span></code></pre></div><p>如果你想将一个多行数据添加到数据流中，只需对要插入或附加的文本中的每一行末尾（除最后一行）添加反斜线即可，例如：</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# sed </span><span style="color:#ADDCFF;">&#39;1i\\</span></span>
<span class="line"><span style="color:#ADDCFF;">&gt; This is one line of new text.\\</span></span>
<span class="line"><span style="color:#ADDCFF;">&gt; This is another line of new text.&#39;</span><span style="color:#F0F3F6;"> data6.txt</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> one</span><span style="color:#ADDCFF;"> line</span><span style="color:#ADDCFF;"> of</span><span style="color:#ADDCFF;"> new</span><span style="color:#ADDCFF;"> text.</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> another</span><span style="color:#ADDCFF;"> line</span><span style="color:#ADDCFF;"> of</span><span style="color:#ADDCFF;"> new</span><span style="color:#ADDCFF;"> text.</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> line</span><span style="color:#ADDCFF;"> number</span><span style="color:#ADDCFF;"> 1.</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> line</span><span style="color:#ADDCFF;"> number</span><span style="color:#ADDCFF;"> 2.</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> line</span><span style="color:#ADDCFF;"> number</span><span style="color:#ADDCFF;"> 3.</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> line</span><span style="color:#ADDCFF;"> number</span><span style="color:#ADDCFF;"> 4.</span></span></code></pre></div><p>可以看到，指定的两行都会被添加到数据流中。</p><h4 id="sed-c-替换脚本命令" tabindex="-1"><a class="header-anchor" href="#sed-c-替换脚本命令"><span>sed c 替换脚本命令</span></a></h4><p><code>c</code>命令表示将指定行中的所有内容，替换成该选项后面的字符串。该命令的基本格式为：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>[address]c\\用于替换的新文本</span></span></code></pre></div><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# sed </span><span style="color:#ADDCFF;">&#39;3c\\</span></span>
<span class="line"><span style="color:#ADDCFF;">&gt; This is a changed line of text.&#39;</span><span style="color:#F0F3F6;"> data6.txt</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> line</span><span style="color:#ADDCFF;"> number</span><span style="color:#ADDCFF;"> 1.</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> line</span><span style="color:#ADDCFF;"> number</span><span style="color:#ADDCFF;"> 2.</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> a</span><span style="color:#ADDCFF;"> changed</span><span style="color:#ADDCFF;"> line</span><span style="color:#ADDCFF;"> of</span><span style="color:#ADDCFF;"> text.</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> line</span><span style="color:#ADDCFF;"> number</span><span style="color:#ADDCFF;"> 4.</span></span></code></pre></div><p>在这个例子中，sed 编辑器会修改第三行中的文本，其实，下面的写法也可以实现此目的：</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# sed </span><span style="color:#ADDCFF;">&#39;/number 3/c\\</span></span>
<span class="line"><span style="color:#ADDCFF;">&gt; This is a changed line of text.&#39;</span><span style="color:#F0F3F6;"> data6.txt</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> line</span><span style="color:#ADDCFF;"> number</span><span style="color:#ADDCFF;"> 1.</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> line</span><span style="color:#ADDCFF;"> number</span><span style="color:#ADDCFF;"> 2.</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> a</span><span style="color:#ADDCFF;"> changed</span><span style="color:#ADDCFF;"> line</span><span style="color:#ADDCFF;"> of</span><span style="color:#ADDCFF;"> text.</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> line</span><span style="color:#ADDCFF;"> number</span><span style="color:#ADDCFF;"> 4.</span></span></code></pre></div><h4 id="sed-y-转换脚本命令" tabindex="-1"><a class="header-anchor" href="#sed-y-转换脚本命令"><span>sed y 转换脚本命令</span></a></h4><p><code>y</code>转换命令是唯一可以处理单个字符的<code>sed</code>脚本命令，其基本格式如下：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>[address]y/inchars/outchars/</span></span></code></pre></div><p>转换命令会对<code>inchars</code>和<code>outchars</code>值进行一对一的映射，即<code>inchars</code>中的第一个字符会被转换为<code>outchars</code>中的第一个字符，第二个字符会被转换成<code>outchars</code>中的第二个字符...这个映射过程会一直持续到处理完指定字符。如果<code>inchars</code>和<code>outchars</code>的长度不同，则<code>sed</code>会产生一条错误消息。</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# sed </span><span style="color:#ADDCFF;">&#39;y/123/789/&#39;</span><span style="color:#F0F3F6;"> data8.txt</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> line</span><span style="color:#ADDCFF;"> number</span><span style="color:#ADDCFF;"> 7.</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> line</span><span style="color:#ADDCFF;"> number</span><span style="color:#ADDCFF;"> 8.</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> line</span><span style="color:#ADDCFF;"> number</span><span style="color:#ADDCFF;"> 9.</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> line</span><span style="color:#ADDCFF;"> number</span><span style="color:#ADDCFF;"> 4.</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> line</span><span style="color:#ADDCFF;"> number</span><span style="color:#91CBFF;"> 7</span><span style="color:#ADDCFF;"> again.</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> yet</span><span style="color:#ADDCFF;"> another</span><span style="color:#ADDCFF;"> line.</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> the</span><span style="color:#ADDCFF;"> last</span><span style="color:#ADDCFF;"> line</span><span style="color:#ADDCFF;"> in</span><span style="color:#ADDCFF;"> the</span><span style="color:#ADDCFF;"> file.</span></span></code></pre></div><p>可以看到，<code>inchars</code>模式中指定字符的每个实例都会被替换成<code>outchars</code>模式中相同位置的那个字符。</p><p>转换命令是一个全局命令，也就是说，它会文本行中找到的所有指定字符自动进行转换，而不会考虑它们出现的位置，再打个比方：</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# echo </span><span style="color:#ADDCFF;">&quot;This 1 is a test of 1 try.&quot;</span><span style="color:#FF9492;"> |</span><span style="color:#FFB757;"> sed</span><span style="color:#ADDCFF;"> &#39;y/123/456/&#39;</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#91CBFF;"> 4</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> a</span><span style="color:#ADDCFF;"> test</span><span style="color:#ADDCFF;"> of</span><span style="color:#91CBFF;"> 4</span><span style="color:#ADDCFF;"> try.</span></span></code></pre></div><p><code>sed</code>转换了在文本行中匹配到的字符 1 的两个实例，我们无法限定只转换在特定地方出现的字符。</p><h4 id="sed-p-打印脚本命令" tabindex="-1"><a class="header-anchor" href="#sed-p-打印脚本命令"><span>sed p 打印脚本命令</span></a></h4><p><code>p</code>命令表示搜索符合条件的行，并输出该行的内容：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>[address]p</span></span></code></pre></div><p><code>p</code>命令常见的用法是打印包含匹配文本模式的行：</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# cat data6.txt</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> line</span><span style="color:#ADDCFF;"> number</span><span style="color:#ADDCFF;"> 1.</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> line</span><span style="color:#ADDCFF;"> number</span><span style="color:#ADDCFF;"> 2.</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> line</span><span style="color:#ADDCFF;"> number</span><span style="color:#ADDCFF;"> 3.</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> line</span><span style="color:#ADDCFF;"> number</span><span style="color:#ADDCFF;"> 4.</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# sed -n </span><span style="color:#ADDCFF;">&#39;/number 3/p&#39;</span><span style="color:#F0F3F6;"> data6.txt</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> line</span><span style="color:#ADDCFF;"> number</span><span style="color:#ADDCFF;"> 3.</span></span></code></pre></div><p>可以看到，用<code>-n</code>选项和<code>p</code>命令配合使用，我们可以禁止输出其他行，只打印包含匹配文本模式的行。</p><p>如果需要在修改之前查看行，也可以使用打印命令，比如与替换或修改命令一起使用。可以创建一个脚本在修改行之前显示该行，如下所示：</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# sed -n </span><span style="color:#ADDCFF;">&#39;/3/{</span></span>
<span class="line"><span style="color:#ADDCFF;">&gt; p</span></span>
<span class="line"><span style="color:#ADDCFF;">&gt; s/line/test/p</span></span>
<span class="line"><span style="color:#ADDCFF;">&gt; }&#39;</span><span style="color:#F0F3F6;"> data6.txt</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> line</span><span style="color:#ADDCFF;"> number</span><span style="color:#ADDCFF;"> 3.</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> test</span><span style="color:#ADDCFF;"> number</span><span style="color:#ADDCFF;"> 3.</span></span></code></pre></div><p>sed 命令会查找包含数字 3 的行，然后执行两条命令。首先，脚本用 p 命令来打印出原始行；然后它用 s 命令替换文本，并用 p 标记打印出替换结果。输出同时显示了原来的行文本和新的行文本。</p><h4 id="sed-w-脚本命令" tabindex="-1"><a class="header-anchor" href="#sed-w-脚本命令"><span>sed w 脚本命令</span></a></h4><p><code>w</code>命令用来将文本中指定行的内容写入文件中：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>[address]w filename</span></span></code></pre></div><p>这里的<code>filename</code>表示文件名，可以使用相对路径或绝对路径，但不管是哪种，运行<code>sed</code>命令的用户都必须有文件的写权限。</p><p>下面的例子是将数据流中的前两行打印到一个文本文件中：</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# sed </span><span style="color:#ADDCFF;">&#39;1,2w test.txt&#39;</span><span style="color:#F0F3F6;"> data6.txt</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> line</span><span style="color:#ADDCFF;"> number</span><span style="color:#ADDCFF;"> 1.</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> line</span><span style="color:#ADDCFF;"> number</span><span style="color:#ADDCFF;"> 2.</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> line</span><span style="color:#ADDCFF;"> number</span><span style="color:#ADDCFF;"> 3.</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> line</span><span style="color:#ADDCFF;"> number</span><span style="color:#ADDCFF;"> 4.</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# cat test.txt</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> line</span><span style="color:#ADDCFF;"> number</span><span style="color:#ADDCFF;"> 1.</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> line</span><span style="color:#ADDCFF;"> number</span><span style="color:#ADDCFF;"> 2.</span></span></code></pre></div><p>当然，如果不想让行直接输出，可以用<code>-n</code>选项：</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# cat data11.txt</span></span>
<span class="line"><span style="color:#FFB757;">Blum,</span><span style="color:#ADDCFF;"> R</span><span style="color:#ADDCFF;">       Browncoat</span></span>
<span class="line"><span style="color:#FFB757;">McGuiness,</span><span style="color:#ADDCFF;"> A</span><span style="color:#ADDCFF;">  Alliance</span></span>
<span class="line"><span style="color:#FFB757;">Bresnahan,</span><span style="color:#ADDCFF;"> C</span><span style="color:#ADDCFF;">  Browncoat</span></span>
<span class="line"><span style="color:#FFB757;">Harken,</span><span style="color:#ADDCFF;"> C</span><span style="color:#ADDCFF;">     Alliance</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# sed -n </span><span style="color:#ADDCFF;">&#39;/Browncoat/w Browncoats.txt&#39;</span><span style="color:#F0F3F6;"> data11.txt</span></span>
<span class="line"><span style="color:#FFB757;">cat</span><span style="color:#ADDCFF;"> Browncoats.txt</span></span>
<span class="line"><span style="color:#FFB757;">Blum,</span><span style="color:#ADDCFF;"> R</span><span style="color:#ADDCFF;">       Browncoat</span></span>
<span class="line"><span style="color:#FFB757;">Bresnahan,</span><span style="color:#ADDCFF;"> C</span><span style="color:#ADDCFF;">  Browncoat</span></span></code></pre></div><p>可以看到，通过使用<code>w</code>脚本命令，<code>sed</code>可以实现将包含文本模式的数据行写入目标文件。</p><h4 id="sed-r-脚本命令" tabindex="-1"><a class="header-anchor" href="#sed-r-脚本命令"><span>sed r 脚本命令</span></a></h4><p><code>r</code>命令用于将一个独立文件的数据插入到当前数据流的指定位置：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>[address]r filename</span></span></code></pre></div><p><code>sed</code>命令会将<code>filename</code>文件中的内容插入到<code>address</code>指定行的后面，比如说：</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# cat data12.txt</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> an</span><span style="color:#ADDCFF;"> added</span><span style="color:#ADDCFF;"> line.</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> the</span><span style="color:#ADDCFF;"> second</span><span style="color:#ADDCFF;"> added</span><span style="color:#ADDCFF;"> line.</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# sed </span><span style="color:#ADDCFF;">&#39;3r data12.txt&#39;</span><span style="color:#F0F3F6;"> data6.txt</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> line</span><span style="color:#ADDCFF;"> number</span><span style="color:#ADDCFF;"> 1.</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> line</span><span style="color:#ADDCFF;"> number</span><span style="color:#ADDCFF;"> 2.</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> line</span><span style="color:#ADDCFF;"> number</span><span style="color:#ADDCFF;"> 3.</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> an</span><span style="color:#ADDCFF;"> added</span><span style="color:#ADDCFF;"> line.</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> the</span><span style="color:#ADDCFF;"> second</span><span style="color:#ADDCFF;"> added</span><span style="color:#ADDCFF;"> line.</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> line</span><span style="color:#ADDCFF;"> number</span><span style="color:#ADDCFF;"> 4.</span></span></code></pre></div><p>如果你想将指定文件中的数据插入到数据流的末尾，可以使用<code>$</code>地址符，例如：</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# sed </span><span style="color:#ADDCFF;">&#39;$r data12.txt&#39;</span><span style="color:#F0F3F6;"> data6.txt</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> line</span><span style="color:#ADDCFF;"> number</span><span style="color:#ADDCFF;"> 1.</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> line</span><span style="color:#ADDCFF;"> number</span><span style="color:#ADDCFF;"> 2.</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> line</span><span style="color:#ADDCFF;"> number</span><span style="color:#ADDCFF;"> 3.</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> line</span><span style="color:#ADDCFF;"> number</span><span style="color:#ADDCFF;"> 4.</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> an</span><span style="color:#ADDCFF;"> added</span><span style="color:#ADDCFF;"> line.</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> the</span><span style="color:#ADDCFF;"> second</span><span style="color:#ADDCFF;"> added</span><span style="color:#ADDCFF;"> line.</span></span></code></pre></div><h4 id="sed-q-退出脚本命令" tabindex="-1"><a class="header-anchor" href="#sed-q-退出脚本命令"><span>sed q 退出脚本命令</span></a></h4><p><code>q</code>命令的作用是使<code>sed</code>命令在第一次匹配任务结束后，退出<code>sed</code>程序，不再进行对后续数据的处理。</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# sed </span><span style="color:#ADDCFF;">&#39;2q&#39;</span><span style="color:#F0F3F6;"> test.txt</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> line</span><span style="color:#ADDCFF;"> number</span><span style="color:#ADDCFF;"> 1.</span></span>
<span class="line"><span style="color:#FFB757;">This</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> line</span><span style="color:#ADDCFF;"> number</span><span style="color:#ADDCFF;"> 2.</span></span></code></pre></div><p>可以看到，<code>sed</code>命令在打印输出第 2 行之后，就停止了，是 q 命令造成的，再比如：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>[root@localhost ~]# sed &#39;/number 1/{ s/number 1/number 0/;q; }&#39; test.txt</span></span>
<span class="line"><span>This is line number 0.</span></span></code></pre></div><p>使用 q 命令之后，<code>sed</code>命令会在匹配到<code>number 1</code>时，将其替换成<code>number 0</code>，然后直接退出。</p><h3 id="sed-脚本命令的寻址方式" tabindex="-1"><a class="header-anchor" href="#sed-脚本命令的寻址方式"><span>sed 脚本命令的寻址方式</span></a></h3><p>对各个脚本命令来说，<code>address</code>用来表明该脚本命令作用到文本中的具体行。</p><p>默认情况下，<code>sed</code>命令会作用于文本数据的所有行。如果只想将命令作用于特定行或某些行，则必须写明<code>address</code>部分，表示的方法有以下 2 种：</p><ul><li>以数字形式指定行区间；</li><li>用文本模式指定具体行区间。</li></ul><p>以上两种形式都可以使用如下这 2 种格式，分别是：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>[address]脚本命令</span></span>
<span class="line"><span></span></span>
<span class="line"><span>或者</span></span>
<span class="line"><span></span></span>
<span class="line"><span>address {</span></span>
<span class="line"><span>    多个脚本命令</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>以上两种形式在前面例子中都有具体实例，因此这里不再做过多赘述。</p><h4 id="以数字形式指定行区间" tabindex="-1"><a class="header-anchor" href="#以数字形式指定行区间"><span>以数字形式指定行区间</span></a></h4><p>当使用数字方式的行寻址时，可以用行在文本流中的行位置来引用。<code>sed</code>会将文本流中的第一行编号为 1，然后继续按顺序为接下来的行分配行号。</p><p>在脚本命令中，指定的地址可以是单个行号，或是用起始行号、逗号以及结尾行号指定的一定区间范围内的行。这里举一个<code>sed</code>命令作用到指定行号的例子：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>[root@localhost ~]#sed &#39;2s/dog/cat/&#39; data1.txt</span></span>
<span class="line"><span>The quick brown fox jumps over the lazy dog</span></span>
<span class="line"><span>The quick brown fox jumps over the lazy cat</span></span>
<span class="line"><span>The quick brown fox jumps over the lazy dog</span></span>
<span class="line"><span>The quick brown fox jumps over the lazy dog</span></span></code></pre></div><p>可以看到，<code>sed</code>只修改地址指定的第二行的文本。下面的例子中使用了行地址区间：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>[root@localhost ~]# sed &#39;2,3s/dog/cat/&#39; data1.txt</span></span>
<span class="line"><span>The quick brown fox jumps over the lazy dog</span></span>
<span class="line"><span>The quick brown fox jumps over the lazy cat</span></span>
<span class="line"><span>The quick brown fox jumps over the lazy cat</span></span>
<span class="line"><span>The quick brown fox jumps over the lazy dog</span></span></code></pre></div><p>在此基础上，如果想将命令作用到文本中从某行开始的所有行，可以用特殊地址——美元符（<code>$</code>）：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>[root@localhost ~]# sed &#39;2,$s/dog/cat/&#39; data1.txt</span></span>
<span class="line"><span>The quick brown fox jumps over the lazy dog</span></span>
<span class="line"><span>The quick brown fox jumps over the lazy cat</span></span>
<span class="line"><span>The quick brown fox jumps over the lazy cat</span></span>
<span class="line"><span>The quick brown fox jumps over the lazy cat</span></span></code></pre></div><h4 id="用文本模式指定行区间" tabindex="-1"><a class="header-anchor" href="#用文本模式指定行区间"><span>用文本模式指定行区间</span></a></h4><p><code>sed</code>允许指定文本模式来过滤出命令要作用的行：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>/pattern/command</span></span></code></pre></div><p>注意，必须用正斜线将要指定的<code>pattern</code>封起来，<code>sed</code>会将该命令作用到包含指定文本模式的行上。</p><p>举个例子，如果你想只修改用户<code>demo</code>的默认 shell，可以使用<code>sed</code>命令，执行命令如下：</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# grep demo /etc/passwd</span></span>
<span class="line"><span style="color:#FFB757;">demo:x:502:502::/home/Samantha:/bin/bash</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# sed </span><span style="color:#ADDCFF;">&#39;/demo/s/bash/csh/&#39;</span><span style="color:#F0F3F6;"> /etc/passwd</span></span>
<span class="line"><span style="color:#FFB757;">root:x:0:0:root:/root:/bin/bash</span></span>
<span class="line"><span style="color:#91CBFF;">...</span></span>
<span class="line"><span style="color:#FFB757;">demo:x:502:502::/home/demo:/bin/csh</span></span>
<span class="line"><span style="color:#91CBFF;">...</span></span></code></pre></div><p>虽然使用固定文本模式能帮你过滤出特定的值，就跟上面这个用户名的例子一样，但其作用难免有限，因此，<code>sed</code>允许在文本模式使用正则表达式指明作用的具体行。正则表达式允许创建高级文本模式匹配表达式来匹配各种数据。这些表达式结合了一系列通配符、特殊字符以及固定文本字符来生成能够匹配几乎任何形式文本的简练模式。</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# cat test.txt</span></span>
<span class="line"><span style="color:#FF9492;">&lt;</span><span style="color:#F0F3F6;">html</span><span style="color:#FF9492;">&gt;</span></span>
<span class="line"><span style="color:#FF9492;">&lt;</span><span style="color:#F0F3F6;">title</span><span style="color:#FF9492;">&gt;</span><span style="color:#F0F3F6;">First Wed</span><span style="color:#FF9492;">&lt;</span><span style="color:#F0F3F6;">/title</span><span style="color:#FF9492;">&gt;</span></span>
<span class="line"><span style="color:#FF9492;">&lt;</span><span style="color:#F0F3F6;">body</span><span style="color:#FF9492;">&gt;</span></span>
<span class="line"><span style="color:#FFB757;">h1Helloh1</span></span>
<span class="line"><span style="color:#FFB757;">h2Helloh2</span></span>
<span class="line"><span style="color:#FFB757;">h3Helloh3</span></span>
<span class="line"><span style="color:#FF9492;">&lt;</span><span style="color:#F0F3F6;">/body</span><span style="color:#FF9492;">&gt;</span></span>
<span class="line"><span style="color:#FF9492;">&lt;</span><span style="color:#F0F3F6;">/html</span><span style="color:#FF9492;">&gt;</span></span>
<span class="line"><span style="color:#BDC4CC;">#使用正则表示式给所有第一个的h1、h2、h3添加&lt;&gt;，给第二个h1、h2、h3添加&lt;/&gt;</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# cat sed.sh</span></span>
<span class="line"><span style="color:#FFB757;">/h[0-9]/</span><span style="color:#ADDCFF;">{</span></span>
<span class="line"><span style="color:#FFB757;">    s//\\</span><span style="color:#F0F3F6;">&lt;&amp;</span><span style="color:#FFB757;">\\</span><span style="color:#F0F3F6;">&gt;</span><span style="color:#ADDCFF;">/1</span></span>
<span class="line"><span style="color:#FFB757;">    s//\\</span><span style="color:#F0F3F6;">&lt;</span><span style="color:#FF9492;">\\/</span><span style="color:#F0F3F6;">&amp;</span><span style="color:#FFB757;">\\</span><span style="color:#F0F3F6;">&gt;</span><span style="color:#ADDCFF;">/2</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# sed -f sed.sh test.txt</span></span>
<span class="line"><span style="color:#FF9492;">&lt;</span><span style="color:#F0F3F6;">h</span><span style="color:#FF9492;">1&gt;</span><span style="color:#F0F3F6;">Hello</span><span style="color:#FF9492;">&lt;</span><span style="color:#F0F3F6;">/h</span><span style="color:#FF9492;">1&gt;</span></span>
<span class="line"><span style="color:#FF9492;">&lt;</span><span style="color:#F0F3F6;">h</span><span style="color:#FF9492;">2&gt;</span><span style="color:#F0F3F6;">Hello</span><span style="color:#FF9492;">&lt;</span><span style="color:#F0F3F6;">/h</span><span style="color:#FF9492;">2&gt;</span></span>
<span class="line"><span style="color:#FF9492;">&lt;</span><span style="color:#F0F3F6;">h</span><span style="color:#FF9492;">3&gt;</span><span style="color:#F0F3F6;">Hello</span><span style="color:#FF9492;">&lt;</span><span style="color:#F0F3F6;">/h</span><span style="color:#FF9492;">3&gt;</span></span></code></pre></div><h2 id="awk命令" tabindex="-1"><a class="header-anchor" href="#awk命令"><span>awk命令</span></a></h2><p>和<code>sed</code>命令类似，<code>awk</code>命令也是逐行扫描文件（从第 1 行到最后一行），寻找含有目标文本的行，如果匹配成功，则会在该行上执行用户想要的操作；反之，则不对行做任何处理。</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>awk [选项] &#39;脚本命令&#39; 文件名</span></span></code></pre></div><table><thead><tr><th style="text-align:center;">选项</th><th style="text-align:left;">含义</th></tr></thead><tbody><tr><td style="text-align:center;">-F fs</td><td style="text-align:left;">指定以 fs 作为输入行的分隔符，awk 命令默认分隔符为空格或制表符。</td></tr><tr><td style="text-align:center;">-f file</td><td style="text-align:left;">从脚本文件中读取 awk 脚本指令，以取代直接在命令行中输入指令。</td></tr><tr><td style="text-align:center;">-v var=val</td><td style="text-align:left;">在执行处理过程之前，设置一个变量 var，并给其设备初始值为 val。</td></tr></tbody></table><p><code>awk</code>的强大之处在于脚本命令，它由 2 部分组成，分别为匹配规则和执行命令：</p><div class="language-" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>&#39;匹配规则{执行命令}&#39;</span></span></code></pre></div><p>这里的匹配规则，和<code>sed</code>命令中的<code>address</code>部分作用相同，用来指定脚本命令可以作用到文本内容中的具体行，可以使用字符串（比如<code>/demo/</code>，表示查看含有<code>demo</code>字符串的行）或者正则表达式指定。另外需要注意的是，整个脚本命令是用单引号（<code>&#39;&#39;</code>）括起，而其中的执行命令部分需要用大括号（<code>{}</code>）括起来。</p><p>在<code>awk</code>程序执行时，如果没有指定执行命令，则默认会把匹配的行输出；如果不指定匹配规则，则默认匹配文本中所有的行。</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# awk </span><span style="color:#ADDCFF;">&#39;/^$/ {print &quot;Blank line&quot;}&#39;</span><span style="color:#F0F3F6;"> test.txt</span></span></code></pre></div><p>在此命令中，<code>/^$/</code>是一个正则表达式，功能是匹配文本中的空白行，同时可以看到，执行命令使用的是<code>print</code>命令，此命令经常会使用，它的作用很简单，就是将指定的文本进行输出。因此，整个命令的功能是，如果<code>test.txt</code>有 N 个空白行，那么执行此命令会输出 N 个<code>Blank line</code>。</p><h3 id="awk-使用数据字段变量" tabindex="-1"><a class="header-anchor" href="#awk-使用数据字段变量"><span>awk 使用数据字段变量</span></a></h3><p><code>awk</code>的主要特性之一是其处理文本文件中数据的能力，它会自动给一行中的每个数据元素分配一个变量。</p><p>默认情况下，<code>awk</code>会将如下变量分配给它在文本行中发现的数据字段：</p><ul><li><code>$0</code>代表整个文本行；</li><li><code>$1</code>代表文本行中的第 1 个数据字段；</li><li><code>$2</code>代表文本行中的第 2 个数据字段；</li><li><code>$n</code>代表文本行中的第 n 个数据字段。</li></ul><p>前面说过，在<code>awk</code>中，默认的字段分隔符是任意的空白字符（例如空格或制表符）。在文本行中，每个数据字段都是通过字段分隔符划分的。<code>awk</code>在读取一行文本时，会用预定义的字段分隔符划分每个数据字段。</p><p>所以在下面的例子中，<code>awk</code>程序读取文本文件，只显示第 1 个数据字段的值：</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# cat data2.txt</span></span>
<span class="line"><span style="color:#FFB757;">One</span><span style="color:#ADDCFF;"> line</span><span style="color:#ADDCFF;"> of</span><span style="color:#ADDCFF;"> test</span><span style="color:#ADDCFF;"> text.</span></span>
<span class="line"><span style="color:#FFB757;">Two</span><span style="color:#ADDCFF;"> lines</span><span style="color:#ADDCFF;"> of</span><span style="color:#ADDCFF;"> test</span><span style="color:#ADDCFF;"> text.</span></span>
<span class="line"><span style="color:#FFB757;">Three</span><span style="color:#ADDCFF;"> lines</span><span style="color:#ADDCFF;"> of</span><span style="color:#ADDCFF;"> test</span><span style="color:#ADDCFF;"> text.</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# awk </span><span style="color:#ADDCFF;">&#39;{print $1}&#39;</span><span style="color:#F0F3F6;"> data2.txt</span></span>
<span class="line"><span style="color:#FFB757;">One</span></span>
<span class="line"><span style="color:#FFB757;">Two</span></span>
<span class="line"><span style="color:#FFB757;">Three</span></span></code></pre></div><p>该程序用<code>$1</code>字段变量来表示“仅显示每行文本的第 1 个数据字段”。当然，如果你要读取采用了其他字段分隔符的文件，可以用<code>-F</code>选项手动指定。</p><h3 id="awk-脚本命令使用多个命令" tabindex="-1"><a class="header-anchor" href="#awk-脚本命令使用多个命令"><span>awk 脚本命令使用多个命令</span></a></h3><p><code>awk</code>允许将多条命令组合成一个正常的程序。要在命令行上的程序脚本中使用多条命令，只要在命令之间放个分号即可：</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# echo </span><span style="color:#ADDCFF;">&quot;My name is Rich&quot;</span><span style="color:#FF9492;"> |</span><span style="color:#FFB757;"> awk</span><span style="color:#ADDCFF;"> &#39;{$4=&quot;Christine&quot;; print $0}&#39;</span></span>
<span class="line"><span style="color:#FFB757;">My</span><span style="color:#ADDCFF;"> name</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> Christine</span></span></code></pre></div><p>第一条命令会给字段变量<code>$4</code>赋值。第二条命令会打印整个数据字段。可以看到，<code>awk</code>程序在输出中已经将原文本中的第四个数据字段替换成了新值。</p><p>除此之外，也可以一次一行地输入程序脚本命令，比如说：</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# awk </span><span style="color:#ADDCFF;">&#39;{</span></span>
<span class="line"><span style="color:#ADDCFF;">&gt; $4=&quot;Christine&quot;</span></span>
<span class="line"><span style="color:#ADDCFF;">&gt; print $0}&#39;</span></span>
<span class="line"><span style="color:#FFB757;">My</span><span style="color:#ADDCFF;"> name</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> Rich</span></span>
<span class="line"><span style="color:#FFB757;">My</span><span style="color:#ADDCFF;"> name</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> Christine</span></span></code></pre></div><p>在你用了表示起始的单引号后，bash shell 会使用<code>&gt;</code>来提示输入更多数据，我们可以每次在每行加一条命令，直到输入了结尾的单引号。</p><p>注意，此例中因为没有在命令行中指定文件名，<code>awk</code>程序需要用户输入获得数据，因此当运行这个程序的时候，它会一直等着用户输入文本，此时如果要退出程序，只需按下<code>Ctrl+D</code>组合键即可。</p><h3 id="awk从文件中读取程序" tabindex="-1"><a class="header-anchor" href="#awk从文件中读取程序"><span>awk从文件中读取程序</span></a></h3><p>跟<code>sed</code>一样，<code>awk</code>允许将脚本命令存储到文件中，然后再在命令行中引用：</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# cat awk.sh</span></span>
<span class="line"><span style="color:#F0F3F6;">{print $1 &quot;&#39;s home directory is &quot; $6}</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# awk -F: -f awk.sh /etc/passwd</span></span>
<span class="line"><span style="color:#FFB757;">root</span><span style="color:#FFB757;">&#39;s home directory is /root</span></span>
<span class="line"><span style="color:#FFB757;">bin&#39;</span><span style="color:#FFB757;">s</span><span style="color:#ADDCFF;"> home</span><span style="color:#ADDCFF;"> directory</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> /bin</span></span>
<span class="line"><span style="color:#FFB757;">daemon</span><span style="color:#FFB757;">&#39;s home directory is /sbin</span></span>
<span class="line"><span style="color:#FFB757;">adm&#39;</span><span style="color:#FFB757;">s</span><span style="color:#ADDCFF;"> home</span><span style="color:#ADDCFF;"> directory</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> /var/adm</span></span>
<span class="line"><span style="color:#FFB757;">lp</span><span style="color:#FFB757;">&#39;s home directory is /var/spool/lpd</span></span>
<span class="line"><span style="color:#FFB757;">...</span></span>
<span class="line"><span style="color:#FFB757;">Christine&#39;</span><span style="color:#FFB757;">s</span><span style="color:#ADDCFF;"> home</span><span style="color:#ADDCFF;"> directory</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> /home/Christine</span></span>
<span class="line"><span style="color:#FFB757;">Samantha</span><span style="color:#FFB757;">&#39;s home directory is /home/Samantha</span></span>
<span class="line"><span style="color:#FFB757;">Timothy&#39;</span><span style="color:#FFB757;">s</span><span style="color:#ADDCFF;"> home</span><span style="color:#ADDCFF;"> directory</span><span style="color:#ADDCFF;"> is</span><span style="color:#ADDCFF;"> /home/Timothy</span></span></code></pre></div><p><code>awk.sh</code>脚本文件会使用<code>print</code>命令打印<code>/etc/passwd</code>文件的主目录数据字段（字段变量<code>$6</code>），以及<code>userid</code>数据字段（字段变量<code>$1</code>）。注意，在程序文件中，也可以指定多条命令，只要一条命令放一行即可，之间不需要用分号。</p><h3 id="awk-begin关键字" tabindex="-1"><a class="header-anchor" href="#awk-begin关键字"><span>awk BEGIN关键字</span></a></h3><p><code>awk</code>中还可以指定脚本命令的运行时机。默认情况下，<code>awk</code>会从输入中读取一行文本，然后针对该行的数据执行程序脚本，但有时可能需要在处理数据前运行一些脚本命令，这就需要使用<code>BEGIN</code>关键字。</p><p><code>BEGIN</code>会强制<code>awk</code>在读取数据前执行该关键字后指定的脚本命令：</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# cat data3.txt</span></span>
<span class="line"><span style="color:#FFB757;">Line</span><span style="color:#91CBFF;"> 1</span></span>
<span class="line"><span style="color:#FFB757;">Line</span><span style="color:#91CBFF;"> 2</span></span>
<span class="line"><span style="color:#FFB757;">Line</span><span style="color:#91CBFF;"> 3</span></span>
<span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# awk </span><span style="color:#ADDCFF;">&#39;BEGIN {print &quot;The data3 File Contents:&quot;}</span></span>
<span class="line"><span style="color:#ADDCFF;">&gt; {print $0}&#39;</span><span style="color:#F0F3F6;"> data3.txt</span></span>
<span class="line"><span style="color:#FFB757;">The</span><span style="color:#ADDCFF;"> data3</span><span style="color:#ADDCFF;"> File</span><span style="color:#ADDCFF;"> Contents:</span></span>
<span class="line"><span style="color:#FFB757;">Line</span><span style="color:#91CBFF;"> 1</span></span>
<span class="line"><span style="color:#FFB757;">Line</span><span style="color:#91CBFF;"> 2</span></span>
<span class="line"><span style="color:#FFB757;">Line</span><span style="color:#91CBFF;"> 3</span></span></code></pre></div><p>可以看到，这里的脚本命令中分为 2 部分，<code>BEGIN</code>部分的脚本指令会在<code>awk</code>命令处理数据前运行，而真正用来处理数据的是第二段脚本命令。</p><h3 id="awk-end关键字" tabindex="-1"><a class="header-anchor" href="#awk-end关键字"><span>awk END关键字</span></a></h3><p>和<code>BEGIN</code>关键字相对应，<code>END</code>关键字允许我们指定一些脚本命令，<code>awk</code>会在读完数据后执行它们：</p><div class="language-bash" data-highlighter="shiki" data-ext="bash" data-title="bash" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[root@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]# awk </span><span style="color:#ADDCFF;">&#39;BEGIN {print &quot;The data3 File Contents:&quot;}</span></span>
<span class="line"><span style="color:#ADDCFF;">&gt; {print $0}</span></span>
<span class="line"><span style="color:#ADDCFF;">&gt; END {print &quot;End of File&quot;}&#39;</span><span style="color:#F0F3F6;"> data3.txt</span></span>
<span class="line"><span style="color:#FFB757;">The</span><span style="color:#ADDCFF;"> data3</span><span style="color:#ADDCFF;"> File</span><span style="color:#ADDCFF;"> Contents:</span></span>
<span class="line"><span style="color:#FFB757;">Line</span><span style="color:#91CBFF;"> 1</span></span>
<span class="line"><span style="color:#FFB757;">Line</span><span style="color:#91CBFF;"> 2</span></span>
<span class="line"><span style="color:#FFB757;">Line</span><span style="color:#91CBFF;"> 3</span></span>
<span class="line"><span style="color:#FFB757;">End</span><span style="color:#ADDCFF;"> of</span><span style="color:#ADDCFF;"> File</span></span></code></pre></div><p>可以看到，当<code>awk</code>程序打印完文件内容后，才会执行<code>END</code>中的脚本命令。</p>`,253)]))}const F=a(e,[["render",o],["__file","Linux文本操作命令.html.vue"]]),d=JSON.parse('{"path":"/linux/linux%E5%9F%BA%E7%A1%80/Linux%E6%96%87%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4.html","title":"Linux文本操作命令","lang":"zh-CN","frontmatter":{"title":"Linux文本操作命令","date":"2024-06-20T00:00:00.000Z","tags":"linux基础","categories":"linux","order":4,"description":"cat：连接文件并打印输出到标准输出设备 cat命令可以用来显示文本文件的内容，也可以把几个文件内容附加到另一个文件中，即连接合并文件。 这两种格式中，前者用于显示文件的内容；后者用于连接合并文件。 注意，cat命令用于查看文件内容时，不论文件内容有多少，都会一次性显示。如果文件非常大，那么文件开头的内容就看不到了。不过 Linux 可以使用PgUp+...","head":[["meta",{"property":"og:url","content":"https://wsq01.github.io/wsq-blog/linux/linux%E5%9F%BA%E7%A1%80/Linux%E6%96%87%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4.html"}],["meta",{"property":"og:title","content":"Linux文本操作命令"}],["meta",{"property":"og:description","content":"cat：连接文件并打印输出到标准输出设备 cat命令可以用来显示文本文件的内容，也可以把几个文件内容附加到另一个文件中，即连接合并文件。 这两种格式中，前者用于显示文件的内容；后者用于连接合并文件。 注意，cat命令用于查看文件内容时，不论文件内容有多少，都会一次性显示。如果文件非常大，那么文件开头的内容就看不到了。不过 Linux 可以使用PgUp+..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-09-11T05:57:00.000Z"}],["meta",{"property":"article:published_time","content":"2024-06-20T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-09-11T05:57:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Linux文本操作命令\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-06-20T00:00:00.000Z\\",\\"dateModified\\":\\"2024-09-11T05:57:00.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"WSQ\\",\\"url\\":\\"https://wsq01.github.com\\"}]}"]]},"headers":[{"level":2,"title":"cat：连接文件并打印输出到标准输出设备","slug":"cat-连接文件并打印输出到标准输出设备","link":"#cat-连接文件并打印输出到标准输出设备","children":[]},{"level":2,"title":"more：分屏显示文件内容","slug":"more-分屏显示文件内容","link":"#more-分屏显示文件内容","children":[]},{"level":2,"title":"head：显示文件开头的内容","slug":"head-显示文件开头的内容","link":"#head-显示文件开头的内容","children":[]},{"level":2,"title":"less：查看文件内容","slug":"less-查看文件内容","link":"#less-查看文件内容","children":[]},{"level":2,"title":"tail：显示文件结尾的内容","slug":"tail-显示文件结尾的内容","link":"#tail-显示文件结尾的内容","children":[]},{"level":2,"title":"重定向（输入输出重定向）","slug":"重定向-输入输出重定向","link":"#重定向-输入输出重定向","children":[{"level":3,"title":"输入重定向","slug":"输入重定向","link":"#输入重定向","children":[]},{"level":3,"title":"输出重定向","slug":"输出重定向","link":"#输出重定向","children":[]}]},{"level":2,"title":"grep：查找文件内容","slug":"grep-查找文件内容","link":"#grep-查找文件内容","children":[]},{"level":2,"title":"管道命令符 |","slug":"管道命令符","link":"#管道命令符","children":[]},{"level":2,"title":"sed命令","slug":"sed命令","link":"#sed命令","children":[{"level":3,"title":"sed脚本命令","slug":"sed脚本命令","link":"#sed脚本命令","children":[]},{"level":3,"title":"sed 脚本命令的寻址方式","slug":"sed-脚本命令的寻址方式","link":"#sed-脚本命令的寻址方式","children":[]}]},{"level":2,"title":"awk命令","slug":"awk命令","link":"#awk命令","children":[{"level":3,"title":"awk 使用数据字段变量","slug":"awk-使用数据字段变量","link":"#awk-使用数据字段变量","children":[]},{"level":3,"title":"awk 脚本命令使用多个命令","slug":"awk-脚本命令使用多个命令","link":"#awk-脚本命令使用多个命令","children":[]},{"level":3,"title":"awk从文件中读取程序","slug":"awk从文件中读取程序","link":"#awk从文件中读取程序","children":[]},{"level":3,"title":"awk BEGIN关键字","slug":"awk-begin关键字","link":"#awk-begin关键字","children":[]},{"level":3,"title":"awk END关键字","slug":"awk-end关键字","link":"#awk-end关键字","children":[]}]}],"git":{"createdTime":1723619297000,"updatedTime":1726034220000,"contributors":[{"name":"WSQ","email":"592786982@qq.com","commits":2}]},"readingTime":{"minutes":33.15,"words":9946},"filePathRelative":"linux/linux基础/Linux文本操作命令.md","localizedDate":"2024年6月20日","autoDesc":true}');export{F as comp,d as data};
