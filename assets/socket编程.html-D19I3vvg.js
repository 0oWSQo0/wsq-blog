import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,d as o,o as l}from"./app-Coac0FJ0.js";const p={};function e(c,s){return l(),a("div",null,s[0]||(s[0]=[o(`<h2 id="socket是什么" tabindex="-1"><a class="header-anchor" href="#socket是什么"><span>socket是什么</span></a></h2><p><code>socket</code>的原意是“插座”，在计算机通信领域，<code>socket</code>被翻译为“套接字”，它是计算机之间进行通信的一种约定或一种方式。通过<code>socket</code>这种约定，一台计算机可以接收其他计算机的数据，也可以向其他计算机发送数据。</p><p>我们把插头插到插座上就能从电网获得电力供应，同样，为了与远程计算机进行数据传输，需要连接到因特网，而<code>socket</code>就是用来连接到因特网的工具。</p><p>在 UNIX/Linux 系统中，为了统一对各种硬件的操作，简化接口，不同的硬件设备也都被看成一个文件。对这些文件的操作，等同于对磁盘上普通文件的操作。</p><p>为了表示和区分已经打开的文件，UNIX/Linux 会给每个文件分配一个 ID，这个 ID 就是一个整数，被称为文件描述符（File Descriptor）。例如：</p><ul><li>通常用 0 来表示标准输入文件（stdin），它对应的硬件设备就是键盘；</li><li>通常用 1 来表示标准输出文件（stdout），它对应的硬件设备就是显示器。</li></ul><p>UNIX/Linux 程序在执行任何形式的 I/O 操作时，都是在读取或者写入一个文件描述符。一个文件描述符只是一个和打开的文件相关联的整数，它的背后可能是一个硬盘上的普通文件、FIFO、管道、终端、键盘、显示器，甚至是一个网络连接。</p><p>请注意，网络连接也是一个文件，它也有文件描述符！你必须理解这句话。</p><p>我们可以通过<code>socket()</code>函数来创建一个网络连接，或者说打开一个网络文件，<code>socket()</code>的返回值就是文件描述符。有了文件描述符，我们就可以使用普通的文件操作函数来传输数据了，例如：<br> 用<code>read()</code>读取从远程计算机传来的数据；<br> 用<code>write()</code>向远程计算机写入数据。</p><p>只要用<code>socket()</code>创建了连接，剩下的就是文件操作了，网络编程原来就是如此简单！</p><h2 id="socket有哪些类型" tabindex="-1"><a class="header-anchor" href="#socket有哪些类型"><span>socket有哪些类型</span></a></h2><p>根据数据的传输方式，可以将 Internet 套接字分成两种类型。通过<code>socket()</code>函数创建连接时，必须告诉它使用哪种数据传输方式。</p><h3 id="流格式套接字-sock-stream" tabindex="-1"><a class="header-anchor" href="#流格式套接字-sock-stream"><span>流格式套接字（SOCK_STREAM）</span></a></h3><p>流格式套接字（<code>Stream Sockets</code>）也叫“面向连接的套接字”，在代码中使用<code>SOCK_STREAM</code>表示。</p><p><code>SOCK_STREAM</code>是一种可靠的、双向的通信数据流，数据可以准确无误地到达另一台计算机，如果损坏或丢失，可以重新发送。</p><p><code>SOCK_STREAM</code>有以下几个特征：</p><ul><li>数据在传输过程中不会消失</li><li>数据是按照顺序传输的</li><li>数据的发送和接收不是同步的</li></ul><p>可以将<code>SOCK_STREAM</code>比喻成一条传送带，只要传送带本身没有问题（不会断网），就能保证数据不丢失；同时，较晚传送的数据不会先到达，较早传送的数据不会晚到达，这就保证了数据是按照顺序传递的。</p><p>为什么流格式套接字可以达到高质量的数据传输呢？这是因为它使用了 TCP 协议，TCP 协议会控制你的数据按照顺序到达并且没有错误。</p><p>那么，“数据的发送和接收不同步”该如何理解呢？</p><p>假设传送带传送的是水果，接收者需要凑齐 100 个后才能装袋，但是传送带可能把这 100 个水果分批传送，比如第一批传送 20 个，第二批传送 50 个，第三批传送 30 个。接收者不需要和传送带保持同步，只要根据自己的节奏来装袋即可，不用管传送带传送了几批，也不用每到一批就装袋一次，可以等到凑够了 100 个水果再装袋。</p><p>流格式套接字的内部有一个缓冲区（也就是字符数组），通过<code>socket</code>传输的数据将保存到这个缓冲区。接收端在收到数据后并不一定立即读取，只要数据不超过缓冲区的容量，接收端有可能在缓冲区被填满以后一次性地读取，也可能分成好几次读取。</p><p>也就是说，不管数据分几次传送过来，接收端只需要根据自己的要求读取，不用非得在数据到达时立即读取。传送端有自己的节奏，接收端也有自己的节奏，它们是不一致的。</p><p>流格式套接字有什么实际的应用场景吗？浏览器所使用的 http 协议就基于面向连接的套接字，因为必须要确保数据准确无误，否则加载的 HTML 将无法解析。</p><h3 id="数据报格式套接字-sock-dgram" tabindex="-1"><a class="header-anchor" href="#数据报格式套接字-sock-dgram"><span>数据报格式套接字（SOCK_DGRAM）</span></a></h3><p>数据报格式套接字（<code>Datagram Sockets</code>）也叫“无连接的套接字”，在代码中使用<code>SOCK_DGRAM</code>表示。</p><p>计算机只管传输数据，不作数据校验，如果数据在传输中损坏，或者没有到达另一台计算机，是没有办法补救的。也就是说，数据错了就错了，无法重传。</p><p>因为数据报套接字所做的校验工作少，所以在传输效率方面比流格式套接字要高。</p><p><code>SOCK_DGRAM</code>有以下特征：</p><ul><li>强调快速传输而非传输顺序</li><li>传输的数据可能丢失也可能损毁</li><li>限制每次传输的数据大小</li><li>数据的发送和接收是同步的</li></ul><p>总之，数据报套接字是一种不可靠的、不按顺序传递的、以追求速度为目的的套接字。</p><p>数据报套接字也使用 IP 协议作路由，但是它不使用 TCP 协议，而是使用 UDP 协议。</p><h2 id="linux下的socket演示程序" tabindex="-1"><a class="header-anchor" href="#linux下的socket演示程序"><span>Linux下的socket演示程序</span></a></h2><p>我们从一个简单的程序切入 socket 编程。<br><code>server.cpp</code>是服务器端代码，<code>client.cpp</code>是客户端代码，要实现的功能是：客户端从服务器读取一个字符串并打印出来。</p><p>服务器端代码<code>server.cpp</code>：</p><div class="language-c" data-highlighter="shiki" data-ext="c" data-title="c" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">#include</span><span style="color:#ADDCFF;"> &lt;stdio.h&gt;</span></span>
<span class="line"><span style="color:#FF9492;">#include</span><span style="color:#ADDCFF;"> &lt;string.h&gt;</span></span>
<span class="line"><span style="color:#FF9492;">#include</span><span style="color:#ADDCFF;"> &lt;stdlib.h&gt;</span></span>
<span class="line"><span style="color:#FF9492;">#include</span><span style="color:#ADDCFF;"> &lt;unistd.h&gt;</span></span>
<span class="line"><span style="color:#FF9492;">#include</span><span style="color:#ADDCFF;"> &lt;arpa/inet.h&gt;</span></span>
<span class="line"><span style="color:#FF9492;">#include</span><span style="color:#ADDCFF;"> &lt;sys/socket.h&gt;</span></span>
<span class="line"><span style="color:#FF9492;">#include</span><span style="color:#ADDCFF;"> &lt;netinet/in.h&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">int</span><span style="color:#DBB7FF;"> main</span><span style="color:#F0F3F6;">(){</span></span>
<span class="line"><span style="color:#BDC4CC;">    //创建套接字</span></span>
<span class="line"><span style="color:#FF9492;">    int</span><span style="color:#F0F3F6;"> serv_sock </span><span style="color:#FF9492;">=</span><span style="color:#DBB7FF;"> socket</span><span style="color:#F0F3F6;">(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;">    //将套接字和IP、端口绑定</span></span>
<span class="line"><span style="color:#FF9492;">    struct</span><span style="color:#F0F3F6;"> sockaddr_in serv_addr;</span></span>
<span class="line"><span style="color:#DBB7FF;">    memset</span><span style="color:#F0F3F6;">(</span><span style="color:#FF9492;">&amp;</span><span style="color:#F0F3F6;">serv_addr, </span><span style="color:#91CBFF;">0</span><span style="color:#F0F3F6;">, </span><span style="color:#FF9492;">sizeof</span><span style="color:#F0F3F6;">(serv_addr));</span><span style="color:#BDC4CC;">  //每个字节都用0填充</span></span>
<span class="line"><span style="color:#F0F3F6;">    serv_addr.sin_family </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> AF_INET;</span><span style="color:#BDC4CC;">  //使用IPv4地址</span></span>
<span class="line"><span style="color:#F0F3F6;">    serv_addr.sin_addr.s_addr </span><span style="color:#FF9492;">=</span><span style="color:#DBB7FF;"> inet_addr</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;127.0.0.1&quot;</span><span style="color:#F0F3F6;">);</span><span style="color:#BDC4CC;">  //具体的IP地址</span></span>
<span class="line"><span style="color:#F0F3F6;">    serv_addr.sin_port </span><span style="color:#FF9492;">=</span><span style="color:#DBB7FF;"> htons</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">1234</span><span style="color:#F0F3F6;">);</span><span style="color:#BDC4CC;">  //端口</span></span>
<span class="line"><span style="color:#DBB7FF;">    bind</span><span style="color:#F0F3F6;">(serv_sock, (</span><span style="color:#FF9492;">struct</span><span style="color:#F0F3F6;"> sockaddr</span><span style="color:#FF9492;">*</span><span style="color:#F0F3F6;">)</span><span style="color:#FF9492;">&amp;</span><span style="color:#F0F3F6;">serv_addr, </span><span style="color:#FF9492;">sizeof</span><span style="color:#F0F3F6;">(serv_addr));</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;">    //进入监听状态，等待用户发起请求</span></span>
<span class="line"><span style="color:#DBB7FF;">    listen</span><span style="color:#F0F3F6;">(serv_sock, </span><span style="color:#91CBFF;">20</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;">    //接收客户端请求</span></span>
<span class="line"><span style="color:#FF9492;">    struct</span><span style="color:#F0F3F6;"> sockaddr_in clnt_addr;</span></span>
<span class="line"><span style="color:#91CBFF;">    socklen_t</span><span style="color:#F0F3F6;"> clnt_addr_size </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> sizeof</span><span style="color:#F0F3F6;">(clnt_addr);</span></span>
<span class="line"><span style="color:#FF9492;">    int</span><span style="color:#F0F3F6;"> clnt_sock </span><span style="color:#FF9492;">=</span><span style="color:#DBB7FF;"> accept</span><span style="color:#F0F3F6;">(serv_sock, (</span><span style="color:#FF9492;">struct</span><span style="color:#F0F3F6;"> sockaddr</span><span style="color:#FF9492;">*</span><span style="color:#F0F3F6;">)</span><span style="color:#FF9492;">&amp;</span><span style="color:#F0F3F6;">clnt_addr, </span><span style="color:#FF9492;">&amp;</span><span style="color:#F0F3F6;">clnt_addr_size);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;">    //向客户端发送数据</span></span>
<span class="line"><span style="color:#FF9492;">    char</span><span style="color:#F0F3F6;"> str</span><span style="color:#FF9492;">[]</span><span style="color:#FF9492;"> =</span><span style="color:#ADDCFF;"> &quot;hello world&quot;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#DBB7FF;">    write</span><span style="color:#F0F3F6;">(clnt_sock, str, </span><span style="color:#FF9492;">sizeof</span><span style="color:#F0F3F6;">(str));</span></span>
<span class="line"><span style="color:#F0F3F6;">   </span></span>
<span class="line"><span style="color:#BDC4CC;">    //关闭套接字</span></span>
<span class="line"><span style="color:#DBB7FF;">    close</span><span style="color:#F0F3F6;">(clnt_sock);</span></span>
<span class="line"><span style="color:#DBB7FF;">    close</span><span style="color:#F0F3F6;">(serv_sock);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">    return</span><span style="color:#91CBFF;"> 0</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>客户端代码<code>client.cpp</code>：</p><div class="language-c" data-highlighter="shiki" data-ext="c" data-title="c" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">#include</span><span style="color:#ADDCFF;"> &lt;stdio.h&gt;</span></span>
<span class="line"><span style="color:#FF9492;">#include</span><span style="color:#ADDCFF;"> &lt;string.h&gt;</span></span>
<span class="line"><span style="color:#FF9492;">#include</span><span style="color:#ADDCFF;"> &lt;stdlib.h&gt;</span></span>
<span class="line"><span style="color:#FF9492;">#include</span><span style="color:#ADDCFF;"> &lt;unistd.h&gt;</span></span>
<span class="line"><span style="color:#FF9492;">#include</span><span style="color:#ADDCFF;"> &lt;arpa/inet.h&gt;</span></span>
<span class="line"><span style="color:#FF9492;">#include</span><span style="color:#ADDCFF;"> &lt;sys/socket.h&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">int</span><span style="color:#DBB7FF;"> main</span><span style="color:#F0F3F6;">(){</span></span>
<span class="line"><span style="color:#BDC4CC;">    //创建套接字</span></span>
<span class="line"><span style="color:#FF9492;">    int</span><span style="color:#F0F3F6;"> sock </span><span style="color:#FF9492;">=</span><span style="color:#DBB7FF;"> socket</span><span style="color:#F0F3F6;">(AF_INET, SOCK_STREAM, </span><span style="color:#91CBFF;">0</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;">    //向服务器（特定的IP和端口）发起请求</span></span>
<span class="line"><span style="color:#FF9492;">    struct</span><span style="color:#F0F3F6;"> sockaddr_in serv_addr;</span></span>
<span class="line"><span style="color:#DBB7FF;">    memset</span><span style="color:#F0F3F6;">(</span><span style="color:#FF9492;">&amp;</span><span style="color:#F0F3F6;">serv_addr, </span><span style="color:#91CBFF;">0</span><span style="color:#F0F3F6;">, </span><span style="color:#FF9492;">sizeof</span><span style="color:#F0F3F6;">(serv_addr));</span><span style="color:#BDC4CC;">  //每个字节都用0填充</span></span>
<span class="line"><span style="color:#F0F3F6;">    serv_addr.sin_family </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> AF_INET;</span><span style="color:#BDC4CC;">  //使用IPv4地址</span></span>
<span class="line"><span style="color:#F0F3F6;">    serv_addr.sin_addr.s_addr </span><span style="color:#FF9492;">=</span><span style="color:#DBB7FF;"> inet_addr</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;127.0.0.1&quot;</span><span style="color:#F0F3F6;">);</span><span style="color:#BDC4CC;">  //具体的IP地址</span></span>
<span class="line"><span style="color:#F0F3F6;">    serv_addr.sin_port </span><span style="color:#FF9492;">=</span><span style="color:#DBB7FF;"> htons</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">1234</span><span style="color:#F0F3F6;">);</span><span style="color:#BDC4CC;">  //端口</span></span>
<span class="line"><span style="color:#DBB7FF;">    connect</span><span style="color:#F0F3F6;">(sock, (</span><span style="color:#FF9492;">struct</span><span style="color:#F0F3F6;"> sockaddr</span><span style="color:#FF9492;">*</span><span style="color:#F0F3F6;">)</span><span style="color:#FF9492;">&amp;</span><span style="color:#F0F3F6;">serv_addr, </span><span style="color:#FF9492;">sizeof</span><span style="color:#F0F3F6;">(serv_addr));</span></span>
<span class="line"><span style="color:#F0F3F6;">   </span></span>
<span class="line"><span style="color:#BDC4CC;">    //读取服务器传回的数据</span></span>
<span class="line"><span style="color:#FF9492;">    char</span><span style="color:#FFB757;"> buffer</span><span style="color:#F0F3F6;">[</span><span style="color:#91CBFF;">40</span><span style="color:#F0F3F6;">];</span></span>
<span class="line"><span style="color:#DBB7FF;">    read</span><span style="color:#F0F3F6;">(sock, buffer, </span><span style="color:#FF9492;">sizeof</span><span style="color:#F0F3F6;">(buffer)</span><span style="color:#FF9492;">-</span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#F0F3F6;">   </span></span>
<span class="line"><span style="color:#DBB7FF;">    printf</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;Message form server: </span><span style="color:#FF9492;">%s\\n</span><span style="color:#ADDCFF;">&quot;</span><span style="color:#F0F3F6;">, buffer);</span></span>
<span class="line"><span style="color:#F0F3F6;">   </span></span>
<span class="line"><span style="color:#BDC4CC;">    //关闭套接字</span></span>
<span class="line"><span style="color:#DBB7FF;">    close</span><span style="color:#F0F3F6;">(sock);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">    return</span><span style="color:#91CBFF;"> 0</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>启动一个终端，编译<code>server.cpp</code>并运行：</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[admin@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]$ g++ server.cpp -o server</span></span>
<span class="line"><span style="color:#F0F3F6;">[admin@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]$ ./server</span></span>
<span class="line"><span style="color:#BDC4CC;">#等待请求的到来</span></span></code></pre></div><p>正常情况下，程序运行到<code>accept()</code>函数就会被阻塞，等待客户端发起请求。</p><p>接下再启动一个终端，编译<code>client.cpp</code>并运行：</p><div class="language-shell" data-highlighter="shiki" data-ext="shell" data-title="shell" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">[admin@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]$ g++ client.cpp -o client</span></span>
<span class="line"><span style="color:#F0F3F6;">[admin@localhost </span><span style="color:#FF9492;">~</span><span style="color:#F0F3F6;">]$ ./client</span></span>
<span class="line"><span style="color:#FFB757;">Message</span><span style="color:#ADDCFF;"> form</span><span style="color:#ADDCFF;"> server:</span><span style="color:#ADDCFF;"> hello</span><span style="color:#ADDCFF;"> world</span></span></code></pre></div><p><code>client</code>接收到从<code>server</code>发送过来的字符串就运行结束了，同时，<code>server</code>完成发送字符串的任务也运行结束了。</p><p><code>client</code>运行后，通过<code>connect()</code>函数向<code>server</code>发起请求，处于监听状态的<code>server</code>被激活，执行<code>accept()</code>函数，接受客户端的请求，然后执行<code>write()</code>函数向<code>client</code>传回数据。<code>client</code>接收到传回的数据后，<code>connect()</code>就运行结束了，然后使用<code>read()</code>将数据读取出来。</p><p><code>server</code>只接受一次<code>client</code>请求，当<code>server</code>向<code>client</code>传回数据后，程序就运行结束了。如果想再次接收到服务器的数据，必须再次运行<code>server</code>，所以这是一个非常简陋的<code>socket</code>程序，不能够一直接受客户端的请求。</p><h3 id="源码解析" tabindex="-1"><a class="header-anchor" href="#源码解析"><span>源码解析</span></a></h3><p>先说一下<code>server.cpp</code>中的代码：</p><ul><li>第 11 行通过<code>socket()</code>函数创建了一个套接字，参数<code>AF_INET</code>表示使用 IPv4 地址，<code>SOCK_STREAM</code>表示使用面向连接的套接字，<code>IPPROTO_TCP</code>表示使用 TCP 协议。在 Linux 中，<code>socket</code>也是一种文件，有文件描述符，可以使用<code>write()/read()</code>函数进行 I/O 操作。</li><li>第 19 行通过<code>bind()</code>函数将套接字<code>serv_sock</code>与特定的 IP 地址和端口绑定，IP 地址和端口都保存在<code>sockaddr_in</code>结构体中。<br><code>socket()</code>函数确定了套接字的各种属性，<code>bind()</code>函数让套接字与特定的IP地址和端口对应起来，这样客户端才能连接到该套接字。</li><li>第 22 行让套接字处于被动监听状态。所谓被动监听，是指套接字一直处于“睡眠”中，直到客户端发起请求才会被“唤醒”。</li><li>第 27 行的<code>accept()</code>函数用来接收客户端的请求。程序一旦执行到<code>accept()</code>就会被阻塞（暂停运行），直到客户端发起请求。</li><li>第 31 行的<code>write()</code>函数用来向套接字文件中写入数据，也就是向客户端发送数据。</li></ul><p>和普通文件一样，<code>socket</code>在使用完毕后也要用<code>close()</code>关闭。</p><p>再说一下<code>client.cpp</code>中的代码：</p><ul><li>第 19 行代码通过<code>connect()</code>向服务器发起请求，服务器的 IP 地址和端口号保存在<code>sockaddr_in</code>结构体中。直到服务器传回数据后，<code>connect()</code>才运行结束。</li><li>第 23 行代码通过<code>read()</code>从套接字文件中读取数据。</li></ul><h2 id="windows下的socket演示程序" tabindex="-1"><a class="header-anchor" href="#windows下的socket演示程序"><span>Windows下的socket演示程序</span></a></h2><p>服务器端代码<code>server.cpp</code>：</p><div class="language-c" data-highlighter="shiki" data-ext="c" data-title="c" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">#include</span><span style="color:#ADDCFF;"> &lt;stdio.h&gt;</span></span>
<span class="line"><span style="color:#FF9492;">#include</span><span style="color:#ADDCFF;"> &lt;winsock2.h&gt;</span></span>
<span class="line"><span style="color:#FF9492;">#pragma</span><span style="color:#91CBFF;"> comment</span><span style="color:#F0F3F6;"> (</span><span style="color:#91CBFF;">lib</span><span style="color:#F0F3F6;">, </span><span style="color:#ADDCFF;">&quot;ws2_32.lib&quot;</span><span style="color:#F0F3F6;">)  </span><span style="color:#BDC4CC;">//加载 ws2_32.dll</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">int</span><span style="color:#DBB7FF;"> main</span><span style="color:#F0F3F6;">(){</span></span>
<span class="line"><span style="color:#BDC4CC;">    //初始化 DLL</span></span>
<span class="line"><span style="color:#F0F3F6;">    WSADATA wsaData;</span></span>
<span class="line"><span style="color:#DBB7FF;">    WSAStartup</span><span style="color:#F0F3F6;">( </span><span style="color:#DBB7FF;">MAKEWORD</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">), </span><span style="color:#FF9492;">&amp;</span><span style="color:#F0F3F6;">wsaData);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;">    //创建套接字</span></span>
<span class="line"><span style="color:#F0F3F6;">    SOCKET servSock </span><span style="color:#FF9492;">=</span><span style="color:#DBB7FF;"> socket</span><span style="color:#F0F3F6;">(PF_INET, SOCK_STREAM, IPPROTO_TCP);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;">    //绑定套接字</span></span>
<span class="line"><span style="color:#FF9492;">    struct</span><span style="color:#F0F3F6;"> sockaddr_in sockAddr;</span></span>
<span class="line"><span style="color:#DBB7FF;">    memset</span><span style="color:#F0F3F6;">(</span><span style="color:#FF9492;">&amp;</span><span style="color:#F0F3F6;">sockAddr, </span><span style="color:#91CBFF;">0</span><span style="color:#F0F3F6;">, </span><span style="color:#FF9492;">sizeof</span><span style="color:#F0F3F6;">(sockAddr));</span><span style="color:#BDC4CC;">  //每个字节都用0填充</span></span>
<span class="line"><span style="color:#F0F3F6;">    sockAddr.sin_family </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> PF_INET;</span><span style="color:#BDC4CC;">  //使用IPv4地址</span></span>
<span class="line"><span style="color:#F0F3F6;">    sockAddr.sin_addr.s_addr </span><span style="color:#FF9492;">=</span><span style="color:#DBB7FF;"> inet_addr</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;127.0.0.1&quot;</span><span style="color:#F0F3F6;">);</span><span style="color:#BDC4CC;">  //具体的IP地址</span></span>
<span class="line"><span style="color:#F0F3F6;">    sockAddr.sin_port </span><span style="color:#FF9492;">=</span><span style="color:#DBB7FF;"> htons</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">1234</span><span style="color:#F0F3F6;">);</span><span style="color:#BDC4CC;">  //端口</span></span>
<span class="line"><span style="color:#DBB7FF;">    bind</span><span style="color:#F0F3F6;">(servSock, (SOCKADDR</span><span style="color:#FF9492;">*</span><span style="color:#F0F3F6;">)</span><span style="color:#FF9492;">&amp;</span><span style="color:#F0F3F6;">sockAddr, </span><span style="color:#FF9492;">sizeof</span><span style="color:#F0F3F6;">(SOCKADDR));</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;">    //进入监听状态</span></span>
<span class="line"><span style="color:#DBB7FF;">    listen</span><span style="color:#F0F3F6;">(servSock, </span><span style="color:#91CBFF;">20</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;">    //接收客户端请求</span></span>
<span class="line"><span style="color:#F0F3F6;">    SOCKADDR clntAddr;</span></span>
<span class="line"><span style="color:#FF9492;">    int</span><span style="color:#F0F3F6;"> nSize </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> sizeof</span><span style="color:#F0F3F6;">(SOCKADDR);</span></span>
<span class="line"><span style="color:#F0F3F6;">    SOCKET clntSock </span><span style="color:#FF9492;">=</span><span style="color:#DBB7FF;"> accept</span><span style="color:#F0F3F6;">(servSock, (SOCKADDR</span><span style="color:#FF9492;">*</span><span style="color:#F0F3F6;">)</span><span style="color:#FF9492;">&amp;</span><span style="color:#F0F3F6;">clntAddr, </span><span style="color:#FF9492;">&amp;</span><span style="color:#F0F3F6;">nSize);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;">    //向客户端发送数据</span></span>
<span class="line"><span style="color:#FF9492;">    char</span><span style="color:#FF9492;"> *</span><span style="color:#F0F3F6;">str </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &quot;Hello World!&quot;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#DBB7FF;">    send</span><span style="color:#F0F3F6;">(clntSock, str, </span><span style="color:#DBB7FF;">strlen</span><span style="color:#F0F3F6;">(str)</span><span style="color:#FF9492;">+sizeof</span><span style="color:#F0F3F6;">(</span><span style="color:#FF9492;">char</span><span style="color:#F0F3F6;">), </span><span style="color:#91CBFF;">NULL</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;">    //关闭套接字</span></span>
<span class="line"><span style="color:#DBB7FF;">    closesocket</span><span style="color:#F0F3F6;">(clntSock);</span></span>
<span class="line"><span style="color:#DBB7FF;">    closesocket</span><span style="color:#F0F3F6;">(servSock);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;">    //终止 DLL 的使用</span></span>
<span class="line"><span style="color:#DBB7FF;">    WSACleanup</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">    return</span><span style="color:#91CBFF;"> 0</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>客户端代码<code>client.cpp</code>：</p><div class="language-c" data-highlighter="shiki" data-ext="c" data-title="c" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">#include</span><span style="color:#ADDCFF;"> &lt;stdio.h&gt;</span></span>
<span class="line"><span style="color:#FF9492;">#include</span><span style="color:#ADDCFF;"> &lt;stdlib.h&gt;</span></span>
<span class="line"><span style="color:#FF9492;">#include</span><span style="color:#ADDCFF;"> &lt;WinSock2.h&gt;</span></span>
<span class="line"><span style="color:#FF9492;">#pragma</span><span style="color:#91CBFF;"> comment</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">lib</span><span style="color:#F0F3F6;">, </span><span style="color:#ADDCFF;">&quot;ws2_32.lib&quot;</span><span style="color:#F0F3F6;">)  </span><span style="color:#BDC4CC;">//加载 ws2_32.dll</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">int</span><span style="color:#DBB7FF;"> main</span><span style="color:#F0F3F6;">(){</span></span>
<span class="line"><span style="color:#BDC4CC;">    //初始化DLL</span></span>
<span class="line"><span style="color:#F0F3F6;">    WSADATA wsaData;</span></span>
<span class="line"><span style="color:#DBB7FF;">    WSAStartup</span><span style="color:#F0F3F6;">(</span><span style="color:#DBB7FF;">MAKEWORD</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">), </span><span style="color:#FF9492;">&amp;</span><span style="color:#F0F3F6;">wsaData);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;">    //创建套接字</span></span>
<span class="line"><span style="color:#F0F3F6;">    SOCKET sock </span><span style="color:#FF9492;">=</span><span style="color:#DBB7FF;"> socket</span><span style="color:#F0F3F6;">(PF_INET, SOCK_STREAM, IPPROTO_TCP);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;">    //向服务器发起请求</span></span>
<span class="line"><span style="color:#FF9492;">    struct</span><span style="color:#F0F3F6;"> sockaddr_in sockAddr;</span></span>
<span class="line"><span style="color:#DBB7FF;">    memset</span><span style="color:#F0F3F6;">(</span><span style="color:#FF9492;">&amp;</span><span style="color:#F0F3F6;">sockAddr, </span><span style="color:#91CBFF;">0</span><span style="color:#F0F3F6;">, </span><span style="color:#FF9492;">sizeof</span><span style="color:#F0F3F6;">(sockAddr));</span><span style="color:#BDC4CC;">  //每个字节都用0填充</span></span>
<span class="line"><span style="color:#F0F3F6;">    sockAddr.sin_family </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> PF_INET;</span></span>
<span class="line"><span style="color:#F0F3F6;">    sockAddr.sin_addr.s_addr </span><span style="color:#FF9492;">=</span><span style="color:#DBB7FF;"> inet_addr</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;127.0.0.1&quot;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#F0F3F6;">    sockAddr.sin_port </span><span style="color:#FF9492;">=</span><span style="color:#DBB7FF;"> htons</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">1234</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#DBB7FF;">    connect</span><span style="color:#F0F3F6;">(sock, (SOCKADDR</span><span style="color:#FF9492;">*</span><span style="color:#F0F3F6;">)</span><span style="color:#FF9492;">&amp;</span><span style="color:#F0F3F6;">sockAddr, </span><span style="color:#FF9492;">sizeof</span><span style="color:#F0F3F6;">(SOCKADDR));</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;">    //接收服务器传回的数据</span></span>
<span class="line"><span style="color:#FF9492;">    char</span><span style="color:#FFB757;"> szBuffer</span><span style="color:#F0F3F6;">[MAXBYTE] </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> {</span><span style="color:#91CBFF;">0</span><span style="color:#F0F3F6;">};</span></span>
<span class="line"><span style="color:#DBB7FF;">    recv</span><span style="color:#F0F3F6;">(sock, szBuffer, MAXBYTE, </span><span style="color:#91CBFF;">NULL</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;">    //输出接收到的数据</span></span>
<span class="line"><span style="color:#DBB7FF;">    printf</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;Message form server: </span><span style="color:#FF9492;">%s\\n</span><span style="color:#ADDCFF;">&quot;</span><span style="color:#F0F3F6;">, szBuffer);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;">    //关闭套接字</span></span>
<span class="line"><span style="color:#DBB7FF;">    closesocket</span><span style="color:#F0F3F6;">(sock);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;">    //终止使用 DLL</span></span>
<span class="line"><span style="color:#DBB7FF;">    WSACleanup</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#DBB7FF;">    system</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;pause&quot;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#FF9492;">    return</span><span style="color:#91CBFF;"> 0</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>将<code>server.cpp</code>和<code>client.cpp</code>分别编译为<code>server.exe</code>和<code>client.exe</code>，先运行<code>server.exe</code>，再运行<code>client.exe</code>，输出结果为：</p><div class="language-text" data-highlighter="shiki" data-ext="text" data-title="text" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span>Message form server: Hello World!</span></span></code></pre></div><p>Windows 下的<code>socket</code>程序和 Linux 思路相同，但细节有所差别：</p><ul><li>Windows 下的<code>socket</code>程序依赖<code>Winsock.dll</code>或<code>ws2_32.dll</code>，必须提前加载。</li><li>Linux 使用“文件描述符”的概念，而 Windows 使用“文件句柄”的概念；Linux 不区分<code>socket</code>文件和普通文件，而 Windows 区分；Linux 下<code>socket()</code>函数的返回值为<code>int</code>类型，而 Windows 下为<code>SOCKET</code>类型，也就是句柄。</li><li>Linux 下使用<code>read()/write()</code>函数读写，而 Windows 下使用<code>recv()/send()</code>函数发送和接收。</li><li>关闭<code>socket</code>时，Linux 使用<code>close()</code>函数，而 Windows 使用<code>closesocket()</code>函数。</li></ul><h2 id="socket-函数-创建套接字" tabindex="-1"><a class="header-anchor" href="#socket-函数-创建套接字"><span>socket()函数：创建套接字</span></a></h2><p>Linux 中的一切都是文件，每个文件都有一个整数类型的文件描述符；<code>socket</code>也是一个文件，也有文件描述符。使用<code>socket()</code>函数创建套接字以后，返回值就是一个<code>int</code>类型的文件描述符。</p><p>Windows 会区分<code>socket</code>和普通文件，它把<code>socket</code>当做一个网络连接来对待，调用<code>socket()</code>以后，返回值是<code>SOCKET</code>类型，用来表示一个套接字。</p><h3 id="linux-下的-socket-函数" tabindex="-1"><a class="header-anchor" href="#linux-下的-socket-函数"><span>Linux 下的 socket() 函数</span></a></h3><p>在 Linux 下使用<code>&lt;sys/socket.h&gt;</code>头文件中<code>socket()</code>函数来创建套接字，原型为：</p><div class="language-c" data-highlighter="shiki" data-ext="c" data-title="c" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">int</span><span style="color:#DBB7FF;"> socket</span><span style="color:#F0F3F6;">(</span><span style="color:#FF9492;">int</span><span style="color:#FFB757;"> af</span><span style="color:#F0F3F6;">, </span><span style="color:#FF9492;">int</span><span style="color:#FFB757;"> type</span><span style="color:#F0F3F6;">, </span><span style="color:#FF9492;">int</span><span style="color:#FFB757;"> protocol</span><span style="color:#F0F3F6;">);</span></span></code></pre></div><ol><li><code>af</code>为地址族，也就是 IP 地址类型，常用的有<code>AF_INET</code>和<code>AF_INET6</code>。<code>AF</code>是<code>Address Family</code>的简写，<code>INET</code>是<code>Inetnet</code>的简写。<code>AF_INET</code>表示 IPv4 地址；<code>AF_INET6</code>表示 IPv6 地址。<br> 也可以使用 PF 前缀，PF 是<code>Protocol Family</code>的简写，它和 AF 是一样的。<code>PF_INET</code>等价于<code>AF_INET</code>，<code>PF_INET6</code>等价于<code>AF_INET6</code>。</li><li><code>type</code>为数据传输方式/套接字类型，常用的有<code>SOCK_STREAM</code>（流格式套接字/面向连接的套接字） 和<code>SOCK_DGRAM</code>（数据报套接字/无连接的套接字）。</li><li><code>protocol</code>表示传输协议，常用的有<code>IPPROTO_TCP</code>和<code>IPPTOTO_UDP</code>，分别表示 TCP 传输协议和 UDP 传输协议。</li></ol><p>一般情况下有了<code>af</code>和<code>type</code>两个参数就可以创建套接字了，操作系统会自动推演出协议类型，除非遇到这样的情况：有两种不同的协议支持同一种地址类型和数据传输类型。如果我们不指明使用哪种协议，操作系统是没办法自动推演的。</p><p>使用 IPv4 地址，参数<code>af</code>的值为<code>AF_INET</code>。如果使用<code>SOCK_STREAM</code>传输数据，那么满足这两个条件的协议只有 TCP，因此可以这样来调用<code>socket()</code>函数：</p><div class="language-c" data-highlighter="shiki" data-ext="c" data-title="c" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">int</span><span style="color:#F0F3F6;"> tcp_socket </span><span style="color:#FF9492;">=</span><span style="color:#DBB7FF;"> socket</span><span style="color:#F0F3F6;">(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><span style="color:#BDC4CC;">  //IPPROTO_TCP表示TCP协议</span></span></code></pre></div><p>这种套接字称为 TCP 套接字。</p><p>如果使用<code>SOCK_DGRAM</code>传输方式，那么满足这两个条件的协议只有 UDP，因此可以这样来调用<code>socket()</code>函数：</p><div class="language-c" data-highlighter="shiki" data-ext="c" data-title="c" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">int</span><span style="color:#F0F3F6;"> udp_socket </span><span style="color:#FF9492;">=</span><span style="color:#DBB7FF;"> socket</span><span style="color:#F0F3F6;">(AF_INET, SOCK_DGRAM, IPPROTO_UDP);</span><span style="color:#BDC4CC;">  //IPPROTO_UDP表示UDP协议</span></span></code></pre></div><p>这种套接字称为 UDP 套接字。</p><p>上面两种情况都只有一种协议满足条件，可以将<code>protocol</code>的值设为 0，系统会自动推演出应该使用什么协议：</p><div class="language-c" data-highlighter="shiki" data-ext="c" data-title="c" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">int</span><span style="color:#F0F3F6;"> tcp_socket </span><span style="color:#FF9492;">=</span><span style="color:#DBB7FF;"> socket</span><span style="color:#F0F3F6;">(AF_INET, SOCK_STREAM, </span><span style="color:#91CBFF;">0</span><span style="color:#F0F3F6;">);</span><span style="color:#BDC4CC;">  //创建TCP套接字</span></span>
<span class="line"><span style="color:#FF9492;">int</span><span style="color:#F0F3F6;"> udp_socket </span><span style="color:#FF9492;">=</span><span style="color:#DBB7FF;"> socket</span><span style="color:#F0F3F6;">(AF_INET, SOCK_DGRAM, </span><span style="color:#91CBFF;">0</span><span style="color:#F0F3F6;">);</span><span style="color:#BDC4CC;">  //创建UDP套接字</span></span></code></pre></div><h3 id="在windows下创建socket" tabindex="-1"><a class="header-anchor" href="#在windows下创建socket"><span>在Windows下创建socket</span></a></h3><p>Windows 下也使用<code>socket()</code>函数来创建套接字，原型为：</p><div class="language-c" data-highlighter="shiki" data-ext="c" data-title="c" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">SOCKET </span><span style="color:#DBB7FF;">socket</span><span style="color:#F0F3F6;">(</span><span style="color:#FF9492;">int</span><span style="color:#FFB757;"> af</span><span style="color:#F0F3F6;">, </span><span style="color:#FF9492;">int</span><span style="color:#FFB757;"> type</span><span style="color:#F0F3F6;">, </span><span style="color:#FF9492;">int</span><span style="color:#FFB757;"> protocol</span><span style="color:#F0F3F6;">);</span></span></code></pre></div><p>除了返回值类型不同，其他都是相同的。Windows 不把套接字作为普通文件对待，而是返回<code>SOCKET</code>类型的句柄。</p><div class="language-c" data-highlighter="shiki" data-ext="c" data-title="c" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">SOCKET sock </span><span style="color:#FF9492;">=</span><span style="color:#DBB7FF;"> socket</span><span style="color:#F0F3F6;">(AF_INET, SOCK_STREAM, </span><span style="color:#91CBFF;">0</span><span style="color:#F0F3F6;">);</span><span style="color:#BDC4CC;">  //创建TCP套接字</span></span></code></pre></div><h2 id="bind-函数-绑定套接字" tabindex="-1"><a class="header-anchor" href="#bind-函数-绑定套接字"><span>bind()函数：绑定套接字</span></a></h2><p><code>socket()</code>函数用来创建套接字，确定套接字的各种属性，然后服务器端要用<code>bind()</code>函数将套接字与特定的 IP 地址和端口绑定起来，只有这样，流经该 IP 地址和端口的数据才能交给套接字处理。</p><p><code>bind()</code>函数的原型为：</p><div class="language-c" data-highlighter="shiki" data-ext="c" data-title="c" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">int</span><span style="color:#DBB7FF;"> bind</span><span style="color:#F0F3F6;">(</span><span style="color:#FF9492;">int</span><span style="color:#FFB757;"> sock</span><span style="color:#F0F3F6;">, </span><span style="color:#FF9492;">struct</span><span style="color:#F0F3F6;"> sockaddr </span><span style="color:#FF9492;">*</span><span style="color:#FFB757;">addr</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">socklen_t</span><span style="color:#FFB757;"> addrlen</span><span style="color:#F0F3F6;">);</span><span style="color:#BDC4CC;">  //Linux</span></span>
<span class="line"><span style="color:#FF9492;">int</span><span style="color:#DBB7FF;"> bind</span><span style="color:#F0F3F6;">(SOCKET </span><span style="color:#FFB757;">sock</span><span style="color:#F0F3F6;">, </span><span style="color:#FF9492;">const</span><span style="color:#FF9492;"> struct</span><span style="color:#F0F3F6;"> sockaddr </span><span style="color:#FF9492;">*</span><span style="color:#FFB757;">addr</span><span style="color:#F0F3F6;">, </span><span style="color:#FF9492;">int</span><span style="color:#FFB757;"> addrlen</span><span style="color:#F0F3F6;">);</span><span style="color:#BDC4CC;">  //Windows</span></span></code></pre></div><p><code>sock</code>为<code>socket</code>文件描述符，<code>addr</code>为<code>sockaddr</code>结构体变量的指针，<code>addrlen</code>为<code>addr</code>变量的大小，可由<code>sizeof()</code>计算得出。</p>`,87)]))}const r=n(p,[["render",e],["__file","socket编程.html.vue"]]),d=JSON.parse('{"path":"/computer/%E5%85%B6%E5%AE%83/socket%E7%BC%96%E7%A8%8B.html","title":"","lang":"zh-CN","frontmatter":{"description":"socket是什么 socket的原意是“插座”，在计算机通信领域，socket被翻译为“套接字”，它是计算机之间进行通信的一种约定或一种方式。通过socket这种约定，一台计算机可以接收其他计算机的数据，也可以向其他计算机发送数据。 我们把插头插到插座上就能从电网获得电力供应，同样，为了与远程计算机进行数据传输，需要连接到因特网，而socket就是用...","head":[["meta",{"property":"og:url","content":"https://wsq01.github.io/wsq-blog/computer/%E5%85%B6%E5%AE%83/socket%E7%BC%96%E7%A8%8B.html"}],["meta",{"property":"og:description","content":"socket是什么 socket的原意是“插座”，在计算机通信领域，socket被翻译为“套接字”，它是计算机之间进行通信的一种约定或一种方式。通过socket这种约定，一台计算机可以接收其他计算机的数据，也可以向其他计算机发送数据。 我们把插头插到插座上就能从电网获得电力供应，同样，为了与远程计算机进行数据传输，需要连接到因特网，而socket就是用..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-04-23T09:49:11.000Z"}],["meta",{"property":"article:modified_time","content":"2025-04-23T09:49:11.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-04-23T09:49:11.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"WSQ\\",\\"url\\":\\"https://wsq01.github.com\\"}]}"]]},"headers":[{"level":2,"title":"socket是什么","slug":"socket是什么","link":"#socket是什么","children":[]},{"level":2,"title":"socket有哪些类型","slug":"socket有哪些类型","link":"#socket有哪些类型","children":[{"level":3,"title":"流格式套接字（SOCK_STREAM）","slug":"流格式套接字-sock-stream","link":"#流格式套接字-sock-stream","children":[]},{"level":3,"title":"数据报格式套接字（SOCK_DGRAM）","slug":"数据报格式套接字-sock-dgram","link":"#数据报格式套接字-sock-dgram","children":[]}]},{"level":2,"title":"Linux下的socket演示程序","slug":"linux下的socket演示程序","link":"#linux下的socket演示程序","children":[{"level":3,"title":"源码解析","slug":"源码解析","link":"#源码解析","children":[]}]},{"level":2,"title":"Windows下的socket演示程序","slug":"windows下的socket演示程序","link":"#windows下的socket演示程序","children":[]},{"level":2,"title":"socket()函数：创建套接字","slug":"socket-函数-创建套接字","link":"#socket-函数-创建套接字","children":[{"level":3,"title":"Linux 下的 socket() 函数","slug":"linux-下的-socket-函数","link":"#linux-下的-socket-函数","children":[]},{"level":3,"title":"在Windows下创建socket","slug":"在windows下创建socket","link":"#在windows下创建socket","children":[]}]},{"level":2,"title":"bind()函数：绑定套接字","slug":"bind-函数-绑定套接字","link":"#bind-函数-绑定套接字","children":[]}],"git":{"createdTime":1745401751000,"updatedTime":1745401751000,"contributors":[{"name":"WSQ","email":"592786982@qq.com","commits":1}]},"readingTime":{"minutes":12.91,"words":3872},"filePathRelative":"computer/其它/socket编程.md","localizedDate":"2025年4月23日","autoDesc":true}');export{r as comp,d as data};
