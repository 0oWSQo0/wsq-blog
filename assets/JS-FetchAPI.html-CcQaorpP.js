import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,d as n,o}from"./app-CRBxQhNH.js";const l={};function p(c,s){return o(),e("div",null,s[0]||(s[0]=[n(`<p><code>fetch()</code>是<code>XMLHttpRequest</code>的升级版，用于在 JavaScript 脚本里面发出 HTTP 请求。浏览器原生提供这个对象。</p><h2 id="基本用法" tabindex="-1"><a class="header-anchor" href="#基本用法"><span>基本用法</span></a></h2><p><code>fetch()</code>的功能与<code>XMLHttpRequest</code>基本相同，但有三个主要的差异。</p><ol><li><code>fetch()</code>使用<code>Promise</code>，不使用回调函数，因此大大简化了写法，写起来更简洁。</li><li><code>fetch()</code>采用模块化设计，API 分散在多个对象上（<code>Response</code>对象、<code>Request</code>对象、<code>Headers</code>对象），更合理一些；相比之下，<code>XMLHttpRequest</code>的 API 设计并不是很好，输入、输出、状态都在同一个接口管理，容易写出非常混乱的代码。</li><li><code>fetch()</code>通过数据流（<code>Stream</code>对象）处理数据，可以分块读取，有利于提高网站性能表现，减少内存占用，对于请求大文件或者网速慢的场景相当有用。<code>XMLHTTPRequest</code>对象不支持数据流，所有的数据必须放在缓存里，不支持分块读取，必须等待全部拿到后，再一次性吐出来。</li></ol><p>在用法上，<code>fetch()</code>接受一个<code>URL</code>字符串作为参数，默认向该网址发出<code>GET</code>请求，返回一个<code>Promise</code>对象。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#DBB7FF;">fetch</span><span style="color:#F0F3F6;">(url)</span></span>
<span class="line"><span style="color:#F0F3F6;">  .</span><span style="color:#DBB7FF;">then</span><span style="color:#F0F3F6;">(</span><span style="color:#FF9492;">...</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#F0F3F6;">  .</span><span style="color:#DBB7FF;">catch</span><span style="color:#F0F3F6;">(</span><span style="color:#FF9492;">...</span><span style="color:#F0F3F6;">)</span></span></code></pre></div><p>下面是一个例子，从服务器获取 JSON 数据。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#DBB7FF;">fetch</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;https://api.github.com/users/ruanyf&#39;</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#F0F3F6;">  .</span><span style="color:#DBB7FF;">then</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">response</span><span style="color:#FF9492;"> =&gt;</span><span style="color:#F0F3F6;"> response.</span><span style="color:#DBB7FF;">json</span><span style="color:#F0F3F6;">())</span></span>
<span class="line"><span style="color:#F0F3F6;">  .</span><span style="color:#DBB7FF;">then</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">json</span><span style="color:#FF9492;"> =&gt;</span><span style="color:#F0F3F6;"> console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(json))</span></span>
<span class="line"><span style="color:#F0F3F6;">  .</span><span style="color:#DBB7FF;">catch</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">err</span><span style="color:#FF9492;"> =&gt;</span><span style="color:#F0F3F6;"> console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;Request Failed&#39;</span><span style="color:#F0F3F6;">, err));</span></span></code></pre></div><p>上面示例中，<code>fetch()</code>接收到的<code>response</code>是一个<code>Stream</code>对象，<code>response.json()</code>是一个异步操作，取出所有内容，并将其转为 JSON 对象。</p><p><code>Promise</code>可以使用<code>await</code>语法改写，使得语义更清晰。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">async</span><span style="color:#FF9492;"> function</span><span style="color:#DBB7FF;"> getJSON</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#FF9492;">  let</span><span style="color:#F0F3F6;"> url </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &#39;https://api.github.com/users/ruanyf&#39;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">  try</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">    let</span><span style="color:#F0F3F6;"> response </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> await</span><span style="color:#DBB7FF;"> fetch</span><span style="color:#F0F3F6;">(url);</span></span>
<span class="line"><span style="color:#FF9492;">    return</span><span style="color:#FF9492;"> await</span><span style="color:#F0F3F6;"> response.</span><span style="color:#DBB7FF;">json</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#F0F3F6;">  } </span><span style="color:#FF9492;">catch</span><span style="color:#F0F3F6;"> (error) {</span></span>
<span class="line"><span style="color:#F0F3F6;">    console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;Request Failed&#39;</span><span style="color:#F0F3F6;">, error);</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面示例中，<code>await</code>语句必须放在<code>try...catch</code>里面，这样才能捕捉异步操作中可能发生的错误。</p><h2 id="response-对象-处理-http-回应" tabindex="-1"><a class="header-anchor" href="#response-对象-处理-http-回应"><span>Response 对象：处理 HTTP 回应</span></a></h2><h3 id="response-对象的同步属性" tabindex="-1"><a class="header-anchor" href="#response-对象的同步属性"><span>Response 对象的同步属性</span></a></h3><p><code>fetch()</code>请求成功以后，得到的是一个<code>Response</code>对象。它对应服务器的 HTTP 回应。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> response</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> await</span><span style="color:#DBB7FF;"> fetch</span><span style="color:#F0F3F6;">(url);</span></span></code></pre></div><p><code>Response</code>包含的数据通过<code>Stream</code>接口异步读取，但是它还包含一些同步属性，对应 HTTP 回应的标头信息（<code>Headers</code>），可以立即读取。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">async</span><span style="color:#FF9492;"> function</span><span style="color:#DBB7FF;"> fetchText</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#FF9492;">  let</span><span style="color:#F0F3F6;"> response </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> await</span><span style="color:#DBB7FF;"> fetch</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;/readme.txt&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#F0F3F6;">  console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(response.status);</span></span>
<span class="line"><span style="color:#F0F3F6;">  console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(response.statusText);</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面示例中，<code>response.status</code>和<code>response.statusText</code>就是<code>Response</code>的同步属性，可以立即读取。</p><p>标头信息属性有下面这些。</p><ul><li><code>Response.ok</code><br><code>Response.ok</code>属性返回一个布尔值，表示请求是否成功，<code>true</code>对应 HTTP 请求的状态码 200 到 299，<code>false</code>对应其他的状态码。</li><li><code>Response.status</code><br><code>Response.status</code>属性返回一个数字，表示 HTTP 回应的状态码（例如200，表示成功请求）。</li><li><code>Response.statusText</code><br><code>Response.statusText</code>属性返回一个字符串，表示 HTTP 回应的状态信息（例如请求成功以后，服务器返回“OK”）。</li><li><code>Response.url</code><br><code>Response.url</code>属性返回请求的 URL。如果 URL 存在跳转，该属性返回的是最终 URL。</li><li><code>Response.type</code><br><code>Response.type</code>属性返回请求的类型。可能的值如下：</li><li><code>basic</code>：普通请求，即同源请求。</li><li><code>cors</code>：跨域请求。</li><li><code>error</code>：网络错误，主要用于 Service Worker。</li><li><code>opaque</code>：如果<code>fetch()</code>请求的<code>type</code>属性设为<code>no-cors</code>，就会返回这个值。表示发出的是简单的跨域请求，类似<code>&lt;form&gt;</code>表单的那种跨域请求。</li><li><code>opaqueredirect</code>：如果<code>fetch()</code>请求的<code>redirect</code>属性设为<code>manual</code>，就会返回这个值，详见请求部分。</li><li><code>Response.redirected</code><br><code>Response.redirected</code>属性返回一个布尔值，表示请求是否发生过跳转。</li></ul><h3 id="判断请求是否成功" tabindex="-1"><a class="header-anchor" href="#判断请求是否成功"><span>判断请求是否成功</span></a></h3><p><code>fetch()</code>发出请求以后，有一个很重要的注意点：只有网络错误，或者无法连接时，<code>fetch()</code>才会报错，其他情况都不会报错，而是认为请求成功。</p><p>这就是说，即使服务器返回的状态码是 4xx 或 5xx，<code>fetch()</code>也不会报错（即<code>Promise</code>不会变为<code>rejected</code>状态）。</p><p>只有通过<code>Response.status</code>属性，得到 HTTP 回应的真实状态码，才能判断请求是否成功。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">async</span><span style="color:#FF9492;"> function</span><span style="color:#DBB7FF;"> fetchText</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#FF9492;">  let</span><span style="color:#F0F3F6;"> response </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> await</span><span style="color:#DBB7FF;"> fetch</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;/readme.txt&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#FF9492;">  if</span><span style="color:#F0F3F6;"> (response.status </span><span style="color:#FF9492;">&gt;=</span><span style="color:#91CBFF;"> 200</span><span style="color:#FF9492;"> &amp;&amp;</span><span style="color:#F0F3F6;"> response.status </span><span style="color:#FF9492;">&lt;</span><span style="color:#91CBFF;"> 300</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#FF9492;">    return</span><span style="color:#FF9492;"> await</span><span style="color:#F0F3F6;"> response.</span><span style="color:#DBB7FF;">text</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#F0F3F6;">  } </span><span style="color:#FF9492;">else</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">    throw</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> Error</span><span style="color:#F0F3F6;">(response.statusText);</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面示例中，<code>response.status</code>属性只有等于 2xx （200~299），才能认定请求成功。这里不用考虑网址跳转（状态码为 3xx），因为<code>fetch()</code>会将跳转的状态码自动转为 200。</p><p>另一种方法是判断<code>response.ok</code>是否为<code>true</code>。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">if</span><span style="color:#F0F3F6;"> (response.ok) {</span></span>
<span class="line"><span style="color:#BDC4CC;">  // 请求成功</span></span>
<span class="line"><span style="color:#F0F3F6;">} </span><span style="color:#FF9492;">else</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#BDC4CC;">  // 请求失败</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><h3 id="response-headers-属性" tabindex="-1"><a class="header-anchor" href="#response-headers-属性"><span>Response.headers 属性</span></a></h3><p><code>Response</code>对象还有一个<code>Response.headers</code>属性，指向一个<code>Headers</code>对象，对应 HTTP 回应的所有标头。</p><p><code>Headers</code>对象可以使用<code>for...of</code>循环进行遍历。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> response</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> await</span><span style="color:#DBB7FF;"> fetch</span><span style="color:#F0F3F6;">(url);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">for</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> [key, value] </span><span style="color:#FF9492;">of</span><span style="color:#F0F3F6;"> response.headers) {</span></span>
<span class="line"><span style="color:#F0F3F6;">  console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">\`\${</span><span style="color:#F0F3F6;">key</span><span style="color:#ADDCFF;">} : \${</span><span style="color:#F0F3F6;">value</span><span style="color:#ADDCFF;">}\`</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;">// 或者</span></span>
<span class="line"><span style="color:#FF9492;">for</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> [key, value] </span><span style="color:#FF9492;">of</span><span style="color:#F0F3F6;"> response.headers.</span><span style="color:#DBB7FF;">entries</span><span style="color:#F0F3F6;">()) {</span></span>
<span class="line"><span style="color:#F0F3F6;">  console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">\`\${</span><span style="color:#F0F3F6;">key</span><span style="color:#ADDCFF;">} : \${</span><span style="color:#F0F3F6;">value</span><span style="color:#ADDCFF;">}\`</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p><code>Headers</code>对象提供了以下方法，用来操作标头。</p><ul><li><code>Headers.get()</code>：根据指定的键名，返回键值。</li><li><code>Headers.has()</code>： 返回一个布尔值，表示是否包含某个标头。</li><li><code>Headers.set()</code>：将指定的键名设置为新的键值，如果该键名不存在则会添加。</li><li><code>Headers.append()</code>：添加标头。</li><li><code>Headers.delete()</code>：删除标头。</li><li><code>Headers.keys()</code>：返回一个遍历器，可以依次遍历所有键名。</li><li><code>Headers.values()</code>：返回一个遍历器，可以依次遍历所有键值。</li><li><code>Headers.entries()</code>：返回一个遍历器，可以依次遍历所有键值对（[key, value]）。</li><li><code>Headers.forEach()</code>：依次遍历标头，每个标头都会执行一次参数函数。</li></ul><p>上面的有些方法可以修改标头，那是因为继承自<code>Headers</code>接口。对于 HTTP 回应来说，修改标头意义不大，况且很多标头是只读的，浏览器不允许修改。</p><p>这些方法中，最常用的是<code>response.headers.get()</code>，用于读取某个标头的值。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> response </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;">  await</span><span style="color:#DBB7FF;">  fetch</span><span style="color:#F0F3F6;">(url);</span></span>
<span class="line"><span style="color:#F0F3F6;">response.headers.</span><span style="color:#DBB7FF;">get</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;Content-Type&#39;</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#BDC4CC;">// application/json; charset=utf-8</span></span></code></pre></div><p>Headers.keys()和Headers.values()方法用来分别遍历标头的键名和键值。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">// 键名</span></span>
<span class="line"><span style="color:#FF9492;">for</span><span style="color:#F0F3F6;">(</span><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> key </span><span style="color:#FF9492;">of</span><span style="color:#F0F3F6;"> myHeaders.</span><span style="color:#DBB7FF;">keys</span><span style="color:#F0F3F6;">()) {</span></span>
<span class="line"><span style="color:#F0F3F6;">  console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(key);</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;">// 键值</span></span>
<span class="line"><span style="color:#FF9492;">for</span><span style="color:#F0F3F6;">(</span><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> value </span><span style="color:#FF9492;">of</span><span style="color:#F0F3F6;"> myHeaders.</span><span style="color:#DBB7FF;">values</span><span style="color:#F0F3F6;">()) {</span></span>
<span class="line"><span style="color:#F0F3F6;">  console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(value);</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#F0F3F6;">Headers.</span><span style="color:#DBB7FF;">forEach</span><span style="color:#F0F3F6;">()方法也可以遍历所有的键值和键名。</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> response </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> await</span><span style="color:#DBB7FF;"> fetch</span><span style="color:#F0F3F6;">(url);</span></span>
<span class="line"><span style="color:#F0F3F6;">response.headers.</span><span style="color:#DBB7FF;">forEach</span><span style="color:#F0F3F6;">(</span></span>
<span class="line"><span style="color:#F0F3F6;">  (</span><span style="color:#FFB757;">value</span><span style="color:#F0F3F6;">, </span><span style="color:#FFB757;">key</span><span style="color:#F0F3F6;">) </span><span style="color:#FF9492;">=&gt;</span><span style="color:#F0F3F6;"> console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(key, </span><span style="color:#ADDCFF;">&#39;:&#39;</span><span style="color:#F0F3F6;">, value)</span></span>
<span class="line"><span style="color:#F0F3F6;">);</span></span></code></pre></div><h3 id="读取内容的方法" tabindex="-1"><a class="header-anchor" href="#读取内容的方法"><span>读取内容的方法</span></a></h3><p><code>Response</code>对象根据服务器返回的不同类型的数据，提供了不同的读取方法。</p><ul><li><code>response.text()</code>：得到文本字符串。</li><li><code>response.json()</code>：得到 JSON 对象。</li><li><code>response.blob()</code>：得到二进制<code>Blob</code>对象。</li><li><code>response.formData()</code>：得到<code>FormData</code>表单对象。</li><li><code>response.arrayBuffer()</code>：得到二进制<code>ArrayBuffer</code>对象。</li></ul><p>上面5个读取方法都是异步的，返回的都是<code>Promise</code>对象。必须等到异步操作结束，才能得到服务器返回的完整数据。</p><h4 id="response-text" tabindex="-1"><a class="header-anchor" href="#response-text"><span>response.text()</span></a></h4><p><code>response.text()</code>可以用于获取文本数据，比如 HTML 文件。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> response</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> await</span><span style="color:#DBB7FF;"> fetch</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;/users.html&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> body</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> await</span><span style="color:#F0F3F6;"> response.</span><span style="color:#DBB7FF;">text</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#F0F3F6;">document.body.innerHTML </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> body</span></span></code></pre></div><h4 id="response-json" tabindex="-1"><a class="header-anchor" href="#response-json"><span>response.json()</span></a></h4><p><code>response.json()</code>主要用于获取服务器返回的 JSON 数据。</p><h4 id="response-formdata" tabindex="-1"><a class="header-anchor" href="#response-formdata"><span>response.formData()</span></a></h4><p><code>response.formData()</code>主要用在 Service Worker 里面，拦截用户提交的表单，修改某些数据以后，再提交给服务器。</p><h4 id="response-blob" tabindex="-1"><a class="header-anchor" href="#response-blob"><span>response.blob()</span></a></h4><p><code>response.blob()</code>用于获取二进制文件。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> response</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> await</span><span style="color:#DBB7FF;"> fetch</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;flower.jpg&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> myBlob</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> await</span><span style="color:#F0F3F6;"> response.</span><span style="color:#DBB7FF;">blob</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> objectURL</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> URL</span><span style="color:#F0F3F6;">.</span><span style="color:#DBB7FF;">createObjectURL</span><span style="color:#F0F3F6;">(myBlob);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> myImage</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> document.</span><span style="color:#DBB7FF;">querySelector</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;img&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#F0F3F6;">myImage.src </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> objectURL;</span></span></code></pre></div><p>上面示例读取图片文件<code>flower.jpg</code>，显示在网页上。</p><h4 id="response-arraybuffer" tabindex="-1"><a class="header-anchor" href="#response-arraybuffer"><span>response.arrayBuffer()</span></a></h4><p><code>response.arrayBuffer()</code>主要用于获取流媒体文件。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> audioCtx</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> new</span><span style="color:#F0F3F6;"> window.</span><span style="color:#DBB7FF;">AudioContext</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> source</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> audioCtx.</span><span style="color:#DBB7FF;">createBufferSource</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> response</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> await</span><span style="color:#DBB7FF;"> fetch</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;song.ogg&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> buffer</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> await</span><span style="color:#F0F3F6;"> response.</span><span style="color:#DBB7FF;">arrayBuffer</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> decodeData</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> await</span><span style="color:#F0F3F6;"> audioCtx.</span><span style="color:#DBB7FF;">decodeAudioData</span><span style="color:#F0F3F6;">(buffer);</span></span>
<span class="line"><span style="color:#F0F3F6;">source.buffer </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> buffer;</span></span>
<span class="line"><span style="color:#F0F3F6;">source.</span><span style="color:#DBB7FF;">connect</span><span style="color:#F0F3F6;">(audioCtx.destination);</span></span>
<span class="line"><span style="color:#F0F3F6;">source.loop </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> true</span><span style="color:#F0F3F6;">;</span></span></code></pre></div><p>上面示例是<code>response.arrayBuffer()</code>获取音频文件<code>song.ogg</code>，然后在线播放的例子。</p><h3 id="response-clone" tabindex="-1"><a class="header-anchor" href="#response-clone"><span>Response.clone()</span></a></h3><p><code>Stream</code>对象只能读取一次，读取完就没了。这意味着，前面的五个读取方法，只能使用一个，否则会报错。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> text </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;">  await</span><span style="color:#F0F3F6;"> response.</span><span style="color:#DBB7FF;">text</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> json </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;">  await</span><span style="color:#F0F3F6;"> response.</span><span style="color:#DBB7FF;">json</span><span style="color:#F0F3F6;">();  </span><span style="color:#BDC4CC;">// 报错</span></span></code></pre></div><p>上面示例先使用了<code>response.text()</code>，就把<code>Stream</code>读完了。后面再调用<code>response.json()</code>，就没有内容可读了，所以报错。</p><p><code>Response</code>对象提供<code>Response.clone()</code>方法，创建<code>Response</code>对象的副本，实现多次读取。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> response1</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> await</span><span style="color:#DBB7FF;"> fetch</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;flowers.jpg&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> response2</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> response1.</span><span style="color:#DBB7FF;">clone</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> myBlob1</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> await</span><span style="color:#F0F3F6;"> response1.</span><span style="color:#DBB7FF;">blob</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> myBlob2</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> await</span><span style="color:#F0F3F6;"> response2.</span><span style="color:#DBB7FF;">blob</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">image1.src </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> URL</span><span style="color:#F0F3F6;">.</span><span style="color:#DBB7FF;">createObjectURL</span><span style="color:#F0F3F6;">(myBlob1);</span></span>
<span class="line"><span style="color:#F0F3F6;">image2.src </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> URL</span><span style="color:#F0F3F6;">.</span><span style="color:#DBB7FF;">createObjectURL</span><span style="color:#F0F3F6;">(myBlob2);</span></span></code></pre></div><p>上面示例中，<code>response.clone()</code>复制了一份<code>Response</code>对象，然后将同一张图片读取了两次。</p><p><code>Response</code>对象还有一个<code>Response.redirect()</code>方法，用于将<code>Response</code>结果重定向到指定的 URL。该方法一般只用在 Service Worker 里面。</p><h3 id="response-body-属性" tabindex="-1"><a class="header-anchor" href="#response-body-属性"><span>Response.body 属性</span></a></h3><p><code>Response.body</code>属性是<code>Response</code>对象暴露出的底层接口，返回一个<code>ReadableStream</code>对象，供用户操作。</p><p>它可以用来分块读取内容，应用之一就是显示下载的进度。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> response</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> await</span><span style="color:#DBB7FF;"> fetch</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;flower.jpg&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> reader</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> response.body.</span><span style="color:#DBB7FF;">getReader</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">while</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">true</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#FF9492;">  const</span><span style="color:#F0F3F6;"> {</span><span style="color:#91CBFF;">done</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">value</span><span style="color:#F0F3F6;">} </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> await</span><span style="color:#F0F3F6;"> reader.</span><span style="color:#DBB7FF;">read</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">  if</span><span style="color:#F0F3F6;"> (done) {</span></span>
<span class="line"><span style="color:#FF9492;">    break</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">  console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">\`Received \${</span><span style="color:#F0F3F6;">value</span><span style="color:#ADDCFF;">.</span><span style="color:#91CBFF;">length</span><span style="color:#ADDCFF;">} bytes\`</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面示例中，<code>response.body.getReader()</code>方法返回一个遍历器。这个遍历器的<code>read()</code>方法每次返回一个对象，表示本次读取的内容块。</p><p>这个对象的<code>done</code>属性是一个布尔值，用来判断有没有读完；<code>value</code>属性是一个<code>arrayBuffer</code>数组，表示内容块的内容，而<code>value.length</code>属性是当前块的大小。</p><h2 id="fetch-的第二个参数-定制-http-请求" tabindex="-1"><a class="header-anchor" href="#fetch-的第二个参数-定制-http-请求"><span>fetch()的第二个参数：定制 HTTP 请求</span></a></h2><p><code>fetch()</code>的第一个参数是 URL，还可以接受第二个参数，作为配置对象，定制发出的 HTTP 请求。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#DBB7FF;">fetch</span><span style="color:#F0F3F6;">(url, optionObj)</span></span></code></pre></div><p>上面命令的<code>optionObj</code>就是第二个参数。</p><p>HTTP 请求的方法、标头、数据体都在这个对象里面设置。下面是一些示例。</p><h3 id="post-请求" tabindex="-1"><a class="header-anchor" href="#post-请求"><span>POST 请求</span></a></h3><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> response</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> await</span><span style="color:#DBB7FF;"> fetch</span><span style="color:#F0F3F6;">(url, {</span></span>
<span class="line"><span style="color:#F0F3F6;">  method: </span><span style="color:#ADDCFF;">&#39;POST&#39;</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#F0F3F6;">  headers: {</span></span>
<span class="line"><span style="color:#ADDCFF;">    &quot;Content-type&quot;</span><span style="color:#F0F3F6;">: </span><span style="color:#ADDCFF;">&quot;application/x-www-form-urlencoded; charset=UTF-8&quot;</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#F0F3F6;">  },</span></span>
<span class="line"><span style="color:#F0F3F6;">  body: </span><span style="color:#ADDCFF;">&#39;foo=bar&amp;lorem=ipsum&#39;</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#F0F3F6;">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> json</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> await</span><span style="color:#F0F3F6;"> response.</span><span style="color:#DBB7FF;">json</span><span style="color:#F0F3F6;">();</span></span></code></pre></div><p>上面示例中，配置对象用到了三个属性。</p><ul><li><code>method</code>：HTTP 请求的方法，POST、DELETE、PUT 都在这个属性设置。</li><li><code>headers</code>：一个对象，用来定制 HTTP 请求的标头。</li><li><code>body</code>：POST 请求的数据体。</li></ul><p>注意，有些标头不能通过<code>headers</code>属性设置，比如<code>Content-Length、Cookie、Host</code>等等。它们是由浏览器自动生成，无法修改。</p><h3 id="提交-json-数据" tabindex="-1"><a class="header-anchor" href="#提交-json-数据"><span>提交 JSON 数据</span></a></h3><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> user</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;">  { name:  </span><span style="color:#ADDCFF;">&#39;John&#39;</span><span style="color:#F0F3F6;">, surname:  </span><span style="color:#ADDCFF;">&#39;Smith&#39;</span><span style="color:#F0F3F6;">  };</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> response</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> await</span><span style="color:#DBB7FF;"> fetch</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;/article/fetch/post/user&#39;</span><span style="color:#F0F3F6;">, {</span></span>
<span class="line"><span style="color:#F0F3F6;">  method: </span><span style="color:#ADDCFF;">&#39;POST&#39;</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#F0F3F6;">  headers: {</span></span>
<span class="line"><span style="color:#ADDCFF;">   &#39;Content-Type&#39;</span><span style="color:#F0F3F6;">: </span><span style="color:#ADDCFF;">&#39;application/json;charset=utf-8&#39;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }, </span></span>
<span class="line"><span style="color:#F0F3F6;">  body: </span><span style="color:#91CBFF;">JSON</span><span style="color:#F0F3F6;">.</span><span style="color:#DBB7FF;">stringify</span><span style="color:#F0F3F6;">(user) </span></span>
<span class="line"><span style="color:#F0F3F6;">});</span></span></code></pre></div><p>上面示例中，标头<code>Content-Type</code>要设成<code>&#39;application/json;charset=utf-8&#39;</code>。因为默认发送的是纯文本，<code>Content-Type</code>的默认值是<code>&#39;text/plain;charset=UTF-8&#39;</code>。</p><h3 id="提交表单" tabindex="-1"><a class="header-anchor" href="#提交表单"><span>提交表单</span></a></h3><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> form</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> document.</span><span style="color:#DBB7FF;">querySelector</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;form&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> response</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> await</span><span style="color:#DBB7FF;"> fetch</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;/users&#39;</span><span style="color:#F0F3F6;">, {</span></span>
<span class="line"><span style="color:#F0F3F6;">  method: </span><span style="color:#ADDCFF;">&#39;POST&#39;</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#F0F3F6;">  body: </span><span style="color:#FF9492;">new</span><span style="color:#DBB7FF;"> FormData</span><span style="color:#F0F3F6;">(form)</span></span>
<span class="line"><span style="color:#F0F3F6;">})</span></span></code></pre></div><h3 id="文件上传" tabindex="-1"><a class="header-anchor" href="#文件上传"><span>文件上传</span></a></h3><p>如果表单里面有文件选择器，可以用前一个例子的写法，上传的文件包含在整个表单里面，一起提交。</p><p>另一种方法是用脚本添加文件，构造出一个表单，进行上传。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> input</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> document.</span><span style="color:#DBB7FF;">querySelector</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;input[type=&quot;file&quot;]&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> data</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> FormData</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#F0F3F6;">data.</span><span style="color:#DBB7FF;">append</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;file&#39;</span><span style="color:#F0F3F6;">, input.files[</span><span style="color:#91CBFF;">0</span><span style="color:#F0F3F6;">]);</span></span>
<span class="line"><span style="color:#F0F3F6;">data.</span><span style="color:#DBB7FF;">append</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;user&#39;</span><span style="color:#F0F3F6;">, </span><span style="color:#ADDCFF;">&#39;foo&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#DBB7FF;">fetch</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;/avatars&#39;</span><span style="color:#F0F3F6;">, {</span></span>
<span class="line"><span style="color:#F0F3F6;">  method: </span><span style="color:#ADDCFF;">&#39;POST&#39;</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#F0F3F6;">  body: data</span></span>
<span class="line"><span style="color:#F0F3F6;">});</span></span></code></pre></div><p>上传二进制文件时，不用修改标头的<code>Content-Type</code>，浏览器会自动设置。</p><h3 id="直接上传二进制数据" tabindex="-1"><a class="header-anchor" href="#直接上传二进制数据"><span>直接上传二进制数据</span></a></h3><p><code>fetch()</code>也可以直接上传二进制数据，将<code>Blob</code>或<code>arrayBuffer</code>数据放在<code>body</code>属性里面。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> blob </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> await</span><span style="color:#FF9492;"> new</span><span style="color:#91CBFF;"> Promise</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">resolve</span><span style="color:#FF9492;"> =&gt;</span></span>
<span class="line"><span style="color:#F0F3F6;">  canvasElem.</span><span style="color:#DBB7FF;">toBlob</span><span style="color:#F0F3F6;">(resolve,  </span><span style="color:#ADDCFF;">&#39;image/png&#39;</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#F0F3F6;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> response </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> await</span><span style="color:#DBB7FF;"> fetch</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;/article/fetch/post/image&#39;</span><span style="color:#F0F3F6;">, {</span></span>
<span class="line"><span style="color:#F0F3F6;">  method:  </span><span style="color:#ADDCFF;">&#39;POST&#39;</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#F0F3F6;">  body: blob</span></span>
<span class="line"><span style="color:#F0F3F6;">});</span></span></code></pre></div><h2 id="fetch-配置对象的完整-api" tabindex="-1"><a class="header-anchor" href="#fetch-配置对象的完整-api"><span>fetch()配置对象的完整 API</span></a></h2><p><code>fetch()</code>第二个参数的完整 API 如下。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> response</span><span style="color:#FF9492;"> =</span><span style="color:#DBB7FF;"> fetch</span><span style="color:#F0F3F6;">(url, {</span></span>
<span class="line"><span style="color:#F0F3F6;">  method: </span><span style="color:#ADDCFF;">&quot;GET&quot;</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#F0F3F6;">  headers: {</span></span>
<span class="line"><span style="color:#ADDCFF;">    &quot;Content-Type&quot;</span><span style="color:#F0F3F6;">: </span><span style="color:#ADDCFF;">&quot;text/plain;charset=UTF-8&quot;</span></span>
<span class="line"><span style="color:#F0F3F6;">  },</span></span>
<span class="line"><span style="color:#F0F3F6;">  body: </span><span style="color:#91CBFF;">undefined</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#F0F3F6;">  referrer: </span><span style="color:#ADDCFF;">&quot;about:client&quot;</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#F0F3F6;">  referrerPolicy: </span><span style="color:#ADDCFF;">&quot;no-referrer-when-downgrade&quot;</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#F0F3F6;">  mode: </span><span style="color:#ADDCFF;">&quot;cors&quot;</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#F0F3F6;">  credentials: </span><span style="color:#ADDCFF;">&quot;same-origin&quot;</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#F0F3F6;">  cache: </span><span style="color:#ADDCFF;">&quot;default&quot;</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#F0F3F6;">  redirect: </span><span style="color:#ADDCFF;">&quot;follow&quot;</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#F0F3F6;">  integrity: </span><span style="color:#ADDCFF;">&quot;&quot;</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#F0F3F6;">  keepalive: </span><span style="color:#91CBFF;">false</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#F0F3F6;">  signal: </span><span style="color:#91CBFF;">undefined</span></span>
<span class="line"><span style="color:#F0F3F6;">});</span></span></code></pre></div><p><code>fetch()</code>请求的底层用的是<code>Request()</code>对象的接口，参数完全一样，因此上面的 API 也是<code>Request()</code>的 API。</p><h3 id="cache" tabindex="-1"><a class="header-anchor" href="#cache"><span>cache</span></a></h3><p><code>cache</code>属性指定如何处理缓存。可能的取值如下：</p><ul><li><code>default</code>：默认值，先在缓存里面寻找匹配的请求。</li><li><code>no-store</code>：直接请求远程服务器，并且不更新缓存。</li><li><code>reload</code>：直接请求远程服务器，并且更新缓存。</li><li><code>no-cache</code>：将服务器资源跟本地缓存进行比较，有新的版本才使用服务器资源，否则使用缓存。</li><li><code>force-cache</code>：缓存优先，只有不存在缓存的情况下，才请求远程服务器。</li><li><code>only-if-cached</code>：只检查缓存，如果缓存里面不存在，将返回504错误。</li></ul><h3 id="mode" tabindex="-1"><a class="header-anchor" href="#mode"><span>mode</span></a></h3><p><code>mode</code>属性指定请求的模式。可能的取值如下：</p><ul><li><code>cors</code>：默认值，允许跨域请求。</li><li><code>same-origin</code>：只允许同源请求。</li><li><code>no-cors</code>：请求方法只限于 GET、POST 和 HEAD，并且只能使用有限的几个简单标头，不能添加跨域的复杂标头，相当于提交表单、<code>&lt;script&gt;</code>加载脚本、<code>&lt;img&gt;</code>加载图片等传统的跨域请求方法。</li></ul><h3 id="credentials" tabindex="-1"><a class="header-anchor" href="#credentials"><span>credentials</span></a></h3><p><code>credentials</code>属性指定是否发送 Cookie。可能的取值如下：</p><ul><li><code>same-origin</code>：默认值，同源请求时发送 Cookie，跨域请求时不发送。</li><li><code>include</code>：不管同源请求，还是跨域请求，一律发送 Cookie。</li><li><code>omit</code>：一律不发送。</li></ul><p>跨域请求发送 Cookie，需要将<code>credentials</code>属性设为<code>include</code>。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#DBB7FF;">fetch</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;http://another.com&#39;</span><span style="color:#F0F3F6;">, {</span></span>
<span class="line"><span style="color:#F0F3F6;">  credentials: </span><span style="color:#ADDCFF;">&quot;include&quot;</span></span>
<span class="line"><span style="color:#F0F3F6;">});</span></span></code></pre></div><h3 id="signal" tabindex="-1"><a class="header-anchor" href="#signal"><span>signal</span></a></h3><p><code>signal</code>属性指定一个<code>AbortSignal</code>实例，用于取消<code>fetch()</code>请求。</p><h3 id="keepalive" tabindex="-1"><a class="header-anchor" href="#keepalive"><span>keepalive</span></a></h3><p><code>keepalive</code>属性用于页面卸载时，告诉浏览器在后台保持连接，继续发送数据。</p><p>一个典型的场景就是，用户离开网页时，脚本向服务器提交一些用户行为的统计信息。这时，如果不用<code>keepalive</code>属性，数据可能无法发送，因为浏览器已经把页面卸载了。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">window.</span><span style="color:#DBB7FF;">onunload</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> function</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#DBB7FF;">  fetch</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;/analytics&#39;</span><span style="color:#F0F3F6;">, {</span></span>
<span class="line"><span style="color:#F0F3F6;">    method: </span><span style="color:#ADDCFF;">&#39;POST&#39;</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#F0F3F6;">    headers: {</span></span>
<span class="line"><span style="color:#ADDCFF;">      &#39;Content-Type&#39;</span><span style="color:#F0F3F6;">: </span><span style="color:#ADDCFF;">&#39;application/json&#39;</span></span>
<span class="line"><span style="color:#F0F3F6;">    },</span></span>
<span class="line"><span style="color:#F0F3F6;">    body: </span><span style="color:#91CBFF;">JSON</span><span style="color:#F0F3F6;">.</span><span style="color:#DBB7FF;">stringify</span><span style="color:#F0F3F6;">({</span></span>
<span class="line"><span style="color:#F0F3F6;">      some: </span><span style="color:#ADDCFF;">&#39;data&#39;</span></span>
<span class="line"><span style="color:#F0F3F6;">    }),</span></span>
<span class="line"><span style="color:#F0F3F6;">    keepalive: </span><span style="color:#91CBFF;">true</span></span>
<span class="line"><span style="color:#F0F3F6;">  });</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span></code></pre></div><h3 id="redirect" tabindex="-1"><a class="header-anchor" href="#redirect"><span>redirect</span></a></h3><p><code>redirect</code>属性指定 HTTP 跳转的处理方法。可能的取值如下：</p><ul><li><code>follow</code>：默认值，<code>fetch()</code>跟随 HTTP 跳转。</li><li><code>error</code>：如果发生跳转，<code>fetch()</code>就报错。</li><li><code>manual</code>：<code>fetch()</code>不跟随 HTTP 跳转，但是<code>response.url</code>属性会指向新的 URL，<code>response.redirected</code>属性会变为<code>true</code>，由开发者自己决定后续如何处理跳转。</li></ul><h3 id="integrity" tabindex="-1"><a class="header-anchor" href="#integrity"><span>integrity</span></a></h3><p><code>integrity</code>属性指定一个哈希值，用于检查 HTTP 回应传回的数据是否等于这个预先设定的哈希值。</p><p>比如，下载文件时，检查文件的 SHA-256 哈希值是否相符，确保没有被篡改。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#DBB7FF;">fetch</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;http://site.com/file&#39;</span><span style="color:#F0F3F6;">, {</span></span>
<span class="line"><span style="color:#F0F3F6;">  integrity: </span><span style="color:#ADDCFF;">&#39;sha256-abcdef&#39;</span></span>
<span class="line"><span style="color:#F0F3F6;">});</span></span></code></pre></div><h3 id="referrer" tabindex="-1"><a class="header-anchor" href="#referrer"><span>referrer</span></a></h3><p><code>referrer</code>属性用于设定<code>fetch()</code>请求的<code>referer</code>标头。</p><p>这个属性可以为任意字符串，也可以设为空字符串（即不发送<code>referer</code>标头）。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#DBB7FF;">fetch</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;/page&#39;</span><span style="color:#F0F3F6;">, {</span></span>
<span class="line"><span style="color:#F0F3F6;">  referrer: </span><span style="color:#ADDCFF;">&#39;&#39;</span></span>
<span class="line"><span style="color:#F0F3F6;">});</span></span></code></pre></div><h3 id="referrerpolicy" tabindex="-1"><a class="header-anchor" href="#referrerpolicy"><span>referrerPolicy</span></a></h3><p><code>referrerPolicy</code>属性用于设定<code>Referer</code>标头的规则。可能的取值如下：</p><ul><li><code>no-referrer-when-downgrade</code>：默认值，总是发送<code>Referer</code>标头，除非从 HTTPS 页面请求 HTTP 资源时不发送。</li><li><code>no-referrer</code>：不发送<code>Referer</code>标头。</li><li><code>origin</code>：<code>Referer</code>标头只包含域名，不包含完整的路径。</li><li><code>origin-when-cross-origin</code>：同源请求<code>Referer</code>标头包含完整的路径，跨域请求只包含域名。</li><li><code>same-origin</code>：跨域请求不发送<code>Referer</code>，同源请求发送。</li><li><code>strict-origin</code>：<code>Referer</code>标头只包含域名，HTTPS 页面请求 HTTP 资源时不发送<code>Referer</code>标头。</li><li><code>strict-origin-when-cross-origin</code>：同源请求时<code>Referer</code>标头包含完整路径，跨域请求时只包含域名，HTTPS 页面请求 HTTP 资源时不发送该标头。</li><li><code>unsafe-url</code>：不管什么情况，总是发送<code>Referer</code>标头。</li></ul><h2 id="取消fetch-请求" tabindex="-1"><a class="header-anchor" href="#取消fetch-请求"><span>取消fetch()请求</span></a></h2><p><code>fetch()</code>请求发送以后，如果中途想要取消，需要使用<code>AbortController</code>对象。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> controller </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> AbortController</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> signal </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> controller.signal;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#DBB7FF;">fetch</span><span style="color:#F0F3F6;">(url, {</span></span>
<span class="line"><span style="color:#F0F3F6;">  signal: controller.signal</span></span>
<span class="line"><span style="color:#F0F3F6;">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">signal.</span><span style="color:#DBB7FF;">addEventListener</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;abort&#39;</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#F0F3F6;">  () </span><span style="color:#FF9492;">=&gt;</span><span style="color:#F0F3F6;"> console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;abort!&#39;</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#F0F3F6;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">controller.</span><span style="color:#DBB7FF;">abort</span><span style="color:#F0F3F6;">(); </span><span style="color:#BDC4CC;">// 取消</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(signal.aborted); </span><span style="color:#BDC4CC;">// true</span></span></code></pre></div><p>上面示例中，首先新建<code>AbortController</code>实例，然后发送<code>fetch()</code>请求，配置对象的<code>signal</code>属性必须指定接收<code>AbortController</code>实例发送的信号<code>controller.signal</code>。</p><p><code>controller.abort()</code>方法用于发出取消信号。这时会触发<code>abort</code>事件，这个事件可以监听，也可以通过<code>controller.signal.aborted</code>属性判断取消信号是否已经发出。</p><p>下面是一个 1 秒后自动取消请求的例子。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> controller </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> AbortController</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#DBB7FF;">setTimeout</span><span style="color:#F0F3F6;">(() </span><span style="color:#FF9492;">=&gt;</span><span style="color:#F0F3F6;"> controller.</span><span style="color:#DBB7FF;">abort</span><span style="color:#F0F3F6;">(), </span><span style="color:#91CBFF;">1000</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">try</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  let</span><span style="color:#F0F3F6;"> response </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> await</span><span style="color:#DBB7FF;"> fetch</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;/long-operation&#39;</span><span style="color:#F0F3F6;">, {</span></span>
<span class="line"><span style="color:#F0F3F6;">    signal: controller.signal</span></span>
<span class="line"><span style="color:#F0F3F6;">  });</span></span>
<span class="line"><span style="color:#F0F3F6;">} </span><span style="color:#FF9492;">catch</span><span style="color:#F0F3F6;">(err) {</span></span>
<span class="line"><span style="color:#FF9492;">  if</span><span style="color:#F0F3F6;"> (err.name </span><span style="color:#FF9492;">==</span><span style="color:#ADDCFF;"> &#39;AbortError&#39;</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#F0F3F6;">    console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;Aborted!&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#F0F3F6;">  } </span><span style="color:#FF9492;">else</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">    throw</span><span style="color:#F0F3F6;"> err;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div>`,138)]))}const r=a(l,[["render",p],["__file","JS-FetchAPI.html.vue"]]),i=JSON.parse('{"path":"/js/%E5%9F%BA%E7%A1%80/JS-FetchAPI.html","title":"JS-FetchAPI","lang":"zh-CN","frontmatter":{"title":"JS-FetchAPI","date":"2023-03-25T00:00:00.000Z","tags":"JS基础","categories":"前端","order":5,"description":"fetch()是XMLHttpRequest的升级版，用于在 JavaScript 脚本里面发出 HTTP 请求。浏览器原生提供这个对象。 基本用法 fetch()的功能与XMLHttpRequest基本相同，但有三个主要的差异。 fetch()使用Promise，不使用回调函数，因此大大简化了写法，写起来更简洁。 fetch()采用模块化设计，API...","head":[["meta",{"property":"og:url","content":"https://0oWSQo0.github.io/wsq-blog/js/%E5%9F%BA%E7%A1%80/JS-FetchAPI.html"}],["meta",{"property":"og:title","content":"JS-FetchAPI"}],["meta",{"property":"og:description","content":"fetch()是XMLHttpRequest的升级版，用于在 JavaScript 脚本里面发出 HTTP 请求。浏览器原生提供这个对象。 基本用法 fetch()的功能与XMLHttpRequest基本相同，但有三个主要的差异。 fetch()使用Promise，不使用回调函数，因此大大简化了写法，写起来更简洁。 fetch()采用模块化设计，API..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-09-11T05:57:00.000Z"}],["meta",{"property":"article:published_time","content":"2023-03-25T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-09-11T05:57:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"JS-FetchAPI\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-03-25T00:00:00.000Z\\",\\"dateModified\\":\\"2024-09-11T05:57:00.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"WSQ\\",\\"url\\":\\"https://0oWSQo0.github.com\\"}]}"]]},"headers":[{"level":2,"title":"基本用法","slug":"基本用法","link":"#基本用法","children":[]},{"level":2,"title":"Response 对象：处理 HTTP 回应","slug":"response-对象-处理-http-回应","link":"#response-对象-处理-http-回应","children":[{"level":3,"title":"Response 对象的同步属性","slug":"response-对象的同步属性","link":"#response-对象的同步属性","children":[]},{"level":3,"title":"判断请求是否成功","slug":"判断请求是否成功","link":"#判断请求是否成功","children":[]},{"level":3,"title":"Response.headers 属性","slug":"response-headers-属性","link":"#response-headers-属性","children":[]},{"level":3,"title":"读取内容的方法","slug":"读取内容的方法","link":"#读取内容的方法","children":[]},{"level":3,"title":"Response.clone()","slug":"response-clone","link":"#response-clone","children":[]},{"level":3,"title":"Response.body 属性","slug":"response-body-属性","link":"#response-body-属性","children":[]}]},{"level":2,"title":"fetch()的第二个参数：定制 HTTP 请求","slug":"fetch-的第二个参数-定制-http-请求","link":"#fetch-的第二个参数-定制-http-请求","children":[{"level":3,"title":"POST 请求","slug":"post-请求","link":"#post-请求","children":[]},{"level":3,"title":"提交 JSON 数据","slug":"提交-json-数据","link":"#提交-json-数据","children":[]},{"level":3,"title":"提交表单","slug":"提交表单","link":"#提交表单","children":[]},{"level":3,"title":"文件上传","slug":"文件上传","link":"#文件上传","children":[]},{"level":3,"title":"直接上传二进制数据","slug":"直接上传二进制数据","link":"#直接上传二进制数据","children":[]}]},{"level":2,"title":"fetch()配置对象的完整 API","slug":"fetch-配置对象的完整-api","link":"#fetch-配置对象的完整-api","children":[{"level":3,"title":"cache","slug":"cache","link":"#cache","children":[]},{"level":3,"title":"mode","slug":"mode","link":"#mode","children":[]},{"level":3,"title":"credentials","slug":"credentials","link":"#credentials","children":[]},{"level":3,"title":"signal","slug":"signal","link":"#signal","children":[]},{"level":3,"title":"keepalive","slug":"keepalive","link":"#keepalive","children":[]},{"level":3,"title":"redirect","slug":"redirect","link":"#redirect","children":[]},{"level":3,"title":"integrity","slug":"integrity","link":"#integrity","children":[]},{"level":3,"title":"referrer","slug":"referrer","link":"#referrer","children":[]},{"level":3,"title":"referrerPolicy","slug":"referrerpolicy","link":"#referrerpolicy","children":[]}]},{"level":2,"title":"取消fetch()请求","slug":"取消fetch-请求","link":"#取消fetch-请求","children":[]}],"git":{"createdTime":1726034220000,"updatedTime":1726034220000,"contributors":[{"name":"WSQ","email":"592786982@qq.com","commits":1}]},"readingTime":{"minutes":12.58,"words":3775},"filePathRelative":"js/基础/JS-FetchAPI.md","localizedDate":"2023年3月25日","autoDesc":true}');export{r as comp,i as data};
