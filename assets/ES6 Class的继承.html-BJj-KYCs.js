import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,d as l,o as p}from"./app-Coac0FJ0.js";const o={};function e(F,s){return p(),a("div",null,s[0]||(s[0]=[l(`<h2 id="简介" tabindex="-1"><a class="header-anchor" href="#简介"><span>简介</span></a></h2><p><code>Class</code>可以通过<code>extends</code>关键字实现继承，让子类继承父类的属性和方法。<code>extends</code>的写法比 ES5 的原型链继承，要清晰和方便很多。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Point</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> ColorPoint</span><span style="color:#FF9492;"> extends</span><span style="color:#91CBFF;"> Point</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面示例中，<code>Point</code>是父类，<code>ColorPoint</code>是子类，它通过<code>extends</code>关键字，继承了<code>Point</code>类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个<code>Point</code>类。</p><p>下面，我们在<code>ColorPoint</code>内部加上代码。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Point</span><span style="color:#F0F3F6;"> { </span><span style="color:#BDC4CC;">/* ... */</span><span style="color:#F0F3F6;"> }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> ColorPoint</span><span style="color:#FF9492;"> extends</span><span style="color:#91CBFF;"> Point</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  constructor</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">x</span><span style="color:#F0F3F6;">, </span><span style="color:#FFB757;">y</span><span style="color:#F0F3F6;">, </span><span style="color:#FFB757;">color</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#91CBFF;">    super</span><span style="color:#F0F3F6;">(x, y); </span><span style="color:#BDC4CC;">// 调用父类的constructor(x, y)</span></span>
<span class="line"><span style="color:#91CBFF;">    this</span><span style="color:#F0F3F6;">.color </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> color;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#DBB7FF;">  toString</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#FF9492;">    return</span><span style="color:#91CBFF;"> this</span><span style="color:#F0F3F6;">.color </span><span style="color:#FF9492;">+</span><span style="color:#ADDCFF;"> &#39; &#39;</span><span style="color:#FF9492;"> +</span><span style="color:#91CBFF;"> super</span><span style="color:#F0F3F6;">.</span><span style="color:#DBB7FF;">toString</span><span style="color:#F0F3F6;">(); </span><span style="color:#BDC4CC;">// 调用父类的toString()</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面示例中，<code>constructor()</code>方法和<code>toString()</code>方法内部，都出现了<code>super</code>关键字。<code>super</code>在这里表示父类的构造函数，用来新建一个父类的实例对象。</p><p>ES6 规定，子类必须在<code>constructor()</code>方法中调用<code>super()</code>，否则就会报错。这是因为子类自己的<code>this</code>对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，添加子类自己的实例属性和方法。如果不调用<code>super()</code>方法，子类就得不到自己的<code>this</code>对象。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Point</span><span style="color:#F0F3F6;"> { </span><span style="color:#BDC4CC;">/* ... */</span><span style="color:#F0F3F6;"> }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> ColorPoint</span><span style="color:#FF9492;"> extends</span><span style="color:#91CBFF;"> Point</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  constructor</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> cp </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> ColorPoint</span><span style="color:#F0F3F6;">(); </span><span style="color:#BDC4CC;">// ReferenceError</span></span></code></pre></div><p>上面代码中，<code>ColorPoint</code>继承了父类<code>Point</code>，但是它的构造函数没有调用<code>super()</code>，导致新建实例时报错。</p><p>为什么子类的构造函数，一定要调用<code>super()</code>？原因就在于 ES6 的继承机制，与 ES5 完全不同。ES5 的继承机制，是先创造一个独立的子类的实例对象，然后再将父类的方法添加到这个对象上面，即“实例在前，继承在后”。ES6 的继承机制，则是先将父类的属性和方法，加到一个空的对象上面，然后再将该对象作为子类的实例，即“继承在前，实例在后”。这就是为什么 ES6 的继承必须先调用<code>super()</code>方法，因为这一步会生成一个继承父类的<code>this</code>对象，没有这一步就无法继承父类。</p><p>注意，这意味着新建子类实例时，父类的构造函数必定会先运行一次。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Foo</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  constructor</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#F0F3F6;">    console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Bar</span><span style="color:#FF9492;"> extends</span><span style="color:#91CBFF;"> Foo</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  constructor</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#91CBFF;">    super</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#F0F3F6;">    console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> bar</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> Bar</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#BDC4CC;">// 1</span></span>
<span class="line"><span style="color:#BDC4CC;">// 2</span></span></code></pre></div><p>上面示例中，子类<code>Bar</code>新建实例时，会输出 1 和 2。原因就是子类构造函数调用<code>super()</code>时，会执行一次父类构造函数。</p><p>另一个需要注意的地方是，在子类的构造函数中，只有调用<code>super()</code>之后，才可以使用<code>this</code>关键字，否则会报错。这是因为子类实例的构建，必须先完成父类的继承，只有<code>super()</code>方法才能让子类实例继承父类。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Point</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  constructor</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">x</span><span style="color:#F0F3F6;">, </span><span style="color:#FFB757;">y</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#91CBFF;">    this</span><span style="color:#F0F3F6;">.x </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> x;</span></span>
<span class="line"><span style="color:#91CBFF;">    this</span><span style="color:#F0F3F6;">.y </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> y;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> ColorPoint</span><span style="color:#FF9492;"> extends</span><span style="color:#91CBFF;"> Point</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  constructor</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">x</span><span style="color:#F0F3F6;">, </span><span style="color:#FFB757;">y</span><span style="color:#F0F3F6;">, </span><span style="color:#FFB757;">color</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#91CBFF;">    this</span><span style="color:#F0F3F6;">.color </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> color; </span><span style="color:#BDC4CC;">// ReferenceError</span></span>
<span class="line"><span style="color:#91CBFF;">    super</span><span style="color:#F0F3F6;">(x, y);</span></span>
<span class="line"><span style="color:#91CBFF;">    this</span><span style="color:#F0F3F6;">.color </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> color; </span><span style="color:#BDC4CC;">// 正确</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面代码中，子类的<code>constructor()</code>方法没有调用<code>super()</code>之前，就使用<code>this</code>关键字，结果报错，而放在<code>super()</code>之后就是正确的。</p><p>如果子类没有定义<code>constructor()</code>方法，这个方法会默认添加，并且里面会调用<code>super()</code>。也就是说，不管有没有显式定义，任何一个子类都有<code>constructor()</code>方法。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> ColorPoint</span><span style="color:#FF9492;"> extends</span><span style="color:#91CBFF;"> Point</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;">// 等同于</span></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> ColorPoint</span><span style="color:#FF9492;"> extends</span><span style="color:#91CBFF;"> Point</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  constructor</span><span style="color:#F0F3F6;">(</span><span style="color:#FF9492;">...</span><span style="color:#FFB757;">args</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#91CBFF;">    super</span><span style="color:#F0F3F6;">(</span><span style="color:#FF9492;">...</span><span style="color:#F0F3F6;">args);</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>有了子类的定义，就可以生成子类的实例了。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> cp </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> ColorPoint</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">25</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">8</span><span style="color:#F0F3F6;">, </span><span style="color:#ADDCFF;">&#39;green&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">cp </span><span style="color:#FF9492;">instanceof</span><span style="color:#FFB757;"> ColorPoint</span><span style="color:#BDC4CC;"> // true</span></span>
<span class="line"><span style="color:#F0F3F6;">cp </span><span style="color:#FF9492;">instanceof</span><span style="color:#FFB757;"> Point</span><span style="color:#BDC4CC;"> // true</span></span></code></pre></div><p>上面示例中，实例对象<code>cp</code>同时是<code>ColorPoint</code>和<code>Point</code>两个类的实例，这与 ES5 的行为完全一致。</p><h2 id="私有属性和私有方法的继承" tabindex="-1"><a class="header-anchor" href="#私有属性和私有方法的继承"><span>私有属性和私有方法的继承</span></a></h2><p>父类所有的属性和方法，都会被子类继承，除了私有的属性和方法。</p><p>子类无法继承父类的私有属性，或者说，私有属性只能在定义它的<code>class</code>里面使用。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Foo</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FFB757;">  #p</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> 1</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">  #</span><span style="color:#DBB7FF;">m</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#F0F3F6;">    console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;hello&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Bar</span><span style="color:#FF9492;"> extends</span><span style="color:#91CBFF;"> Foo</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  constructor</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#91CBFF;">    super</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#F0F3F6;">    console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">this</span><span style="color:#F0F3F6;">.#p); </span><span style="color:#BDC4CC;">// 报错</span></span>
<span class="line"><span style="color:#91CBFF;">    this</span><span style="color:#F0F3F6;">.</span><span style="color:#DBB7FF;">#m</span><span style="color:#F0F3F6;">(); </span><span style="color:#BDC4CC;">// 报错</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面示例中，子类<code>Bar</code>调用父类<code>Foo</code>的私有属性或私有方法，都会报错。</p><p>如果父类定义了私有属性的读写方法，子类就可以通过这些方法，读写私有属性。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Foo</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FFB757;">  #p</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> 1</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#DBB7FF;">  getP</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#FF9492;">    return</span><span style="color:#91CBFF;"> this</span><span style="color:#F0F3F6;">.#p;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Bar</span><span style="color:#FF9492;"> extends</span><span style="color:#91CBFF;"> Foo</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  constructor</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#91CBFF;">    super</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#F0F3F6;">    console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">this</span><span style="color:#F0F3F6;">.</span><span style="color:#DBB7FF;">getP</span><span style="color:#F0F3F6;">()); </span><span style="color:#BDC4CC;">// 1</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面示例中，<code>getP()</code>是父类用来读取私有属性的方法，通过该方法，子类就可以读到父类的私有属性。</p><h2 id="静态属性和静态方法的继承" tabindex="-1"><a class="header-anchor" href="#静态属性和静态方法的继承"><span>静态属性和静态方法的继承</span></a></h2><p>父类的静态属性和静态方法，也会被子类继承。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> A</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  static</span><span style="color:#DBB7FF;"> hello</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#F0F3F6;">    console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;hello world&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> B</span><span style="color:#FF9492;"> extends</span><span style="color:#91CBFF;"> A</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#91CBFF;">B</span><span style="color:#F0F3F6;">.</span><span style="color:#DBB7FF;">hello</span><span style="color:#F0F3F6;">()  </span><span style="color:#BDC4CC;">// hello world</span></span></code></pre></div><p>上面代码中，<code>hello()</code>是<code>A</code>类的静态方法，<code>B</code>继承<code>A</code>，也继承了<code>A</code>的静态方法。</p><p>注意，静态属性是通过浅拷贝实现继承的。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> A</span><span style="color:#F0F3F6;"> { </span><span style="color:#FF9492;">static</span><span style="color:#FFB757;"> foo</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> 100</span><span style="color:#F0F3F6;">; }</span></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> B</span><span style="color:#FF9492;"> extends</span><span style="color:#91CBFF;"> A</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  constructor</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#91CBFF;">    super</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#91CBFF;">    B</span><span style="color:#F0F3F6;">.foo</span><span style="color:#FF9492;">--</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> b</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> B</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#91CBFF;">B</span><span style="color:#F0F3F6;">.foo </span><span style="color:#BDC4CC;">// 99</span></span>
<span class="line"><span style="color:#91CBFF;">A</span><span style="color:#F0F3F6;">.foo </span><span style="color:#BDC4CC;">// 100</span></span></code></pre></div><p>上面示例中，<code>foo</code>是<code>A</code>类的静态属性，<code>B</code>类继承了<code>A</code>类，因此也继承了这个属性。但是，在<code>B</code>类内部操作<code>B.foo</code>这个静态属性，影响不到<code>A.foo</code>，原因就是<code>B</code>类继承静态属性时，会采用浅拷贝，拷贝父类静态属性的值，因此<code>A.foo</code>和<code>B.foo</code>是两个彼此独立的属性。</p><p>但是，由于这种拷贝是浅拷贝，如果父类的静态属性的值是一个对象，那么子类的静态属性也会指向这个对象，因为浅拷贝只会拷贝对象的内存地址。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> A</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  static</span><span style="color:#FFB757;"> foo</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> { n: </span><span style="color:#91CBFF;">100</span><span style="color:#F0F3F6;"> };</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> B</span><span style="color:#FF9492;"> extends</span><span style="color:#91CBFF;"> A</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  constructor</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#91CBFF;">    super</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#91CBFF;">    B</span><span style="color:#F0F3F6;">.foo.n</span><span style="color:#FF9492;">--</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> b</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> B</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#91CBFF;">B</span><span style="color:#F0F3F6;">.foo.n </span><span style="color:#BDC4CC;">// 99</span></span>
<span class="line"><span style="color:#91CBFF;">A</span><span style="color:#F0F3F6;">.foo.n </span><span style="color:#BDC4CC;">// 99</span></span></code></pre></div><p>上面示例中，<code>A.foo</code>的值是一个对象，浅拷贝导致<code>B.foo</code>和<code>A.foo</code>指向同一个对象。所以，子类B修改这个对象的属性值，会影响到父类<code>A</code>。</p><h2 id="object-getprototypeof" tabindex="-1"><a class="header-anchor" href="#object-getprototypeof"><span>Object.getPrototypeOf()</span></a></h2><p><code>Object.getPrototypeOf()</code>方法可以用来从子类上获取父类。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Point</span><span style="color:#F0F3F6;"> { </span><span style="color:#BDC4CC;">/*...*/</span><span style="color:#F0F3F6;"> }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> ColorPoint</span><span style="color:#FF9492;"> extends</span><span style="color:#91CBFF;"> Point</span><span style="color:#F0F3F6;"> { </span><span style="color:#BDC4CC;">/*...*/</span><span style="color:#F0F3F6;"> }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">getPrototypeOf</span><span style="color:#F0F3F6;">(ColorPoint) </span><span style="color:#FF9492;">===</span><span style="color:#F0F3F6;"> Point</span></span>
<span class="line"><span style="color:#BDC4CC;">// true</span></span></code></pre></div><p>因此，可以使用这个方法判断，一个类是否继承了另一个类。</p><h2 id="super-关键字" tabindex="-1"><a class="header-anchor" href="#super-关键字"><span>super 关键字</span></a></h2><p><code>super</code>这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。</p><p>第一种情况，super作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次<code>super()</code>函数。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> A</span><span style="color:#F0F3F6;"> {}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> B</span><span style="color:#FF9492;"> extends</span><span style="color:#91CBFF;"> A</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  constructor</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#91CBFF;">    super</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面代码中，子类B的构造函数之中的<code>super()</code>，代表调用父类的构造函数。这是必须的，否则报错。</p><p>调用<code>super()</code>的作用是形成子类的<code>this</code>对象，把父类的实例属性和方法放到这个<code>this</code>对象上面。子类在调用<code>super()</code>之前，是没有<code>this</code>对象的，任何对<code>this</code>的操作都要放在<code>super()</code>的后面。</p><p>注意，这里的<code>super</code>虽然代表了父类的构造函数，但是因为返回的是子类的<code>this</code>（即子类的实例对象），所以<code>super</code>内部的<code>this</code>代表子类的实例，而不是父类的实例，这里的<code>super()</code>相当于<code>A.prototype.constructor.call(this)</code>（在子类的<code>this</code>上运行父类的构造函数）。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> A</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  constructor</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#F0F3F6;">    console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(</span><span style="color:#FF9492;">new</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">target</span><span style="color:#F0F3F6;">.name);</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> B</span><span style="color:#FF9492;"> extends</span><span style="color:#91CBFF;"> A</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  constructor</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#91CBFF;">    super</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#FF9492;">new</span><span style="color:#DBB7FF;"> A</span><span style="color:#F0F3F6;">() </span><span style="color:#BDC4CC;">// A</span></span>
<span class="line"><span style="color:#FF9492;">new</span><span style="color:#DBB7FF;"> B</span><span style="color:#F0F3F6;">() </span><span style="color:#BDC4CC;">// B</span></span></code></pre></div><p>上面示例中，<code>new.target</code>指向当前正在执行的函数。可以看到，在<code>super()</code>执行时（<code>new B()</code>），它指向的是子类<code>B</code>的构造函数，而不是父类<code>A</code>的构造函数。也就是说，<code>super()</code>内部的<code>this</code>指向的是<code>B</code>。</p><p>不过，由于<code>super()</code>在子类构造方法中执行时，子类的属性和方法还没有绑定到<code>this</code>，所以如果存在同名属性，此时拿到的是父类的属性。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> A</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FFB757;">  name</span><span style="color:#FF9492;"> =</span><span style="color:#ADDCFF;"> &#39;A&#39;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">  constructor</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#F0F3F6;">    console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;My name is &#39;</span><span style="color:#FF9492;"> +</span><span style="color:#91CBFF;"> this</span><span style="color:#F0F3F6;">.name);</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> B</span><span style="color:#FF9492;"> extends</span><span style="color:#91CBFF;"> A</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FFB757;">  name</span><span style="color:#FF9492;"> =</span><span style="color:#ADDCFF;"> &#39;B&#39;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> b</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> B</span><span style="color:#F0F3F6;">(); </span><span style="color:#BDC4CC;">// My name is A</span></span></code></pre></div><p>上面示例中，最后一行输出的是<code>A</code>，而不是<code>B</code>，原因就在于<code>super()</code>执行时，<code>B</code>的<code>name</code>属性还没有绑定到<code>this</code>，所以<code>this.name</code>拿到的是<code>A</code>类的<code>name</code>属性。</p><p>作为函数时，<code>super()</code>只能用在子类的构造函数之中，用在其他地方就会报错。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> A</span><span style="color:#F0F3F6;"> {}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> B</span><span style="color:#FF9492;"> extends</span><span style="color:#91CBFF;"> A</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#DBB7FF;">  m</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#91CBFF;">    super</span><span style="color:#F0F3F6;">(); </span><span style="color:#BDC4CC;">// 报错</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面代码中，<code>super()</code>用在<code>B</code>类的<code>m</code>方法之中，就会造成语法错误。</p><p>第二种情况，<code>super</code>作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> A</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#DBB7FF;">  p</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#FF9492;">    return</span><span style="color:#91CBFF;"> 2</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> B</span><span style="color:#FF9492;"> extends</span><span style="color:#91CBFF;"> A</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  constructor</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#91CBFF;">    super</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#F0F3F6;">    console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">super</span><span style="color:#F0F3F6;">.</span><span style="color:#DBB7FF;">p</span><span style="color:#F0F3F6;">()); </span><span style="color:#BDC4CC;">// 2</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> b </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> B</span><span style="color:#F0F3F6;">();</span></span></code></pre></div><p>上面代码中，子类<code>B</code>当中的<code>super.p()</code>，就是将<code>super</code>当作一个对象使用。这时，<code>super</code>在普通方法之中，指向<code>A.prototype</code>，所以<code>super.p()</code>就相当于<code>A.prototype.p()</code>。</p><p>这里需要注意，由于<code>super</code>指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过<code>super</code>调用的。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> A</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  constructor</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#91CBFF;">    this</span><span style="color:#F0F3F6;">.p </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 2</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> B</span><span style="color:#FF9492;"> extends</span><span style="color:#91CBFF;"> A</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  get</span><span style="color:#DBB7FF;"> m</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#FF9492;">    return</span><span style="color:#91CBFF;"> super</span><span style="color:#F0F3F6;">.p;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> b </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> B</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#F0F3F6;">b.m </span><span style="color:#BDC4CC;">// undefined</span></span></code></pre></div><p>上面代码中，<code>p</code>是父类<code>A</code>实例的属性，<code>super.p</code>就引用不到它。</p><p>如果属性定义在父类的原型对象上，<code>super</code>就可以取到。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> A</span><span style="color:#F0F3F6;"> {}</span></span>
<span class="line"><span style="color:#91CBFF;">A</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">prototype</span><span style="color:#F0F3F6;">.x </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 2</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> B</span><span style="color:#FF9492;"> extends</span><span style="color:#91CBFF;"> A</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  constructor</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#91CBFF;">    super</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#F0F3F6;">    console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">super</span><span style="color:#F0F3F6;">.x) </span><span style="color:#BDC4CC;">// 2</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> b </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> B</span><span style="color:#F0F3F6;">();</span></span></code></pre></div><p>上面代码中，属性<code>x</code>是定义在<code>A.prototype</code>上面的，所以<code>super.x</code>可以取到它的值。</p><p>ES6 规定，在子类普通方法中通过<code>super</code>调用父类的方法时，方法内部的<code>this</code>指向当前的子类实例。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> A</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  constructor</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#91CBFF;">    this</span><span style="color:#F0F3F6;">.x </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 1</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#DBB7FF;">  print</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#F0F3F6;">    console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">this</span><span style="color:#F0F3F6;">.x);</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> B</span><span style="color:#FF9492;"> extends</span><span style="color:#91CBFF;"> A</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  constructor</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#91CBFF;">    super</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#91CBFF;">    this</span><span style="color:#F0F3F6;">.x </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 2</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#DBB7FF;">  m</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#91CBFF;">    super</span><span style="color:#F0F3F6;">.</span><span style="color:#DBB7FF;">print</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> b </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> B</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#F0F3F6;">b.</span><span style="color:#DBB7FF;">m</span><span style="color:#F0F3F6;">() </span><span style="color:#BDC4CC;">// 2</span></span></code></pre></div><p>上面代码中，<code>super.print()</code>虽然调用的是<code>A.prototype.print()</code>，但是<code>A.prototype.print()</code>内部的<code>this</code>指向子类<code>B</code>的实例，导致输出的是 2，而不是 1。也就是说，实际上执行的是<code>super.print.call(this)</code>。</p><p>由于<code>this</code>指向子类实例，所以如果通过<code>super</code>对某个属性赋值，这时<code>super</code>就是<code>this</code>，赋值的属性会变成子类实例的属性。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> A</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  constructor</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#91CBFF;">    this</span><span style="color:#F0F3F6;">.x </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 1</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> B</span><span style="color:#FF9492;"> extends</span><span style="color:#91CBFF;"> A</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  constructor</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#91CBFF;">    super</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#91CBFF;">    this</span><span style="color:#F0F3F6;">.x </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 2</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#91CBFF;">    super</span><span style="color:#F0F3F6;">.x </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 3</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">    console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">super</span><span style="color:#F0F3F6;">.x); </span><span style="color:#BDC4CC;">// undefined</span></span>
<span class="line"><span style="color:#F0F3F6;">    console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">this</span><span style="color:#F0F3F6;">.x); </span><span style="color:#BDC4CC;">// 3</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> b </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> B</span><span style="color:#F0F3F6;">();</span></span></code></pre></div><p>上面代码中，<code>super.x</code>赋值为 3，这时等同于对<code>this.x</code>赋值为 3。而当读取<code>super.x</code>的时候，读的是<code>A.prototype.x</code>，所以返回<code>undefined</code>。</p><p>如果<code>super</code>作为对象，用在静态方法之中，这时<code>super</code>将指向父类，而不是父类的原型对象。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Parent</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  static</span><span style="color:#DBB7FF;"> myMethod</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">msg</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#F0F3F6;">    console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;static&#39;</span><span style="color:#F0F3F6;">, msg);</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#DBB7FF;">  myMethod</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">msg</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#F0F3F6;">    console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;instance&#39;</span><span style="color:#F0F3F6;">, msg);</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Child</span><span style="color:#FF9492;"> extends</span><span style="color:#91CBFF;"> Parent</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  static</span><span style="color:#DBB7FF;"> myMethod</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">msg</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#91CBFF;">    super</span><span style="color:#F0F3F6;">.</span><span style="color:#DBB7FF;">myMethod</span><span style="color:#F0F3F6;">(msg);</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#DBB7FF;">  myMethod</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">msg</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#91CBFF;">    super</span><span style="color:#F0F3F6;">.</span><span style="color:#DBB7FF;">myMethod</span><span style="color:#F0F3F6;">(msg);</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">Child.</span><span style="color:#DBB7FF;">myMethod</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">); </span><span style="color:#BDC4CC;">// static 1</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> child </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> Child</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#F0F3F6;">child.</span><span style="color:#DBB7FF;">myMethod</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">); </span><span style="color:#BDC4CC;">// instance 2</span></span></code></pre></div><p>上面代码中，<code>super</code>在静态方法之中指向父类，在普通方法之中指向父类的原型对象。</p><p>另外，在子类的静态方法中通过<code>super</code>调用父类的方法时，方法内部的<code>this</code>指向当前的子类，而不是子类的实例。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> A</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  constructor</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#91CBFF;">    this</span><span style="color:#F0F3F6;">.x </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 1</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#FF9492;">  static</span><span style="color:#DBB7FF;"> print</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#F0F3F6;">    console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">this</span><span style="color:#F0F3F6;">.x);</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> B</span><span style="color:#FF9492;"> extends</span><span style="color:#91CBFF;"> A</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  constructor</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#91CBFF;">    super</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#91CBFF;">    this</span><span style="color:#F0F3F6;">.x </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 2</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#FF9492;">  static</span><span style="color:#DBB7FF;"> m</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#91CBFF;">    super</span><span style="color:#F0F3F6;">.</span><span style="color:#DBB7FF;">print</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#91CBFF;">B</span><span style="color:#F0F3F6;">.x </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 3</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#91CBFF;">B</span><span style="color:#F0F3F6;">.</span><span style="color:#DBB7FF;">m</span><span style="color:#F0F3F6;">() </span><span style="color:#BDC4CC;">// 3</span></span></code></pre></div><p>上面代码中，静态方法<code>B.m</code>里面，<code>super.print</code>指向父类的静态方法。这个方法里面的<code>this</code>指向的是<code>B</code>，而不是<code>B</code>的实例。</p><p>注意，使用<code>super</code>的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> A</span><span style="color:#F0F3F6;"> {}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> B</span><span style="color:#FF9492;"> extends</span><span style="color:#91CBFF;"> A</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  constructor</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#91CBFF;">    super</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#F0F3F6;">    console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">super</span><span style="color:#F0F3F6;">); </span><span style="color:#BDC4CC;">// 报错</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面代码中，<code>console.log(super)</code>当中的<code>super</code>，无法看出是作为函数使用，还是作为对象使用，所以 JavaScript 引擎解析代码的时候就会报错。这时，如果能清晰地表明<code>super</code>的数据类型，就不会报错。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> A</span><span style="color:#F0F3F6;"> {}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> B</span><span style="color:#FF9492;"> extends</span><span style="color:#91CBFF;"> A</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  constructor</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#91CBFF;">    super</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#F0F3F6;">    console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">super</span><span style="color:#F0F3F6;">.</span><span style="color:#DBB7FF;">valueOf</span><span style="color:#F0F3F6;">() </span><span style="color:#FF9492;">instanceof</span><span style="color:#FFB757;"> B</span><span style="color:#F0F3F6;">); </span><span style="color:#BDC4CC;">// true</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> b </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> B</span><span style="color:#F0F3F6;">();</span></span></code></pre></div><p>上面代码中，<code>super.valueOf()</code>表明<code>super</code>是一个对象，因此就不会报错。同时，由于<code>super</code>使得<code>this</code>指向B的实例，所以<code>super.valueOf()</code>返回的是一个<code>B</code>的实例。</p><p>最后，由于对象总是继承其他对象的，所以可以在任意一个对象中，使用<code>super</code>关键字。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> obj </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#DBB7FF;">  toString</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#FF9492;">    return</span><span style="color:#ADDCFF;"> &quot;MyObject: &quot;</span><span style="color:#FF9492;"> +</span><span style="color:#91CBFF;"> super</span><span style="color:#F0F3F6;">.</span><span style="color:#DBB7FF;">toString</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">obj.</span><span style="color:#DBB7FF;">toString</span><span style="color:#F0F3F6;">(); </span><span style="color:#BDC4CC;">// MyObject: [object Object]</span></span></code></pre></div><h2 id="类的-prototype-属性和-proto-属性" tabindex="-1"><a class="header-anchor" href="#类的-prototype-属性和-proto-属性"><span>类的 prototype 属性和__proto__属性</span></a></h2><p>大多数浏览器的 ES5 实现之中，每一个对象都有<code>__proto__</code>属性，指向对应的构造函数的<code>prototype</code>属性。<code>Class</code>作为构造函数的语法糖，同时有<code>prototype</code>属性和<code>__proto__</code>属性，因此同时存在两条继承链。</p><ol><li>子类的<code>__proto__</code>属性，表示构造函数的继承，总是指向父类。</li><li>子类<code>prototype</code>属性的<code>__proto__</code>属性，表示方法的继承，总是指向父类的<code>prototype</code>属性。</li></ol><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> A</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> B</span><span style="color:#FF9492;"> extends</span><span style="color:#91CBFF;"> A</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#91CBFF;">B</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">__proto__</span><span style="color:#FF9492;"> ===</span><span style="color:#91CBFF;"> A</span><span style="color:#BDC4CC;"> // true</span></span>
<span class="line"><span style="color:#91CBFF;">B</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">prototype</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">__proto__</span><span style="color:#FF9492;"> ===</span><span style="color:#91CBFF;"> A</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">prototype</span><span style="color:#BDC4CC;"> // true</span></span></code></pre></div><p>上面代码中，子类<code>B</code>的<code>__proto__</code>属性指向父类<code>A</code>，子类<code>B</code>的<code>prototype</code>属性的<code>__proto__</code>属性指向父类<code>A</code>的<code>prototype</code>属性。</p><p>这样的结果是因为，类的继承是按照下面的模式实现的。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> A</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> B</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;">// B 的实例继承 A 的实例</span></span>
<span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">setPrototypeOf</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">B</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">prototype</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">A</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">prototype</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;">// B 继承 A 的静态属性</span></span>
<span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">setPrototypeOf</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">B</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">A</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> b</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> B</span><span style="color:#F0F3F6;">();</span></span></code></pre></div><p><code>Object.setPrototypeOf</code>方法的实现。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">setPrototypeOf</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> function</span><span style="color:#F0F3F6;"> (</span><span style="color:#FFB757;">obj</span><span style="color:#F0F3F6;">, </span><span style="color:#FFB757;">proto</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#F0F3F6;">  obj.</span><span style="color:#91CBFF;">__proto__</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> proto;</span></span>
<span class="line"><span style="color:#FF9492;">  return</span><span style="color:#F0F3F6;"> obj;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>因此，就得到了上面的结果。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">setPrototypeOf</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">B</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">prototype</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">A</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">prototype</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#BDC4CC;">// 等同于</span></span>
<span class="line"><span style="color:#91CBFF;">B</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">prototype</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">__proto__</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> A</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">prototype</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">setPrototypeOf</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">B</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">A</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#BDC4CC;">// 等同于</span></span>
<span class="line"><span style="color:#91CBFF;">B</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">__proto__</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> A</span><span style="color:#F0F3F6;">;</span></span></code></pre></div><p>这两条继承链，可以这样理解：作为一个对象，子类（<code>B</code>）的原型（<code>__proto__</code>属性）是父类（<code>A</code>）；作为一个构造函数，子类（<code>B</code>）的原型对象（<code>prototype</code>属性）是父类的原型对象（<code>prototype</code>属性）的实例。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#91CBFF;">B</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">prototype</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> Object.</span><span style="color:#DBB7FF;">create</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">A</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">prototype</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#BDC4CC;">// 等同于</span></span>
<span class="line"><span style="color:#91CBFF;">B</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">prototype</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">__proto__</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> A</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">prototype</span><span style="color:#F0F3F6;">;</span></span></code></pre></div><p><code>extends</code>关键字后面可以跟多种类型的值。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> B</span><span style="color:#FF9492;"> extends</span><span style="color:#91CBFF;"> A</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面代码的<code>A</code>，只要是一个有<code>prototype</code>属性的函数，就能被B继承。由于函数都有<code>prototype</code>属性（除了<code>Function.prototype</code>函数），因此<code>A</code>可以是任意函数。</p><p>下面，讨论两种情况。第一种，子类继承<code>Object</code>类。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> A</span><span style="color:#FF9492;"> extends</span><span style="color:#91CBFF;"> Object</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#91CBFF;">A</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">__proto__</span><span style="color:#FF9492;"> ===</span><span style="color:#F0F3F6;"> Object </span><span style="color:#BDC4CC;">// true</span></span>
<span class="line"><span style="color:#91CBFF;">A</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">prototype</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">__proto__</span><span style="color:#FF9492;"> ===</span><span style="color:#91CBFF;"> Object</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">prototype</span><span style="color:#BDC4CC;"> // true</span></span></code></pre></div><p>这种情况下，<code>A</code>其实就是构造函数<code>Object</code>的复制，<code>A</code>的实例就是<code>Object</code>的实例。</p><p>第二种情况，不存在任何继承。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> A</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#91CBFF;">A</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">__proto__</span><span style="color:#FF9492;"> ===</span><span style="color:#91CBFF;"> Function</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">prototype</span><span style="color:#BDC4CC;"> // true</span></span>
<span class="line"><span style="color:#91CBFF;">A</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">prototype</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">__proto__</span><span style="color:#FF9492;"> ===</span><span style="color:#91CBFF;"> Object</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">prototype</span><span style="color:#BDC4CC;"> // true</span></span></code></pre></div><p>这种情况下，<code>A</code>作为一个基类（即不存在任何继承），就是一个普通函数，所以直接继承<code>Function.prototype</code>。但是，<code>A</code>调用后返回一个空对象（即<code>Object</code>实例），所以<code>A.prototype.__proto__</code>指向构造函数（<code>Object</code>）的<code>prototype</code>属性。</p><h3 id="实例的-proto-属性" tabindex="-1"><a class="header-anchor" href="#实例的-proto-属性"><span>实例的 <strong>proto</strong> 属性</span></a></h3><p>子类实例的<code>__proto__</code>属性的<code>__proto__</code>属性，指向父类实例的<code>__proto__</code>属性。也就是说，子类的原型的原型，是父类的原型。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> p1 </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> Point</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">3</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> p2 </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> ColorPoint</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">3</span><span style="color:#F0F3F6;">, </span><span style="color:#ADDCFF;">&#39;red&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">p2.</span><span style="color:#91CBFF;">__proto__</span><span style="color:#FF9492;"> ===</span><span style="color:#F0F3F6;"> p1.</span><span style="color:#91CBFF;">__proto__</span><span style="color:#BDC4CC;"> // false</span></span>
<span class="line"><span style="color:#F0F3F6;">p2.</span><span style="color:#91CBFF;">__proto__</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">__proto__</span><span style="color:#FF9492;"> ===</span><span style="color:#F0F3F6;"> p1.</span><span style="color:#91CBFF;">__proto__</span><span style="color:#BDC4CC;"> // true</span></span></code></pre></div><p>上面代码中，<code>ColorPoint</code>继承了<code>Point</code>，导致前者原型的原型是后者的原型。</p><p>因此，通过子类实例的<code>__proto__.__proto__</code>属性，可以修改父类实例的行为。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">p2.</span><span style="color:#91CBFF;">__proto__</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">__proto__</span><span style="color:#F0F3F6;">.</span><span style="color:#DBB7FF;">printName</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> function</span><span style="color:#F0F3F6;"> () {</span></span>
<span class="line"><span style="color:#F0F3F6;">console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;Ha&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">p1.</span><span style="color:#DBB7FF;">printName</span><span style="color:#F0F3F6;">() </span><span style="color:#BDC4CC;">// &quot;Ha&quot;</span></span></code></pre></div><p>上面代码在<code>ColorPoint</code>的实例<code>p2</code>上向<code>Point</code>类添加方法，结果影响到了<code>Point</code>的实例<code>p1</code>。</p><h2 id="原生构造函数的继承" tabindex="-1"><a class="header-anchor" href="#原生构造函数的继承"><span>原生构造函数的继承</span></a></h2><p>原生构造函数是指语言内置的构造函数，通常用来生成数据结构。ECMAScript 的原生构造函数大致有下面这些。</p><ul><li><code>Boolean()</code></li><li><code>Number()</code></li><li><code>String()</code></li><li><code>Array()</code></li><li><code>Date()</code></li><li><code>Function()</code></li><li><code>RegExp()</code></li><li><code>Error()</code></li><li><code>Object()</code></li></ul><p>以前，这些原生构造函数是无法继承的，比如，不能自己定义一个<code>Array</code>的子类。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">function</span><span style="color:#DBB7FF;"> MyArray</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#F0F3F6;">  Array.</span><span style="color:#DBB7FF;">apply</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">this</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">arguments</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#91CBFF;">MyArray</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">prototype</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> Object.</span><span style="color:#DBB7FF;">create</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">Array</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">prototype</span><span style="color:#F0F3F6;">, {</span></span>
<span class="line"><span style="color:#F0F3F6;">  constructor: {</span></span>
<span class="line"><span style="color:#F0F3F6;">    value: MyArray,</span></span>
<span class="line"><span style="color:#F0F3F6;">    writable: </span><span style="color:#91CBFF;">true</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#F0F3F6;">    configurable: </span><span style="color:#91CBFF;">true</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#F0F3F6;">    enumerable: </span><span style="color:#91CBFF;">true</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">});</span></span></code></pre></div><p>上面代码定义了一个继承<code>Array</code>的<code>MyArray</code>类。但是，这个类的行为与<code>Array</code>完全不一致。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> colors </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> MyArray</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#F0F3F6;">colors[</span><span style="color:#91CBFF;">0</span><span style="color:#F0F3F6;">] </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &quot;red&quot;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">colors.</span><span style="color:#91CBFF;">length</span><span style="color:#BDC4CC;">  // 0</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">colors.</span><span style="color:#91CBFF;">length</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> 0</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">colors[</span><span style="color:#91CBFF;">0</span><span style="color:#F0F3F6;">]  </span><span style="color:#BDC4CC;">// &quot;red&quot;</span></span></code></pre></div><p>之所以会发生这种情况，是因为子类无法获得原生构造函数的内部属性，通过<code>Array.apply()</code>或者分配给原型对象都不行。原生构造函数会忽略<code>apply</code>方法传入的<code>this</code>，也就是说，原生构造函数的<code>this</code>无法绑定，导致拿不到内部属性。</p><p>ES5 是先新建子类的实例对象<code>this</code>，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致无法继承原生的构造函数。比如，<code>Array</code>构造函数有一个内部属性<code>[[DefineOwnProperty]]</code>，用来定义新属性时，更新<code>length</code>属性，这个内部属性无法在子类获取，导致子类的<code>length</code>属性行为不正常。</p><p>下面的例子中，我们想让一个普通对象继承<code>Error</code>对象。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> e </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> {};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">getOwnPropertyNames</span><span style="color:#F0F3F6;">(Error.</span><span style="color:#DBB7FF;">call</span><span style="color:#F0F3F6;">(e))</span></span>
<span class="line"><span style="color:#BDC4CC;">// [ &#39;stack&#39; ]</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">getOwnPropertyNames</span><span style="color:#F0F3F6;">(e)</span></span>
<span class="line"><span style="color:#BDC4CC;">// []</span></span></code></pre></div><p>上面代码中，我们想通过<code>Error.call(e)</code>这种写法，让普通对象<code>e</code>具有<code>Error</code>对象的实例属性。但是，<code>Error.call()</code>完全忽略传入的第一个参数，而是返回一个新对象，<code>e</code>本身没有任何变化。这证明了<code>Error.call(e)</code>这种写法，无法继承原生构造函数。</p><p>ES6 允许继承原生构造函数定义子类，因为 ES6 是先新建父类的实例对象<code>this</code>，然后再用子类的构造函数修饰<code>this</code>，使得父类的所有行为都可以继承。下面是一个继承<code>Array</code>的例子。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> MyArray</span><span style="color:#FF9492;"> extends</span><span style="color:#91CBFF;"> Array</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  constructor</span><span style="color:#F0F3F6;">(</span><span style="color:#FF9492;">...</span><span style="color:#FFB757;">args</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#91CBFF;">    super</span><span style="color:#F0F3F6;">(</span><span style="color:#FF9492;">...</span><span style="color:#F0F3F6;">args);</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> arr </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> MyArray</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#F0F3F6;">arr[</span><span style="color:#91CBFF;">0</span><span style="color:#F0F3F6;">] </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 12</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">arr.</span><span style="color:#91CBFF;">length</span><span style="color:#BDC4CC;"> // 1</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">arr.</span><span style="color:#91CBFF;">length</span><span style="color:#FF9492;"> =</span><span style="color:#91CBFF;"> 0</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">arr[</span><span style="color:#91CBFF;">0</span><span style="color:#F0F3F6;">] </span><span style="color:#BDC4CC;">// undefined</span></span></code></pre></div><p>上面代码定义了一个<code>MyArray</code>类，继承了<code>Array</code>构造函数，因此就可以从<code>MyArray</code>生成数组的实例。这意味着，ES6 可以自定义原生数据结构（比如<code>Array</code>、<code>String</code>等）的子类，这是 ES5 无法做到的。</p><p>上面这个例子也说明，<code>extends</code>关键字不仅可以用来继承类，还可以用来继承原生的构造函数。因此可以在原生数据结构的基础上，定义自己的数据结构。下面就是定义了一个带版本功能的数组。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> VersionedArray</span><span style="color:#FF9492;"> extends</span><span style="color:#91CBFF;"> Array</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  constructor</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#91CBFF;">    super</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#91CBFF;">    this</span><span style="color:#F0F3F6;">.history </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [[]];</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#DBB7FF;">  commit</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#91CBFF;">    this</span><span style="color:#F0F3F6;">.history.</span><span style="color:#DBB7FF;">push</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">this</span><span style="color:#F0F3F6;">.</span><span style="color:#DBB7FF;">slice</span><span style="color:#F0F3F6;">());</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#DBB7FF;">  revert</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#91CBFF;">    this</span><span style="color:#F0F3F6;">.</span><span style="color:#DBB7FF;">splice</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">0</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">this</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">length</span><span style="color:#F0F3F6;">, </span><span style="color:#FF9492;">...</span><span style="color:#91CBFF;">this</span><span style="color:#F0F3F6;">.history[</span><span style="color:#91CBFF;">this</span><span style="color:#F0F3F6;">.history.</span><span style="color:#91CBFF;">length</span><span style="color:#FF9492;"> -</span><span style="color:#91CBFF;"> 1</span><span style="color:#F0F3F6;">]);</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> x </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> VersionedArray</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">x.</span><span style="color:#DBB7FF;">push</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#F0F3F6;">x.</span><span style="color:#DBB7FF;">push</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#F0F3F6;">x </span><span style="color:#BDC4CC;">// [1, 2]</span></span>
<span class="line"><span style="color:#F0F3F6;">x.history </span><span style="color:#BDC4CC;">// [[]]</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">x.</span><span style="color:#DBB7FF;">commit</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#F0F3F6;">x.history </span><span style="color:#BDC4CC;">// [[], [1, 2]]</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">x.</span><span style="color:#DBB7FF;">push</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">3</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#F0F3F6;">x </span><span style="color:#BDC4CC;">// [1, 2, 3]</span></span>
<span class="line"><span style="color:#F0F3F6;">x.history </span><span style="color:#BDC4CC;">// [[], [1, 2]]</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">x.</span><span style="color:#DBB7FF;">revert</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#F0F3F6;">x </span><span style="color:#BDC4CC;">// [1, 2]</span></span></code></pre></div><p>上面代码中，<code>VersionedArray</code>会通过<code>commit</code>方法，将自己的当前状态生成一个版本快照，存入<code>history</code>属性。<code>revert</code>方法用来将数组重置为最新一次保存的版本。除此之外，<code>VersionedArray</code>依然是一个普通数组，所有原生的数组方法都可以在它上面调用。</p><p>下面是一个自定义<code>Error</code>子类的例子，可以用来定制报错时的行为。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> ExtendableError</span><span style="color:#FF9492;"> extends</span><span style="color:#91CBFF;"> Error</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  constructor</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">message</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#91CBFF;">    super</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#91CBFF;">    this</span><span style="color:#F0F3F6;">.message </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> message;</span></span>
<span class="line"><span style="color:#91CBFF;">    this</span><span style="color:#F0F3F6;">.stack </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">new</span><span style="color:#DBB7FF;"> Error</span><span style="color:#F0F3F6;">()).stack;</span></span>
<span class="line"><span style="color:#91CBFF;">    this</span><span style="color:#F0F3F6;">.name </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> this</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">constructor</span><span style="color:#F0F3F6;">.name;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> MyError</span><span style="color:#FF9492;"> extends</span><span style="color:#91CBFF;"> ExtendableError</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  constructor</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">m</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#91CBFF;">    super</span><span style="color:#F0F3F6;">(m);</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> myerror </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> MyError</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;ll&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#F0F3F6;">myerror.message </span><span style="color:#BDC4CC;">// &quot;ll&quot;</span></span>
<span class="line"><span style="color:#F0F3F6;">myerror </span><span style="color:#FF9492;">instanceof</span><span style="color:#FFB757;"> Error</span><span style="color:#BDC4CC;"> // true</span></span>
<span class="line"><span style="color:#F0F3F6;">myerror.name </span><span style="color:#BDC4CC;">// &quot;MyError&quot;</span></span>
<span class="line"><span style="color:#F0F3F6;">myerror.stack</span></span>
<span class="line"><span style="color:#BDC4CC;">// Error</span></span>
<span class="line"><span style="color:#BDC4CC;">//     at MyError.ExtendableError</span></span>
<span class="line"><span style="color:#BDC4CC;">//     ...</span></span></code></pre></div><p>注意，继承<code>Object</code>的子类，有一个行为差异。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> NewObj</span><span style="color:#FF9492;"> extends</span><span style="color:#91CBFF;"> Object</span><span style="color:#F0F3F6;">{</span></span>
<span class="line"><span style="color:#FF9492;">  constructor</span><span style="color:#F0F3F6;">(){</span></span>
<span class="line"><span style="color:#91CBFF;">    super</span><span style="color:#F0F3F6;">(</span><span style="color:#FF9492;">...</span><span style="color:#91CBFF;">arguments</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#FF9492;">var</span><span style="color:#F0F3F6;"> o </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> NewObj</span><span style="color:#F0F3F6;">({attr: </span><span style="color:#91CBFF;">true</span><span style="color:#F0F3F6;">});</span></span>
<span class="line"><span style="color:#F0F3F6;">o.attr </span><span style="color:#FF9492;">===</span><span style="color:#91CBFF;"> true</span><span style="color:#BDC4CC;">  // false</span></span></code></pre></div><p>上面代码中，<code>NewObj</code>继承了<code>Object</code>，但是无法通过<code>super</code>方法向父类<code>Object</code>传参。这是因为 ES6 改变了<code>Object</code>构造函数的行为，一旦发现<code>Object</code>方法不是通过<code>new Object()</code>这种形式调用，ES6 规定<code>Object</code>构造函数会忽略参数。</p><h2 id="mixin-模式的实现" tabindex="-1"><a class="header-anchor" href="#mixin-模式的实现"><span>Mixin 模式的实现</span></a></h2><p><code>Mixin</code>指的是多个对象合成一个新的对象，新对象具有各个组成成员的接口。它的最简单实现如下。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> a</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">  a: </span><span style="color:#ADDCFF;">&#39;a&#39;</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> b</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">  b: </span><span style="color:#ADDCFF;">&#39;b&#39;</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> c</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> {</span><span style="color:#FF9492;">...</span><span style="color:#F0F3F6;">a, </span><span style="color:#FF9492;">...</span><span style="color:#F0F3F6;">b}; </span><span style="color:#BDC4CC;">// {a: &#39;a&#39;, b: &#39;b&#39;}</span></span></code></pre></div><p>上面代码中，<code>c</code>对象是<code>a</code>对象和<code>b</code>对象的合成，具有两者的接口。</p><p>下面是一个更完备的实现，将多个类的接口“混入”另一个类。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">function</span><span style="color:#DBB7FF;"> mix</span><span style="color:#F0F3F6;">(</span><span style="color:#FF9492;">...</span><span style="color:#FFB757;">mixins</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#FF9492;">  class</span><span style="color:#FFB757;"> Mix</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">    constructor</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#FF9492;">      for</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> mixin </span><span style="color:#FF9492;">of</span><span style="color:#F0F3F6;"> mixins) {</span></span>
<span class="line"><span style="color:#DBB7FF;">        copyProperties</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">this</span><span style="color:#F0F3F6;">, </span><span style="color:#FF9492;">new</span><span style="color:#DBB7FF;"> mixin</span><span style="color:#F0F3F6;">()); </span><span style="color:#BDC4CC;">// 拷贝实例属性</span></span>
<span class="line"><span style="color:#F0F3F6;">      }</span></span>
<span class="line"><span style="color:#F0F3F6;">    }</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">  for</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> mixin </span><span style="color:#FF9492;">of</span><span style="color:#F0F3F6;"> mixins) {</span></span>
<span class="line"><span style="color:#DBB7FF;">    copyProperties</span><span style="color:#F0F3F6;">(Mix, mixin); </span><span style="color:#BDC4CC;">// 拷贝静态属性</span></span>
<span class="line"><span style="color:#DBB7FF;">    copyProperties</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">Mix</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">prototype</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">mixin</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">prototype</span><span style="color:#F0F3F6;">); </span><span style="color:#BDC4CC;">// 拷贝原型属性</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">  return</span><span style="color:#F0F3F6;"> Mix;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">function</span><span style="color:#DBB7FF;"> copyProperties</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">target</span><span style="color:#F0F3F6;">, </span><span style="color:#FFB757;">source</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#FF9492;">  for</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> key </span><span style="color:#FF9492;">of</span><span style="color:#F0F3F6;"> Reflect.</span><span style="color:#DBB7FF;">ownKeys</span><span style="color:#F0F3F6;">(source)) {</span></span>
<span class="line"><span style="color:#FF9492;">    if</span><span style="color:#F0F3F6;"> ( key </span><span style="color:#FF9492;">!==</span><span style="color:#ADDCFF;"> &#39;constructor&#39;</span></span>
<span class="line"><span style="color:#FF9492;">      &amp;&amp;</span><span style="color:#F0F3F6;"> key </span><span style="color:#FF9492;">!==</span><span style="color:#ADDCFF;"> &#39;prototype&#39;</span></span>
<span class="line"><span style="color:#FF9492;">      &amp;&amp;</span><span style="color:#F0F3F6;"> key </span><span style="color:#FF9492;">!==</span><span style="color:#ADDCFF;"> &#39;name&#39;</span></span>
<span class="line"><span style="color:#F0F3F6;">    ) {</span></span>
<span class="line"><span style="color:#FF9492;">      let</span><span style="color:#F0F3F6;"> desc </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> Object.</span><span style="color:#DBB7FF;">getOwnPropertyDescriptor</span><span style="color:#F0F3F6;">(source, key);</span></span>
<span class="line"><span style="color:#F0F3F6;">      Object.</span><span style="color:#DBB7FF;">defineProperty</span><span style="color:#F0F3F6;">(target, key, desc);</span></span>
<span class="line"><span style="color:#F0F3F6;">    }</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面代码的<code>mix</code>函数，可以将多个对象合成为一个类。使用的时候，只要继承这个类即可。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> DistributedEdit</span><span style="color:#FF9492;"> extends</span><span style="color:#DBB7FF;"> mix</span><span style="color:#F0F3F6;">(Loggable, Serializable) {</span></span>
<span class="line"><span style="color:#BDC4CC;">	// ...</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div>`,147)]))}const r=n(o,[["render",e],["__file","ES6 Class的继承.html.vue"]]),y=JSON.parse('{"path":"/js/es6/ES6%20Class%E7%9A%84%E7%BB%A7%E6%89%BF.html","title":"","lang":"zh-CN","frontmatter":{"description":"简介 Class可以通过extends关键字实现继承，让子类继承父类的属性和方法。extends的写法比 ES5 的原型链继承，要清晰和方便很多。 上面示例中，Point是父类，ColorPoint是子类，它通过extends关键字，继承了Point类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个Point类。 下面，...","head":[["meta",{"property":"og:url","content":"https://wsq01.github.io/wsq-blog/js/es6/ES6%20Class%E7%9A%84%E7%BB%A7%E6%89%BF.html"}],["meta",{"property":"og:description","content":"简介 Class可以通过extends关键字实现继承，让子类继承父类的属性和方法。extends的写法比 ES5 的原型链继承，要清晰和方便很多。 上面示例中，Point是父类，ColorPoint是子类，它通过extends关键字，继承了Point类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个Point类。 下面，..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-11-01T01:55:29.000Z"}],["meta",{"property":"article:modified_time","content":"2024-11-01T01:55:29.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-11-01T01:55:29.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"WSQ\\",\\"url\\":\\"https://wsq01.github.com\\"}]}"]]},"headers":[{"level":2,"title":"简介","slug":"简介","link":"#简介","children":[]},{"level":2,"title":"私有属性和私有方法的继承","slug":"私有属性和私有方法的继承","link":"#私有属性和私有方法的继承","children":[]},{"level":2,"title":"静态属性和静态方法的继承","slug":"静态属性和静态方法的继承","link":"#静态属性和静态方法的继承","children":[]},{"level":2,"title":"Object.getPrototypeOf()","slug":"object-getprototypeof","link":"#object-getprototypeof","children":[]},{"level":2,"title":"super 关键字","slug":"super-关键字","link":"#super-关键字","children":[]},{"level":2,"title":"类的 prototype 属性和__proto__属性","slug":"类的-prototype-属性和-proto-属性","link":"#类的-prototype-属性和-proto-属性","children":[{"level":3,"title":"实例的 proto 属性","slug":"实例的-proto-属性","link":"#实例的-proto-属性","children":[]}]},{"level":2,"title":"原生构造函数的继承","slug":"原生构造函数的继承","link":"#原生构造函数的继承","children":[]},{"level":2,"title":"Mixin 模式的实现","slug":"mixin-模式的实现","link":"#mixin-模式的实现","children":[]}],"git":{"createdTime":1730426129000,"updatedTime":1730426129000,"contributors":[{"name":"WSQ","email":"592786982@qq.com","commits":1}]},"readingTime":{"minutes":16.7,"words":5009},"filePathRelative":"js/es6/ES6 Class的继承.md","localizedDate":"2024年11月1日","autoDesc":true}');export{r as comp,y as data};
