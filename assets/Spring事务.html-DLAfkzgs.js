import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,d as r,o as i}from"./app-ByvFWdWZ.js";const o={};function e(s,a){return i(),n("div",null,a[0]||(a[0]=[r('<p>事务具有 4 个特性：原子性、一致性、隔离性和持久性，简称为 ACID 特性。<br> 原子性（Atomicity）：一个事务是一个不可分割的工作单位，事务中包括的动作要么都做要么都不做。<br> 一致性（Consistency）：事务必须保证数据库从一个一致性状态变到另一个一致性状态，一致性和原子性是密切相关的。<br> 隔离性（Isolation）：一个事务的执行不能被其它事务干扰，即一个事务内部的操作及使用的数据对并发的其它事务是隔离的，并发执行的各个事务之间不能互相打扰。<br> 持久性（Durability）：持久性也称为永久性，指一个事务一旦提交，它对数据库中数据的改变就是永久性的，后面的其它操作和故障都不应该对其有任何影响。</p><p>事务允许我们将几个或一组操作组合成一个要么全部成功、要么全部失败的工作单元。如果事务中的所有的操作都执行成功，那自然万事大吉。但如果事务中的任何一个操作失败，那么事务中所有的操作都会被回滚，已经执行成功操作也会被完全清除干净，就好像什么事都没有发生一样。</p><h2 id="事务管理方式" tabindex="-1"><a class="header-anchor" href="#事务管理方式"><span>事务管理方式</span></a></h2><p>Spring 支持以下 2 种事务管理方式。</p><p>事务管理方式 说明<br> 编程式事务管理 编程式事务管理是通过编写代码实现的事务管理。</p><p>这种方式能够在代码中精确地定义事务的边界，我们可以根据需求规定事务从哪里开始，到哪里结束。<br> 声明式事务管理 Spring 声明式事务管理在底层采用了 AOP 技术，其最大的优点在于无须通过编程的方式管理事务，只需要在配置文件中进行相关的规则声明，就可以将事务规则应用到业务逻辑中。</p><p>选择编程式事务还是声明式事务，很大程度上就是在控制权细粒度和易用性之间进行权衡。<br> 编程式对事物控制的细粒度更高，我们能够精确的控制事务的边界，事务的开始和结束完全取决于我们的需求，但这种方式存在一个致命的缺点，那就是事务规则与业务代码耦合度高，难以维护，因此我们很少使用这种方式对事务进行管理。<br> 声明式事务易用性更高，对业务代码没有侵入性，耦合度低，易于维护，因此这种方式也是我们最常用的事务管理方式。</p><p>Spring 的声明式事务管理主要通过以下 2 种方式实现：<br> 基于 XML 方式的声明式事务管理<br> 基于注解方式的声明式事务管理</p><h2 id="事务管理器" tabindex="-1"><a class="header-anchor" href="#事务管理器"><span>事务管理器</span></a></h2><p>Spring 并不会直接管理事务，而是通过事务管理器对事务进行管理的。</p><p>在 Spring 中提供了一个 org.springframework.transaction.PlatformTransactionManager 接口，这个接口被称为 Spring 的事务管理器，其源码如下。<br> public interface PlatformTransactionManager extends TransactionManager {<br> TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException;<br> void commit(TransactionStatus status) throws TransactionException;<br> void rollback(TransactionStatus status) throws TransactionException;<br> }</p><p>该接口中各方法说明如下：</p><p>名称 说明<br> TransactionStatus getTransaction(TransactionDefinition definition) 用于获取事务的状态信息<br> void commit(TransactionStatus status) 用于提交事务<br> void rollback(TransactionStatus status) 用于回滚事务</p><p>Spring 为不同的持久化框架或平台（例如 JDBC、Hibernate、JPA 以及 JTA 等）提供了不同的 PlatformTransactionManager 接口实现，这些实现类被称为事务管理器实现。</p><p>实现类 说明<br> org.springframework.jdbc.datasource.DataSourceTransactionManager 使用 Spring JDBC 或 iBatis 进行持久化数据时使用。<br> org.springframework.orm.hibernate3.HibernateTransactionManager 使用 Hibernate 3.0 及以上版本进行持久化数据时使用。<br> org.springframework.orm.jpa.JpaTransactionManager 使用 JPA 进行持久化时使用。<br> org.springframework.jdo.JdoTransactionManager 当持久化机制是 Jdo 时使用。<br> org.springframework.transaction.jta.JtaTransactionManager 使用 JTA 来实现事务管理，在一个事务跨越多个不同的资源（即分布式事务）使用该实现。</p><p>这些事务管理器的使用方式十分简单，我们只要根据持久化框架（或平台）选用相应的事务管理器实现，即可实现对事物的管理，而不必关心实际事务实现到底是什么。</p><h2 id="transactiondefinition-接口" tabindex="-1"><a class="header-anchor" href="#transactiondefinition-接口"><span>TransactionDefinition 接口</span></a></h2><p>Spring 将 XML 配置中的事务信息封装到对象 TransactionDefinition 中，然后通过事务管理器的 getTransaction() 方法获得事务的状态（TransactionStatus），并对事务进行下一步的操作。</p><p>TransactionDefinition 接口提供了获取事务相关信息的方法，接口定义如下。<br> public interface TransactionDefinition {<br> int getPropagationBehavior();<br> int getIsolationLevel();<br> String getName();<br> int getTimeout();<br> boolean isReadOnly();<br> }</p><p>该接口中方法说明如下。</p><p>方法 说明<br> String getName() 获取事务的名称<br> int getIsolationLevel() 获取事务的隔离级别<br> int getPropagationBehavior() 获取事务的传播行为<br> int getTimeout() 获取事务的超时时间<br> boolean isReadOnly() 获取事务是否只读<br> 事务的隔离级别<br> 事务的隔离级别定义了一个事务可能受其他并发事务影响的程度。</p><p>在实际应用中，经常会出现多个事务同时对同一数据执行不同操作，来实现各自的任务的情况。此时就有可能导致脏读、幻读以及不可重复读等问题的出现。</p><p>在理想情况下，事务之间是完全隔离的，这自然不会出现上述问题。但完全的事务隔离会导致性能问题，而且并不是所有的应用都需要事务的完全隔离，因此有时应用程序在事务隔离上也有一定的灵活性。</p><p>Spring 中提供了以下隔离级别，我们可以根据自身的需求自行选择合适的隔离级别。</p><p>方法 说明<br> ISOLATION_DEFAULT 使用后端数据库默认的隔离级别<br> ISOLATION_READ_UNCOMMITTED 允许读取尚未提交的更改，可能导致脏读、幻读和不可重复读<br> ISOLATION_READ_COMMITTED Oracle 默认级别，允许读取已提交的并发事务，防止脏读，可能出现幻读和不可重复读<br> ISOLATION_REPEATABLE_READ MySQL 默认级别，多次读取相同字段的结果是一致的，防止脏读和不可重复读，可能出现幻读<br> ISOLATION_SERIALIZABLE 完全服从 ACID 的隔离级别，防止脏读、不可重复读和幻读<br> 关于事务隔离级别、脏读、幻读、不可重复度等概念的详细介绍，请阅读《数据库事务隔离级别》一节。</p><p>事务的传播行为<br> 事务传播行为（propagation behavior）指的是，当一个事务方法被另一个事务方法调用时，这个事务方法应该如何运行。例如，事务方法 A 在调用事务方法 B 时，B 方法是继续在调用者 A 方法的事务中运行呢，还是为自己开启一个新事务运行，这就是由事务方法 B 的事务传播行为决定的。<br> 事务方法指的是能让数据库表数据发生改变的方法，例如新增数据、删除数据、修改数据的方法。</p><p>Spring 提供了以下 7 种不同的事务传播行为。</p><p>名称 说明<br> PROPAGATION_MANDATORY 支持当前事务，如果不存在当前事务，则引发异常。<br> PROPAGATION_NESTED 如果当前事务存在，则在嵌套事务中执行。<br> PROPAGATION_NEVER 不支持当前事务，如果当前事务存在，则引发异常。<br> PROPAGATION_NOT_SUPPORTED 不支持当前事务，始终以非事务方式执行。<br> PROPAGATION_REQUIRED 默认传播行为，如果存在当前事务，则当前方法就在当前事务中运行，如果不存在，则创建一个新的事务，并在这个新建的事务中运行。<br> PROPAGATION_REQUIRES_NEW 创建新事务，如果已经存在事务则暂停当前事务。<br> PROPAGATION_SUPPORTS 支持当前事务，如果不存在事务，则以非事务方式执行。</p><h2 id="transactionstatus-接口" tabindex="-1"><a class="header-anchor" href="#transactionstatus-接口"><span>TransactionStatus 接口</span></a></h2><p>TransactionStatus 接口提供了一些简单的方法，来控制事务的执行、查询事务的状态，接口定义如下。<br> public interface TransactionStatus extends SavepointManager {<br> boolean isNewTransaction();<br> boolean hasSavepoint();<br> void setRollbackOnly();<br> boolean isRollbackOnly();<br> boolean isCompleted();<br> }</p><p>该接口中各方法说明如下。</p><p>名称 说明<br> boolean hasSavepoint() 获取是否存在保存点<br> boolean isCompleted() 获取事务是否完成<br> boolean isNewTransaction() 获取是否是新事务<br> boolean isRollbackOnly() 获取事务是否回滚<br> void setRollbackOnly() 设置事务回滚</p>',32)]))}const l=t(o,[["render",e],["__file","Spring事务.html.vue"]]),b=JSON.parse('{"path":"/java/Spring/Spring%E4%BA%8B%E5%8A%A1.html","title":"","lang":"zh-CN","frontmatter":{"description":"事务具有 4 个特性：原子性、一致性、隔离性和持久性，简称为 ACID 特性。 原子性（Atomicity）：一个事务是一个不可分割的工作单位，事务中包括的动作要么都做要么都不做。 一致性（Consistency）：事务必须保证数据库从一个一致性状态变到另一个一致性状态，一致性和原子性是密切相关的。 隔离性（Isolation）：一个事务的执行不能被其...","head":[["meta",{"property":"og:url","content":"https://0oWSQo0.github.io/wsq-blog/java/Spring/Spring%E4%BA%8B%E5%8A%A1.html"}],["meta",{"property":"og:description","content":"事务具有 4 个特性：原子性、一致性、隔离性和持久性，简称为 ACID 特性。 原子性（Atomicity）：一个事务是一个不可分割的工作单位，事务中包括的动作要么都做要么都不做。 一致性（Consistency）：事务必须保证数据库从一个一致性状态变到另一个一致性状态，一致性和原子性是密切相关的。 隔离性（Isolation）：一个事务的执行不能被其..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-04-23T09:49:11.000Z"}],["meta",{"property":"article:modified_time","content":"2025-04-23T09:49:11.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-04-23T09:49:11.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"WSQ\\",\\"url\\":\\"https://0oWSQo0.github.com\\"}]}"]]},"headers":[{"level":2,"title":"事务管理方式","slug":"事务管理方式","link":"#事务管理方式","children":[]},{"level":2,"title":"事务管理器","slug":"事务管理器","link":"#事务管理器","children":[]},{"level":2,"title":"TransactionDefinition 接口","slug":"transactiondefinition-接口","link":"#transactiondefinition-接口","children":[]},{"level":2,"title":"TransactionStatus 接口","slug":"transactionstatus-接口","link":"#transactionstatus-接口","children":[]}],"git":{"createdTime":1745401751000,"updatedTime":1745401751000,"contributors":[{"name":"WSQ","email":"592786982@qq.com","commits":1}]},"readingTime":{"minutes":7.12,"words":2135},"filePathRelative":"java/Spring/Spring事务.md","localizedDate":"2025年4月23日","autoDesc":true}');export{l as comp,b as data};
