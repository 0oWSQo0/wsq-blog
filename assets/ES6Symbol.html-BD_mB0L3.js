import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,d as l,o}from"./app-CRBxQhNH.js";const p={};function e(F,s){return o(),n("div",null,s[0]||(s[0]=[l(`<h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述"><span>概述</span></a></h2><p>ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（<code>mixin</code>模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入<code>Symbol</code>的原因。</p><p>ES6 引入了一种新的原始数据类型<code>Symbol</code>，表示独一无二的值。它属于 JavaScript 语言的原生数据类型之一，其他数据类型是：<code>undefined、null</code>、布尔值（<code>Boolean</code>）、字符串（<code>String</code>）、数值（<code>Number</code>）、大整数（<code>BigInt</code>）、对象（<code>Object</code>）。</p><p><code>Symbol</code>值通过<code>Symbol()</code>函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的<code>Symbol</code>类型。凡是属性名属于<code>Symbol</code>类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> s </span><span style="color:#FF9492;">=</span><span style="color:#DBB7FF;"> Symbol</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">typeof</span><span style="color:#F0F3F6;"> s</span></span>
<span class="line"><span style="color:#BDC4CC;">// &quot;symbol&quot;</span></span></code></pre></div><p>上面代码中，变量<code>s</code>就是一个独一无二的值。<code>typeof</code>运算符的结果，表明变量<code>s</code>是<code>Symbol</code>数据类型，而不是字符串之类的其他类型。</p><p>注意，<code>Symbol()</code>函数前不能使用<code>new</code>命令，否则会报错。这是因为生成的<code>Symbol</code>是一个原始类型的值，不是对象，所以不能使用<code>new</code>命令来调用。另外，由于<code>Symbol</code>值不是对象，所以也不能添加属性。基本上，它是一种类似于字符串的数据类型。</p><p><code>Symbol()</code>函数可以接受一个字符串作为参数，表示对<code>Symbol</code>实例的描述。这主要是为了在控制台显示，或者转为字符串时，比较容易区分。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> s1 </span><span style="color:#FF9492;">=</span><span style="color:#DBB7FF;"> Symbol</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;foo&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> s2 </span><span style="color:#FF9492;">=</span><span style="color:#DBB7FF;"> Symbol</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;bar&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">s1 </span><span style="color:#BDC4CC;">// Symbol(foo)</span></span>
<span class="line"><span style="color:#F0F3F6;">s2 </span><span style="color:#BDC4CC;">// Symbol(bar)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">s1.</span><span style="color:#DBB7FF;">toString</span><span style="color:#F0F3F6;">() </span><span style="color:#BDC4CC;">// &quot;Symbol(foo)&quot;</span></span>
<span class="line"><span style="color:#F0F3F6;">s2.</span><span style="color:#DBB7FF;">toString</span><span style="color:#F0F3F6;">() </span><span style="color:#BDC4CC;">// &quot;Symbol(bar)&quot;</span></span></code></pre></div><p>上面代码中，<code>s1</code>和<code>s2</code>是两个<code>Symbol</code>值。如果不加参数，它们在控制台的输出都是<code>Symbol()</code>，不利于区分。有了参数以后，就等于为它们加上了描述，输出的时候就能够分清，到底是哪一个值。</p><p>如果<code>Symbol</code>的参数是一个对象，就会调用该对象的<code>toString()</code>方法，将其转为字符串，然后才生成一个<code>Symbol</code>值。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> obj</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#DBB7FF;">  toString</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#FF9492;">    return</span><span style="color:#ADDCFF;"> &#39;abc&#39;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> sym</span><span style="color:#FF9492;"> =</span><span style="color:#DBB7FF;"> Symbol</span><span style="color:#F0F3F6;">(obj);</span></span>
<span class="line"><span style="color:#F0F3F6;">sym </span><span style="color:#BDC4CC;">// Symbol(abc)</span></span></code></pre></div><p>注意，<code>Symbol()</code>函数的参数只是表示对当前<code>Symbol</code>值的描述，因此相同参数的<code>Symbol</code>函数的返回值是不相等的。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">// 没有参数的情况</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> s1 </span><span style="color:#FF9492;">=</span><span style="color:#DBB7FF;"> Symbol</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> s2 </span><span style="color:#FF9492;">=</span><span style="color:#DBB7FF;"> Symbol</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">s1 </span><span style="color:#FF9492;">===</span><span style="color:#F0F3F6;"> s2 </span><span style="color:#BDC4CC;">// false</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;">// 有参数的情况</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> s1 </span><span style="color:#FF9492;">=</span><span style="color:#DBB7FF;"> Symbol</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;foo&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> s2 </span><span style="color:#FF9492;">=</span><span style="color:#DBB7FF;"> Symbol</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;foo&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">s1 </span><span style="color:#FF9492;">===</span><span style="color:#F0F3F6;"> s2 </span><span style="color:#BDC4CC;">// false</span></span></code></pre></div><p>上面代码中，<code>s1</code>和<code>s2</code>都是<code>Symbol()</code>函数的返回值，而且参数相同，但是它们是不相等的。事实上，如果调用 100 次<code>Symbol()</code>，会得到 100 个互不相等的值。</p><p><code>Symbol</code>值不能与其他类型的值进行运算，会报错。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> sym </span><span style="color:#FF9492;">=</span><span style="color:#DBB7FF;"> Symbol</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;My symbol&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ADDCFF;">&quot;your symbol is &quot;</span><span style="color:#FF9492;"> +</span><span style="color:#F0F3F6;"> sym</span></span>
<span class="line"><span style="color:#BDC4CC;">// TypeError: can&#39;t convert symbol to string</span></span>
<span class="line"><span style="color:#ADDCFF;">\`your symbol is \${</span><span style="color:#F0F3F6;">sym</span><span style="color:#ADDCFF;">}\`</span></span>
<span class="line"><span style="color:#BDC4CC;">// TypeError: can&#39;t convert symbol to string</span></span></code></pre></div><p>但是，<code>Symbol</code>值可以显式转为字符串。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> sym </span><span style="color:#FF9492;">=</span><span style="color:#DBB7FF;"> Symbol</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;My symbol&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#DBB7FF;">String</span><span style="color:#F0F3F6;">(sym) </span><span style="color:#BDC4CC;">// &#39;Symbol(My symbol)&#39;</span></span>
<span class="line"><span style="color:#F0F3F6;">sym.</span><span style="color:#DBB7FF;">toString</span><span style="color:#F0F3F6;">() </span><span style="color:#BDC4CC;">// &#39;Symbol(My symbol)&#39;</span></span></code></pre></div><p>另外，<code>Symbol</code>值也可以转为布尔值，但是不能转为数值。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> sym </span><span style="color:#FF9492;">=</span><span style="color:#DBB7FF;"> Symbol</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#DBB7FF;">Boolean</span><span style="color:#F0F3F6;">(sym) </span><span style="color:#BDC4CC;">// true</span></span>
<span class="line"><span style="color:#FF9492;">!</span><span style="color:#F0F3F6;">sym  </span><span style="color:#BDC4CC;">// false</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">if</span><span style="color:#F0F3F6;"> (sym) {</span></span>
<span class="line"><span style="color:#BDC4CC;">  // ...</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#DBB7FF;">Number</span><span style="color:#F0F3F6;">(sym) </span><span style="color:#BDC4CC;">// TypeError</span></span>
<span class="line"><span style="color:#F0F3F6;">sym </span><span style="color:#FF9492;">+</span><span style="color:#91CBFF;"> 2</span><span style="color:#BDC4CC;"> // TypeError</span></span></code></pre></div><h2 id="symbol-prototype-description" tabindex="-1"><a class="header-anchor" href="#symbol-prototype-description"><span>Symbol.prototype.description</span></a></h2><p><code>Symbol()</code>函数创建<code>Symbol</code>值时，可以用参数添加一个描述。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> sym</span><span style="color:#FF9492;"> =</span><span style="color:#DBB7FF;"> Symbol</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;foo&#39;</span><span style="color:#F0F3F6;">);</span></span></code></pre></div><p>上面代码中，<code>sym</code>这个值的描述就是字符串<code>foo</code>。</p><p>但是，读取这个描述需要将<code>Symbol</code>显式转为字符串，即下面的写法。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> sym</span><span style="color:#FF9492;"> =</span><span style="color:#DBB7FF;"> Symbol</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;foo&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#DBB7FF;">String</span><span style="color:#F0F3F6;">(sym) </span><span style="color:#BDC4CC;">// &quot;Symbol(foo)&quot;</span></span>
<span class="line"><span style="color:#F0F3F6;">sym.</span><span style="color:#DBB7FF;">toString</span><span style="color:#F0F3F6;">() </span><span style="color:#BDC4CC;">// &quot;Symbol(foo)&quot;</span></span></code></pre></div><p>上面的用法不是很方便。ES2019 提供了一个<code>Symbol</code>值的实例属性<code>description</code>，直接返回<code>Symbol</code>值的描述。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> sym</span><span style="color:#FF9492;"> =</span><span style="color:#DBB7FF;"> Symbol</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;foo&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">sym.description </span><span style="color:#BDC4CC;">// &quot;foo&quot;</span></span></code></pre></div><h3 id="作为属性名的-symbol" tabindex="-1"><a class="header-anchor" href="#作为属性名的-symbol"><span>作为属性名的 Symbol</span></a></h3><p>由于每一个<code>Symbol</code>值都是不相等的，这意味着只要<code>Symbol</code>值作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> mySymbol </span><span style="color:#FF9492;">=</span><span style="color:#DBB7FF;"> Symbol</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;">// 第一种写法</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> a </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> {};</span></span>
<span class="line"><span style="color:#F0F3F6;">a[mySymbol] </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &#39;Hello!&#39;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;">// 第二种写法</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> a </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">  [mySymbol]: </span><span style="color:#ADDCFF;">&#39;Hello!&#39;</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;">// 第三种写法</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> a </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> {};</span></span>
<span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">defineProperty</span><span style="color:#F0F3F6;">(a, mySymbol, { value: </span><span style="color:#ADDCFF;">&#39;Hello!&#39;</span><span style="color:#F0F3F6;"> });</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;">// 以上写法都得到同样结果</span></span>
<span class="line"><span style="color:#F0F3F6;">a[mySymbol] </span><span style="color:#BDC4CC;">// &quot;Hello!&quot;</span></span></code></pre></div><p>上面代码通过方括号结构和<code>Object.defineProperty()</code>方法，将对象的属性名指定为一个<code>Symbol</code>值。</p><p>注意，<code>Symbol</code>值作为对象属性名时，不能用点运算符。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> mySymbol</span><span style="color:#FF9492;"> =</span><span style="color:#DBB7FF;"> Symbol</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> a</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> {};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">a.mySymbol </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &#39;Hello!&#39;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">a[mySymbol] </span><span style="color:#BDC4CC;">// undefined</span></span>
<span class="line"><span style="color:#F0F3F6;">a[</span><span style="color:#ADDCFF;">&#39;mySymbol&#39;</span><span style="color:#F0F3F6;">] </span><span style="color:#BDC4CC;">// &quot;Hello!&quot;</span></span></code></pre></div><p>上面代码中，因为点运算符后面总是字符串，所以不会读取<code>mySymbol</code>作为标识名所指代的那个值，导致a的属性名实际上是一个字符串，而不是一个<code>Symbol</code>值。</p><p>同理，在对象的内部，使用<code>Symbol</code>值定义属性时，<code>Symbol</code>值必须放在方括号之中。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> s </span><span style="color:#FF9492;">=</span><span style="color:#DBB7FF;"> Symbol</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> obj </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">  [s]: </span><span style="color:#FF9492;">function</span><span style="color:#F0F3F6;"> (</span><span style="color:#FFB757;">arg</span><span style="color:#F0F3F6;">) { </span><span style="color:#FF9492;">...</span><span style="color:#F0F3F6;"> }</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">obj[s](</span><span style="color:#91CBFF;">123</span><span style="color:#F0F3F6;">);</span></span></code></pre></div><p>上面代码中，如果<code>s</code>不放在方括号中，该属性的键名就是字符串<code>s</code>，而不是s所代表的那个<code>Symbol</code>值。</p><p>采用增强的对象写法，上面代码的<code>obj</code>对象可以写得更简洁一些。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> obj </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">	[s](</span><span style="color:#FFB757;">arg</span><span style="color:#F0F3F6;">) { </span><span style="color:#FF9492;">...</span><span style="color:#F0F3F6;"> }</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span></code></pre></div><p><code>Symbol</code>类型还可以用于定义一组常量，保证这组常量的值都是不相等的。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> log</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> {};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">log.levels </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">  DEBUG: </span><span style="color:#DBB7FF;">Symbol</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;debug&#39;</span><span style="color:#F0F3F6;">),</span></span>
<span class="line"><span style="color:#F0F3F6;">  INFO: </span><span style="color:#DBB7FF;">Symbol</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;info&#39;</span><span style="color:#F0F3F6;">),</span></span>
<span class="line"><span style="color:#F0F3F6;">  WARN: </span><span style="color:#DBB7FF;">Symbol</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;warn&#39;</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span>
<span class="line"><span style="color:#F0F3F6;">console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(log.levels.</span><span style="color:#91CBFF;">DEBUG</span><span style="color:#F0F3F6;">, </span><span style="color:#ADDCFF;">&#39;debug message&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#F0F3F6;">console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(log.levels.</span><span style="color:#91CBFF;">INFO</span><span style="color:#F0F3F6;">, </span><span style="color:#ADDCFF;">&#39;info message&#39;</span><span style="color:#F0F3F6;">);</span></span></code></pre></div><p>下面是另外一个例子。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> COLOR_RED</span><span style="color:#FF9492;">    =</span><span style="color:#DBB7FF;"> Symbol</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> COLOR_GREEN</span><span style="color:#FF9492;">  =</span><span style="color:#DBB7FF;"> Symbol</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">function</span><span style="color:#DBB7FF;"> getComplement</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">color</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#FF9492;">  switch</span><span style="color:#F0F3F6;"> (color) {</span></span>
<span class="line"><span style="color:#FF9492;">    case</span><span style="color:#91CBFF;"> COLOR_RED</span><span style="color:#F0F3F6;">:</span></span>
<span class="line"><span style="color:#FF9492;">      return</span><span style="color:#91CBFF;"> COLOR_GREEN</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">    case</span><span style="color:#91CBFF;"> COLOR_GREEN</span><span style="color:#F0F3F6;">:</span></span>
<span class="line"><span style="color:#FF9492;">      return</span><span style="color:#91CBFF;"> COLOR_RED</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">    default</span><span style="color:#F0F3F6;">:</span></span>
<span class="line"><span style="color:#FF9492;">      throw</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> Error</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;Undefined color&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#F0F3F6;">    }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>常量使用<code>Symbol</code>值最大的好处，就是其他任何值都不可能有相同的值了，因此可以保证上面的<code>switch</code>语句会按设计的方式工作。</p><p>还有一点需要注意，<code>Symbol</code>值作为属性名时，该属性还是公开属性，不是私有属性。</p><h3 id="实例-消除魔术字符串" tabindex="-1"><a class="header-anchor" href="#实例-消除魔术字符串"><span>实例：消除魔术字符串</span></a></h3><p>魔术字符串指的是，在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。风格良好的代码，应该尽量消除魔术字符串，改由含义清晰的变量代替。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">function</span><span style="color:#DBB7FF;"> getArea</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">shape</span><span style="color:#F0F3F6;">, </span><span style="color:#FFB757;">options</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#FF9492;">  let</span><span style="color:#F0F3F6;"> area </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 0</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">  switch</span><span style="color:#F0F3F6;"> (shape) {</span></span>
<span class="line"><span style="color:#FF9492;">    case</span><span style="color:#ADDCFF;"> &#39;Triangle&#39;</span><span style="color:#F0F3F6;">: </span><span style="color:#BDC4CC;">// 魔术字符串</span></span>
<span class="line"><span style="color:#F0F3F6;">      area </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> .5</span><span style="color:#FF9492;"> *</span><span style="color:#F0F3F6;"> options.width </span><span style="color:#FF9492;">*</span><span style="color:#F0F3F6;"> options.height;</span></span>
<span class="line"><span style="color:#FF9492;">      break</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#BDC4CC;">    /* ... more code ... */</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">  return</span><span style="color:#F0F3F6;"> area;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#DBB7FF;">getArea</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;Triangle&#39;</span><span style="color:#F0F3F6;">, { width: </span><span style="color:#91CBFF;">100</span><span style="color:#F0F3F6;">, height: </span><span style="color:#91CBFF;">100</span><span style="color:#F0F3F6;"> }); </span><span style="color:#BDC4CC;">// 魔术字符串</span></span></code></pre></div><p>上面代码中，字符串<code>Triangle</code>就是一个魔术字符串。它多次出现，与代码形成“强耦合”，不利于将来的修改和维护。</p><p>常用的消除魔术字符串的方法，就是把它写成一个变量。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> shapeType</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">  triangle: </span><span style="color:#ADDCFF;">&#39;Triangle&#39;</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">function</span><span style="color:#DBB7FF;"> getArea</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">shape</span><span style="color:#F0F3F6;">, </span><span style="color:#FFB757;">options</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#FF9492;">  let</span><span style="color:#F0F3F6;"> area </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 0</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">  switch</span><span style="color:#F0F3F6;"> (shape) {</span></span>
<span class="line"><span style="color:#FF9492;">    case</span><span style="color:#F0F3F6;"> shapeType.triangle:</span></span>
<span class="line"><span style="color:#F0F3F6;">      area </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> .5</span><span style="color:#FF9492;"> *</span><span style="color:#F0F3F6;"> options.width </span><span style="color:#FF9492;">*</span><span style="color:#F0F3F6;"> options.height;</span></span>
<span class="line"><span style="color:#FF9492;">      break</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#FF9492;">  return</span><span style="color:#F0F3F6;"> area;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#DBB7FF;">getArea</span><span style="color:#F0F3F6;">(shapeType.triangle, { width: </span><span style="color:#91CBFF;">100</span><span style="color:#F0F3F6;">, height: </span><span style="color:#91CBFF;">100</span><span style="color:#F0F3F6;"> });</span></span></code></pre></div><p>上面代码中，我们把<code>Triangle</code>写成<code>shapeType</code>对象的<code>triangle</code>属性，这样就消除了强耦合。</p><p>如果仔细分析，可以发现<code>shapeType.triangle</code>等于哪个值并不重要，只要确保不会跟其他<code>shapeType</code>属性的值冲突即可。因此，这里就很适合改用<code>Symbol</code>值。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> shapeType</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">	triangle: </span><span style="color:#DBB7FF;">Symbol</span><span style="color:#F0F3F6;">()</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span></code></pre></div><p>上面代码中，除了将<code>shapeType.triangle</code>的值设为一个<code>Symbol</code>，其他地方都不用修改。</p><h2 id="属性名的遍历" tabindex="-1"><a class="header-anchor" href="#属性名的遍历"><span>属性名的遍历</span></a></h2><p><code>Symbol</code>值作为属性名，遍历对象的时候，该属性不会出现在<code>for...in、for...of</code>循环中，也不会被<code>Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()</code>返回。</p><p>但是，它也不是私有属性，有一个<code>Object.getOwnPropertySymbols()</code>方法，可以获取指定对象的所有<code>Symbol</code>属性名。该方法返回一个数组，成员是当前对象的所有用作属性名的<code>Symbol</code>值。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> obj</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> {};</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> a </span><span style="color:#FF9492;">=</span><span style="color:#DBB7FF;"> Symbol</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;a&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> b </span><span style="color:#FF9492;">=</span><span style="color:#DBB7FF;"> Symbol</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;b&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">obj[a] </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &#39;Hello&#39;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">obj[b] </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &#39;World&#39;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> objectSymbols</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> Object.</span><span style="color:#DBB7FF;">getOwnPropertySymbols</span><span style="color:#F0F3F6;">(obj);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">objectSymbols</span></span>
<span class="line"><span style="color:#BDC4CC;">// [Symbol(a), Symbol(b)]</span></span></code></pre></div><p>上面代码是<code>Object.getOwnPropertySymbols()</code>方法的示例，可以获取所有<code>Symbol</code>属性名。</p><p>下面是另一个例子，<code>Object.getOwnPropertySymbols()</code>方法与<code>for...in</code>循环、<code>Object.getOwnPropertyNames</code>方法进行对比的例子。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> obj</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> {};</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> foo</span><span style="color:#FF9492;"> =</span><span style="color:#DBB7FF;"> Symbol</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;foo&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">obj[foo] </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &#39;bar&#39;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">for</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> i </span><span style="color:#FF9492;">in</span><span style="color:#F0F3F6;"> obj) {</span></span>
<span class="line"><span style="color:#F0F3F6;">  console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(i); </span><span style="color:#BDC4CC;">// 无输出</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">getOwnPropertyNames</span><span style="color:#F0F3F6;">(obj) </span><span style="color:#BDC4CC;">// []</span></span>
<span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">getOwnPropertySymbols</span><span style="color:#F0F3F6;">(obj) </span><span style="color:#BDC4CC;">// [Symbol(foo)]</span></span></code></pre></div><p>上面代码中，使用<code>for...in</code>循环和<code>Object.getOwnPropertyNames()</code>方法都得不到<code>Symbol</code>键名，需要使用<code>Object.getOwnPropertySymbols()</code>方法。</p><p>另一个新的 API，<code>Reflect.ownKeys()</code>方法可以返回所有类型的键名，包括常规键名和<code>Symbol</code>键名。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> obj </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">  [</span><span style="color:#DBB7FF;">Symbol</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;my_key&#39;</span><span style="color:#F0F3F6;">)]: </span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#F0F3F6;">  enum: </span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">,</span></span>
<span class="line"><span style="color:#F0F3F6;">  nonEnum: </span><span style="color:#91CBFF;">3</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">Reflect.</span><span style="color:#DBB7FF;">ownKeys</span><span style="color:#F0F3F6;">(obj)</span></span>
<span class="line"><span style="color:#BDC4CC;">//  [&quot;enum&quot;, &quot;nonEnum&quot;, Symbol(my_key)]</span></span></code></pre></div><p>由于以<code>Symbol</code>值作为键名，不会被常规方法遍历得到。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> size </span><span style="color:#FF9492;">=</span><span style="color:#DBB7FF;"> Symbol</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;size&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Collection</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  constructor</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#91CBFF;">    this</span><span style="color:#F0F3F6;">[size] </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 0</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#DBB7FF;">  add</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">item</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#91CBFF;">    this</span><span style="color:#F0F3F6;">[</span><span style="color:#91CBFF;">this</span><span style="color:#F0F3F6;">[size]] </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> item;</span></span>
<span class="line"><span style="color:#91CBFF;">    this</span><span style="color:#F0F3F6;">[size]</span><span style="color:#FF9492;">++</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">  static</span><span style="color:#DBB7FF;"> sizeOf</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">instance</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#FF9492;">    return</span><span style="color:#F0F3F6;"> instance[size];</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> x </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> Collection</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#F0F3F6;">Collection.</span><span style="color:#DBB7FF;">sizeOf</span><span style="color:#F0F3F6;">(x) </span><span style="color:#BDC4CC;">// 0</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">x.</span><span style="color:#DBB7FF;">add</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;foo&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#F0F3F6;">Collection.</span><span style="color:#DBB7FF;">sizeOf</span><span style="color:#F0F3F6;">(x) </span><span style="color:#BDC4CC;">// 1</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">keys</span><span style="color:#F0F3F6;">(x) </span><span style="color:#BDC4CC;">// [&#39;0&#39;]</span></span>
<span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">getOwnPropertyNames</span><span style="color:#F0F3F6;">(x) </span><span style="color:#BDC4CC;">// [&#39;0&#39;]</span></span>
<span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">getOwnPropertySymbols</span><span style="color:#F0F3F6;">(x) </span><span style="color:#BDC4CC;">// [Symbol(size)]</span></span></code></pre></div><p>上面代码中，对象<code>x</code>的<code>size</code>属性是一个<code>Symbol</code>值，所以<code>Object.keys(x)、Object.getOwnPropertyNames(x)</code>都无法获取它。这就造成了一种非私有的内部方法的效果。</p><h2 id="symbol-for-symbol-keyfor" tabindex="-1"><a class="header-anchor" href="#symbol-for-symbol-keyfor"><span>Symbol.for()，Symbol.keyFor()</span></a></h2><p>有时，我们希望重新使用同一个<code>Symbol</code>值，<code>Symbol.for()</code>方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的<code>Symbol</code>值。如果有，就返回这个<code>Symbol</code>值，否则就新建一个以该字符串为名称的<code>Symbol</code>值，并将其注册到全局。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> s1 </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> Symbol.</span><span style="color:#DBB7FF;">for</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;foo&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> s2 </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> Symbol.</span><span style="color:#DBB7FF;">for</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;foo&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">s1 </span><span style="color:#FF9492;">===</span><span style="color:#F0F3F6;"> s2 </span><span style="color:#BDC4CC;">// true</span></span></code></pre></div><p>上面代码中，<code>s1</code>和<code>s2</code>都是<code>Symbol</code>值，但是它们都是由同样参数的<code>Symbol.for</code>方法生成的，所以实际上是同一个值。</p><p><code>Symbol.for()</code>与<code>Symbol()</code>这两种写法，都会生成新的<code>Symbol</code>。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。<code>Symbol.for()</code>不会每次调用就返回一个新的<code>Symbol</code>类型的值，而是会先检查给定的<code>key</code>是否已经存在，如果不存在才会新建一个值。比如，如果你调用<code>Symbol.for(&quot;cat&quot;)</code> 30 次，每次都会返回同一个<code>Symbol</code>值，但是调用<code>Symbol(&quot;cat&quot;)</code> 30 次，会返回 30 个不同的<code>Symbol</code>值。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">Symbol.</span><span style="color:#DBB7FF;">for</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;bar&quot;</span><span style="color:#F0F3F6;">) </span><span style="color:#FF9492;">===</span><span style="color:#F0F3F6;"> Symbol.</span><span style="color:#DBB7FF;">for</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;bar&quot;</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#BDC4CC;">// true</span></span>
<span class="line"></span>
<span class="line"><span style="color:#DBB7FF;">Symbol</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;bar&quot;</span><span style="color:#F0F3F6;">) </span><span style="color:#FF9492;">===</span><span style="color:#DBB7FF;"> Symbol</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;bar&quot;</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#BDC4CC;">// false</span></span></code></pre></div><p>上面代码中，由于<code>Symbol()</code>写法没有登记机制，所以每次调用都会返回一个不同的值。</p><p><code>Symbol.keyFor()</code>方法返回一个已登记的<code>Symbol</code>类型值的<code>key</code>。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> s1 </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> Symbol.</span><span style="color:#DBB7FF;">for</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;foo&quot;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#F0F3F6;">Symbol.</span><span style="color:#DBB7FF;">keyFor</span><span style="color:#F0F3F6;">(s1) </span><span style="color:#BDC4CC;">// &quot;foo&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> s2 </span><span style="color:#FF9492;">=</span><span style="color:#DBB7FF;"> Symbol</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&quot;foo&quot;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#F0F3F6;">Symbol.</span><span style="color:#DBB7FF;">keyFor</span><span style="color:#F0F3F6;">(s2) </span><span style="color:#BDC4CC;">// undefined</span></span></code></pre></div><p>上面代码中，变量<code>s2</code>属于未登记的<code>Symbol</code>值，所以返回<code>undefined</code>。</p><p>注意，<code>Symbol.for()</code>为<code>Symbol</code>值登记的名字，是全局环境的，不管有没有在全局环境运行。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">function</span><span style="color:#DBB7FF;"> foo</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#FF9492;">  return</span><span style="color:#F0F3F6;"> Symbol.</span><span style="color:#DBB7FF;">for</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;bar&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> x</span><span style="color:#FF9492;"> =</span><span style="color:#DBB7FF;"> foo</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> y</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> Symbol.</span><span style="color:#DBB7FF;">for</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;bar&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#F0F3F6;">console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(x </span><span style="color:#FF9492;">===</span><span style="color:#F0F3F6;"> y); </span><span style="color:#BDC4CC;">// true</span></span></code></pre></div><p>上面代码中，<code>Symbol.for(&#39;bar&#39;)</code>是函数内部运行的，但是生成的<code>Symbol</code>值是登记在全局环境的。所以，第二次运行<code>Symbol.for(&#39;bar&#39;)</code>可以取到这个<code>Symbol</code>值。</p><p><code>Symbol.for()</code>的这个全局登记特性，可以用在不同的<code>iframe</code>或<code>service worker</code>中取到同一个值。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">iframe </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> document.</span><span style="color:#DBB7FF;">createElement</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;iframe&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#F0F3F6;">iframe.src </span><span style="color:#FF9492;">=</span><span style="color:#DBB7FF;"> String</span><span style="color:#F0F3F6;">(window.location);</span></span>
<span class="line"><span style="color:#F0F3F6;">document.body.</span><span style="color:#DBB7FF;">appendChild</span><span style="color:#F0F3F6;">(iframe);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">iframe.contentWindow.Symbol.</span><span style="color:#DBB7FF;">for</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;foo&#39;</span><span style="color:#F0F3F6;">) </span><span style="color:#FF9492;">===</span><span style="color:#F0F3F6;"> Symbol.</span><span style="color:#DBB7FF;">for</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;foo&#39;</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#BDC4CC;">// true</span></span></code></pre></div><p>上面代码中，<code>iframe</code>窗口生成的<code>Symbol</code>值，可以在主页面得到。</p><h2 id="实例-模块的-singleton-模式" tabindex="-1"><a class="header-anchor" href="#实例-模块的-singleton-模式"><span>实例：模块的 Singleton 模式</span></a></h2><p><code>Singleton</code>模式指的是调用一个类，任何时候返回的都是同一个实例。</p><p>对于<code>Node</code>来说，模块文件可以看成是一个类。怎么保证每次执行这个模块文件，返回的都是同一个实例呢？</p><p>很容易想到，可以把实例放到顶层对象<code>global</code>。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">// mod.js</span></span>
<span class="line"><span style="color:#FF9492;">function</span><span style="color:#DBB7FF;"> A</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#91CBFF;">    this</span><span style="color:#F0F3F6;">.foo </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &#39;hello&#39;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">if</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">!</span><span style="color:#F0F3F6;">global._foo) {</span></span>
<span class="line"><span style="color:#F0F3F6;">    global._foo </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> A</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#91CBFF;">module</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">exports</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> global._foo;</span></span></code></pre></div><p>然后，加载上面的<code>mod.js</code>。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> a</span><span style="color:#FF9492;"> =</span><span style="color:#DBB7FF;"> require</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;./mod.js&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#F0F3F6;">console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(a.foo);</span></span></code></pre></div><p>上面代码中，变量<code>a</code>任何时候加载的都是<code>A</code>的同一个实例。</p><p>但是，这里有一个问题，全局变量<code>global._foo</code>是可写的，任何文件都可以修改。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">global._foo </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> { foo: </span><span style="color:#ADDCFF;">&#39;world&#39;</span><span style="color:#F0F3F6;"> };</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> a</span><span style="color:#FF9492;"> =</span><span style="color:#DBB7FF;"> require</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;./mod.js&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#F0F3F6;">console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(a.foo);</span></span></code></pre></div><p>上面的代码，会使得加载<code>mod.js</code>的脚本都失真。</p><p>为了防止这种情况出现，我们就可以使用<code>Symbol</code>。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">// mod.js</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> FOO_KEY</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> Symbol.</span><span style="color:#DBB7FF;">for</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;foo&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">function</span><span style="color:#DBB7FF;"> A</span><span style="color:#F0F3F6;">() {</span></span>
<span class="line"><span style="color:#91CBFF;">  this</span><span style="color:#F0F3F6;">.foo </span><span style="color:#FF9492;">=</span><span style="color:#ADDCFF;"> &#39;hello&#39;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">if</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">!</span><span style="color:#F0F3F6;">global[</span><span style="color:#91CBFF;">FOO_KEY</span><span style="color:#F0F3F6;">]) {</span></span>
<span class="line"><span style="color:#F0F3F6;">  global[</span><span style="color:#91CBFF;">FOO_KEY</span><span style="color:#F0F3F6;">] </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> A</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#91CBFF;">module</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">exports</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> global[</span><span style="color:#91CBFF;">FOO_KEY</span><span style="color:#F0F3F6;">];</span></span></code></pre></div><p>上面代码中，可以保证<code>global[FOO_KEY]</code>不会被无意间覆盖，但还是可以被改写。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">global[Symbol.</span><span style="color:#DBB7FF;">for</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;foo&#39;</span><span style="color:#F0F3F6;">)] </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> { foo: </span><span style="color:#ADDCFF;">&#39;world&#39;</span><span style="color:#F0F3F6;"> };</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> a</span><span style="color:#FF9492;"> =</span><span style="color:#DBB7FF;"> require</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;./mod.js&#39;</span><span style="color:#F0F3F6;">);</span></span></code></pre></div><p>如果键名使用<code>Symbol</code>方法生成，那么外部将无法引用这个值，当然也就无法改写。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">// mod.js</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> FOO_KEY</span><span style="color:#FF9492;"> =</span><span style="color:#DBB7FF;"> Symbol</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;foo&#39;</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;">// 后面代码相同 ……</span></span></code></pre></div><p>上面代码将导致其他脚本都无法引用<code>FOO_KEY</code>。但这样也有一个问题，就是如果多次执行这个脚本，每次得到的<code>FOO_KEY</code>都是不一样的。虽然<code>Node</code>会将脚本的执行结果缓存，一般情况下，不会多次执行同一个脚本，但是用户可以手动清除缓存，所以也不是绝对可靠。</p><h2 id="内置的-symbol-值" tabindex="-1"><a class="header-anchor" href="#内置的-symbol-值"><span>内置的 Symbol 值</span></a></h2><p>除了定义自己使用的<code>Symbol</code>值以外，ES6 还提供了 11 个内置的<code>Symbol</code>值，指向语言内部使用的方法。</p><h3 id="symbol-hasinstance" tabindex="-1"><a class="header-anchor" href="#symbol-hasinstance"><span>Symbol.hasInstance</span></a></h3><p>对象的<code>Symbol.hasInstance</code>属性，指向一个内部方法。当其他对象使用<code>instanceof</code>运算符，判断是否为该对象的实例时，会调用这个方法。比如，<code>foo instanceof Foo</code>在语言内部，实际调用的是<code>Foo[Symbol.hasInstance](foo)</code>。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> MyClass</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">  [Symbol.hasInstance](</span><span style="color:#FFB757;">foo</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#FF9492;">    return</span><span style="color:#F0F3F6;"> foo </span><span style="color:#FF9492;">instanceof</span><span style="color:#FFB757;"> Array</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">[</span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">3</span><span style="color:#F0F3F6;">] </span><span style="color:#FF9492;">instanceof</span><span style="color:#FFB757;"> new</span><span style="color:#FFB757;"> MyClass</span><span style="color:#F0F3F6;">() </span><span style="color:#BDC4CC;">// true</span></span></code></pre></div><p>上面代码中，<code>MyClass</code>是一个类，<code>new MyClass()</code>会返回一个实例。该实例的<code>Symbol.hasInstance</code>方法，会在进行<code>instanceof</code>运算时自动调用，判断左侧的运算子是否为<code>Array</code>的实例。</p><p>下面是另一个例子。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Even</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  static</span><span style="color:#F0F3F6;"> [Symbol.hasInstance](</span><span style="color:#FFB757;">obj</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#FF9492;">    return</span><span style="color:#DBB7FF;"> Number</span><span style="color:#F0F3F6;">(obj) </span><span style="color:#FF9492;">%</span><span style="color:#91CBFF;"> 2</span><span style="color:#FF9492;"> ===</span><span style="color:#91CBFF;"> 0</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;">// 等同于</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> Even</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">  [Symbol.hasInstance](</span><span style="color:#FFB757;">obj</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#FF9492;">    return</span><span style="color:#DBB7FF;"> Number</span><span style="color:#F0F3F6;">(obj) </span><span style="color:#FF9492;">%</span><span style="color:#91CBFF;"> 2</span><span style="color:#FF9492;"> ===</span><span style="color:#91CBFF;"> 0</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#91CBFF;">1</span><span style="color:#FF9492;"> instanceof</span><span style="color:#FFB757;"> Even</span><span style="color:#BDC4CC;"> // false</span></span>
<span class="line"><span style="color:#91CBFF;">2</span><span style="color:#FF9492;"> instanceof</span><span style="color:#FFB757;"> Even</span><span style="color:#BDC4CC;"> // true</span></span>
<span class="line"><span style="color:#91CBFF;">12345</span><span style="color:#FF9492;"> instanceof</span><span style="color:#FFB757;"> Even</span><span style="color:#BDC4CC;"> // false</span></span></code></pre></div><h3 id="symbol-isconcatspreadable" tabindex="-1"><a class="header-anchor" href="#symbol-isconcatspreadable"><span>Symbol.isConcatSpreadable</span></a></h3><p>对象的<code>Symbol.isConcatSpreadable</code>属性等于一个布尔值，表示该对象用于<code>Array.prototype.concat()</code>时，是否可以展开。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> arr1 </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [</span><span style="color:#ADDCFF;">&#39;c&#39;</span><span style="color:#F0F3F6;">, </span><span style="color:#ADDCFF;">&#39;d&#39;</span><span style="color:#F0F3F6;">];</span></span>
<span class="line"><span style="color:#F0F3F6;">[</span><span style="color:#ADDCFF;">&#39;a&#39;</span><span style="color:#F0F3F6;">, </span><span style="color:#ADDCFF;">&#39;b&#39;</span><span style="color:#F0F3F6;">].</span><span style="color:#DBB7FF;">concat</span><span style="color:#F0F3F6;">(arr1, </span><span style="color:#ADDCFF;">&#39;e&#39;</span><span style="color:#F0F3F6;">) </span><span style="color:#BDC4CC;">// [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]</span></span>
<span class="line"><span style="color:#F0F3F6;">arr1[Symbol.isConcatSpreadable] </span><span style="color:#BDC4CC;">// undefined</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> arr2 </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> [</span><span style="color:#ADDCFF;">&#39;c&#39;</span><span style="color:#F0F3F6;">, </span><span style="color:#ADDCFF;">&#39;d&#39;</span><span style="color:#F0F3F6;">];</span></span>
<span class="line"><span style="color:#F0F3F6;">arr2[Symbol.isConcatSpreadable] </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> false</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">[</span><span style="color:#ADDCFF;">&#39;a&#39;</span><span style="color:#F0F3F6;">, </span><span style="color:#ADDCFF;">&#39;b&#39;</span><span style="color:#F0F3F6;">].</span><span style="color:#DBB7FF;">concat</span><span style="color:#F0F3F6;">(arr2, </span><span style="color:#ADDCFF;">&#39;e&#39;</span><span style="color:#F0F3F6;">) </span><span style="color:#BDC4CC;">// [&#39;a&#39;, &#39;b&#39;, [&#39;c&#39;,&#39;d&#39;], &#39;e&#39;]</span></span></code></pre></div><p>上面代码说明，数组的默认行为是可以展开，<code>Symbol.isConcatSpreadable</code>默认等于<code>undefined</code>。该属性等于<code>true</code>时，也有展开的效果。</p><p>类似数组的对象正好相反，默认不展开。它的<code>Symbol.isConcatSpreadable</code>属性设为<code>true</code>，才可以展开。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> obj </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> {length: </span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">0</span><span style="color:#F0F3F6;">: </span><span style="color:#ADDCFF;">&#39;c&#39;</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">: </span><span style="color:#ADDCFF;">&#39;d&#39;</span><span style="color:#F0F3F6;">};</span></span>
<span class="line"><span style="color:#F0F3F6;">[</span><span style="color:#ADDCFF;">&#39;a&#39;</span><span style="color:#F0F3F6;">, </span><span style="color:#ADDCFF;">&#39;b&#39;</span><span style="color:#F0F3F6;">].</span><span style="color:#DBB7FF;">concat</span><span style="color:#F0F3F6;">(obj, </span><span style="color:#ADDCFF;">&#39;e&#39;</span><span style="color:#F0F3F6;">) </span><span style="color:#BDC4CC;">// [&#39;a&#39;, &#39;b&#39;, obj, &#39;e&#39;]</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">obj[Symbol.isConcatSpreadable] </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> true</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">[</span><span style="color:#ADDCFF;">&#39;a&#39;</span><span style="color:#F0F3F6;">, </span><span style="color:#ADDCFF;">&#39;b&#39;</span><span style="color:#F0F3F6;">].</span><span style="color:#DBB7FF;">concat</span><span style="color:#F0F3F6;">(obj, </span><span style="color:#ADDCFF;">&#39;e&#39;</span><span style="color:#F0F3F6;">) </span><span style="color:#BDC4CC;">// [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]</span></span></code></pre></div><p><code>Symbol.isConcatSpreadable</code>属性也可以定义在类里面。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> A1</span><span style="color:#FF9492;"> extends</span><span style="color:#91CBFF;"> Array</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  constructor</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">args</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#91CBFF;">    super</span><span style="color:#F0F3F6;">(args);</span></span>
<span class="line"><span style="color:#91CBFF;">    this</span><span style="color:#F0F3F6;">[Symbol.isConcatSpreadable] </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> true</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> A2</span><span style="color:#FF9492;"> extends</span><span style="color:#91CBFF;"> Array</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  constructor</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">args</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#91CBFF;">    super</span><span style="color:#F0F3F6;">(args);</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#FF9492;">  get</span><span style="color:#F0F3F6;"> [Symbol.isConcatSpreadable] () {</span></span>
<span class="line"><span style="color:#FF9492;">    return</span><span style="color:#91CBFF;"> false</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> a1 </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> A1</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#F0F3F6;">a1[</span><span style="color:#91CBFF;">0</span><span style="color:#F0F3F6;">] </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 3</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">a1[</span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">] </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 4</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> a2 </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> A2</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#F0F3F6;">a2[</span><span style="color:#91CBFF;">0</span><span style="color:#F0F3F6;">] </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 5</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">a2[</span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">] </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 6</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">[</span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">].</span><span style="color:#DBB7FF;">concat</span><span style="color:#F0F3F6;">(a1).</span><span style="color:#DBB7FF;">concat</span><span style="color:#F0F3F6;">(a2)</span></span>
<span class="line"><span style="color:#BDC4CC;">// [1, 2, 3, 4, [5, 6]]</span></span></code></pre></div><p>上面代码中，类<code>A1</code>是可展开的，类<code>A2</code>是不可展开的，所以使用<code>concat</code>时有不一样的结果。</p><p>注意，<code>Symbol.isConcatSpreadable</code>的位置差异，<code>A1</code>是定义在实例上，<code>A2</code>是定义在类本身，效果相同。</p><h3 id="symbol-species" tabindex="-1"><a class="header-anchor" href="#symbol-species"><span>Symbol.species</span></a></h3><p>对象的<code>Symbol.species</code>属性，指向一个构造函数。创建衍生对象时，会使用该属性。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> MyArray</span><span style="color:#FF9492;"> extends</span><span style="color:#91CBFF;"> Array</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> a</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> MyArray</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">2</span><span style="color:#F0F3F6;">, </span><span style="color:#91CBFF;">3</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> b</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> a.</span><span style="color:#DBB7FF;">map</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">x</span><span style="color:#FF9492;"> =&gt;</span><span style="color:#F0F3F6;"> x);</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> c</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> a.</span><span style="color:#DBB7FF;">filter</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">x</span><span style="color:#FF9492;"> =&gt;</span><span style="color:#F0F3F6;"> x </span><span style="color:#FF9492;">&gt;</span><span style="color:#91CBFF;"> 1</span><span style="color:#F0F3F6;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">b </span><span style="color:#FF9492;">instanceof</span><span style="color:#FFB757;"> MyArray</span><span style="color:#BDC4CC;"> // true</span></span>
<span class="line"><span style="color:#F0F3F6;">c </span><span style="color:#FF9492;">instanceof</span><span style="color:#FFB757;"> MyArray</span><span style="color:#BDC4CC;"> // true</span></span></code></pre></div><p>上面代码中，子类<code>MyArray</code>继承了父类<code>Array</code>，<code>a</code>是<code>MyArray</code>的实例，<code>b</code>和<code>c</code>是<code>a</code>的衍生对象。你可能会认为，<code>b</code>和<code>c</code>都是调用数组方法生成的，所以应该是数组（<code>Array</code>的实例），但实际上它们也是<code>MyArray</code>的实例。</p><p><code>Symbol.species</code>属性就是为了解决这个问题而提供的。现在，我们可以为<code>MyArray</code>设置<code>Symbol.species</code>属性。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> MyArray</span><span style="color:#FF9492;"> extends</span><span style="color:#91CBFF;"> Array</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">	static</span><span style="color:#FF9492;"> get</span><span style="color:#F0F3F6;"> [Symbol.species]() { </span><span style="color:#FF9492;">return</span><span style="color:#F0F3F6;"> Array; }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面代码中，由于定义了<code>Symbol.species</code>属性，创建衍生对象时就会使用这个属性返回的函数，作为构造函数。这个例子也说明，定义<code>Symbol.species</code>属性要采用<code>get</code>取值器。默认的<code>Symbol.species</code>属性等同于下面的写法。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#F0F3F6;">static get [Symbol.species]() {</span></span>
<span class="line"><span style="color:#FF9492;">	return</span><span style="color:#91CBFF;"> this</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>现在，再来看前面的例子。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> MyArray</span><span style="color:#FF9492;"> extends</span><span style="color:#91CBFF;"> Array</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">	static</span><span style="color:#FF9492;"> get</span><span style="color:#F0F3F6;"> [Symbol.species]() { </span><span style="color:#FF9492;">return</span><span style="color:#F0F3F6;"> Array; }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> a</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> MyArray</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> b</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> a.</span><span style="color:#DBB7FF;">map</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">x</span><span style="color:#FF9492;"> =&gt;</span><span style="color:#F0F3F6;"> x);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">b </span><span style="color:#FF9492;">instanceof</span><span style="color:#FFB757;"> MyArray</span><span style="color:#BDC4CC;"> // false</span></span>
<span class="line"><span style="color:#F0F3F6;">b </span><span style="color:#FF9492;">instanceof</span><span style="color:#FFB757;"> Array</span><span style="color:#BDC4CC;"> // true</span></span></code></pre></div><p>上面代码中，<code>a.map(x =&gt; x)</code>生成的衍生对象，就不是<code>MyArray</code>的实例，而直接就是<code>Array</code>的实例。</p><p>再看一个例子。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> T1</span><span style="color:#FF9492;"> extends</span><span style="color:#91CBFF;"> Promise</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> T2</span><span style="color:#FF9492;"> extends</span><span style="color:#91CBFF;"> Promise</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  static</span><span style="color:#FF9492;"> get</span><span style="color:#F0F3F6;"> [Symbol.species]() {</span></span>
<span class="line"><span style="color:#FF9492;">    return</span><span style="color:#91CBFF;"> Promise</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">new</span><span style="color:#DBB7FF;"> T1</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">r</span><span style="color:#FF9492;"> =&gt;</span><span style="color:#DBB7FF;"> r</span><span style="color:#F0F3F6;">()).</span><span style="color:#DBB7FF;">then</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">v</span><span style="color:#FF9492;"> =&gt;</span><span style="color:#F0F3F6;"> v) </span><span style="color:#FF9492;">instanceof</span><span style="color:#FFB757;"> T1</span><span style="color:#BDC4CC;"> // true</span></span>
<span class="line"><span style="color:#FF9492;">new</span><span style="color:#DBB7FF;"> T2</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">r</span><span style="color:#FF9492;"> =&gt;</span><span style="color:#DBB7FF;"> r</span><span style="color:#F0F3F6;">()).</span><span style="color:#DBB7FF;">then</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">v</span><span style="color:#FF9492;"> =&gt;</span><span style="color:#F0F3F6;"> v) </span><span style="color:#FF9492;">instanceof</span><span style="color:#FFB757;"> T2</span><span style="color:#BDC4CC;"> // false</span></span></code></pre></div><p>上面代码中，<code>T2</code>定义了<code>Symbol.species</code>属性，<code>T1</code>没有。结果就导致了创建衍生对象时（<code>then</code>方法），<code>T1</code>调用的是自身的构造方法，而<code>T2</code>调用的是<code>Promise</code>的构造方法。</p><p>总之，<code>Symbol.species</code>的作用在于，实例对象在运行过程中，需要再次调用自身的构造函数时，会调用该属性指定的构造函数。它主要的用途是，有些类库是在基类的基础上修改的，那么子类使用继承的方法时，作者可能希望返回基类的实例，而不是子类的实例。</p><h3 id="symbol-match" tabindex="-1"><a class="header-anchor" href="#symbol-match"><span>Symbol.match</span></a></h3><p>对象的<code>Symbol.match</code>属性，指向一个函数。当执行<code>str.match(myObject)</code>时，如果该属性存在，会调用它，返回该方法的返回值。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#91CBFF;">String</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">prototype</span><span style="color:#F0F3F6;">.</span><span style="color:#DBB7FF;">match</span><span style="color:#F0F3F6;">(regexp)</span></span>
<span class="line"><span style="color:#BDC4CC;">// 等同于</span></span>
<span class="line"><span style="color:#F0F3F6;">regexp[Symbol.match](</span><span style="color:#91CBFF;">this</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> MyMatcher</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">  [Symbol.match](</span><span style="color:#FFB757;">string</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#FF9492;">    return</span><span style="color:#ADDCFF;"> &#39;hello world&#39;</span><span style="color:#F0F3F6;">.</span><span style="color:#DBB7FF;">indexOf</span><span style="color:#F0F3F6;">(string);</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ADDCFF;">&#39;e&#39;</span><span style="color:#F0F3F6;">.</span><span style="color:#DBB7FF;">match</span><span style="color:#F0F3F6;">(</span><span style="color:#FF9492;">new</span><span style="color:#DBB7FF;"> MyMatcher</span><span style="color:#F0F3F6;">()) </span><span style="color:#BDC4CC;">// 1</span></span></code></pre></div><h3 id="symbol-replace" tabindex="-1"><a class="header-anchor" href="#symbol-replace"><span>Symbol.replace</span></a></h3><p>对象的<code>Symbol.replace</code>属性，指向一个方法，当该对象被<code>String.prototype.replace</code>方法调用时，会返回该方法的返回值。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#91CBFF;">String</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">prototype</span><span style="color:#F0F3F6;">.</span><span style="color:#DBB7FF;">replace</span><span style="color:#F0F3F6;">(searchValue, replaceValue)</span></span>
<span class="line"><span style="color:#BDC4CC;">// 等同于</span></span>
<span class="line"><span style="color:#F0F3F6;">searchValue[Symbol.replace](</span><span style="color:#91CBFF;">this</span><span style="color:#F0F3F6;">, replaceValue)</span></span></code></pre></div><p>下面是一个例子。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> x</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> {};</span></span>
<span class="line"><span style="color:#F0F3F6;">x[Symbol.replace] </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> (</span><span style="color:#FF9492;">...</span><span style="color:#FFB757;">s</span><span style="color:#F0F3F6;">) </span><span style="color:#FF9492;">=&gt;</span><span style="color:#F0F3F6;"> console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(s);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ADDCFF;">&#39;Hello&#39;</span><span style="color:#F0F3F6;">.</span><span style="color:#DBB7FF;">replace</span><span style="color:#F0F3F6;">(x, </span><span style="color:#ADDCFF;">&#39;World&#39;</span><span style="color:#F0F3F6;">) </span><span style="color:#BDC4CC;">// [&quot;Hello&quot;, &quot;World&quot;]</span></span></code></pre></div><p><code>Symbol.replace</code>方法会收到两个参数，第一个参数是<code>replace</code>方法正在作用的对象，上面例子是<code>Hello</code>，第二个参数是替换后的值，上面例子是<code>World</code>。</p><h3 id="symbol-search" tabindex="-1"><a class="header-anchor" href="#symbol-search"><span>Symbol.search</span></a></h3><p>对象的<code>Symbol.search</code>属性，指向一个方法，当该对象被<code>String.prototype.search</code>方法调用时，会返回该方法的返回值。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#91CBFF;">String</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">prototype</span><span style="color:#F0F3F6;">.</span><span style="color:#DBB7FF;">search</span><span style="color:#F0F3F6;">(regexp)</span></span>
<span class="line"><span style="color:#BDC4CC;">// 等同于</span></span>
<span class="line"><span style="color:#F0F3F6;">regexp[Symbol.search](</span><span style="color:#91CBFF;">this</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> MySearch</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  constructor</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">value</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#91CBFF;">    this</span><span style="color:#F0F3F6;">.value </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> value;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">  [Symbol.search](</span><span style="color:#FFB757;">string</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#FF9492;">    return</span><span style="color:#F0F3F6;"> string.</span><span style="color:#DBB7FF;">indexOf</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">this</span><span style="color:#F0F3F6;">.value);</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#ADDCFF;">&#39;foobar&#39;</span><span style="color:#F0F3F6;">.</span><span style="color:#DBB7FF;">search</span><span style="color:#F0F3F6;">(</span><span style="color:#FF9492;">new</span><span style="color:#DBB7FF;"> MySearch</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;foo&#39;</span><span style="color:#F0F3F6;">)) </span><span style="color:#BDC4CC;">// 0</span></span></code></pre></div><h3 id="symbol-split" tabindex="-1"><a class="header-anchor" href="#symbol-split"><span>Symbol.split</span></a></h3><p>对象的<code>Symbol.split</code>属性，指向一个方法，当该对象被<code>String.prototype.split</code>方法调用时，会返回该方法的返回值。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#91CBFF;">String</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">prototype</span><span style="color:#F0F3F6;">.</span><span style="color:#DBB7FF;">split</span><span style="color:#F0F3F6;">(separator, limit)</span></span>
<span class="line"><span style="color:#BDC4CC;">// 等同于</span></span>
<span class="line"><span style="color:#F0F3F6;">separator[Symbol.split](</span><span style="color:#91CBFF;">this</span><span style="color:#F0F3F6;">, limit)</span></span></code></pre></div><p>下面是一个例子。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> MySplitter</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  constructor</span><span style="color:#F0F3F6;">(</span><span style="color:#FFB757;">value</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#91CBFF;">    this</span><span style="color:#F0F3F6;">.value </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> value;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">  [Symbol.split](</span><span style="color:#FFB757;">string</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#FF9492;">    let</span><span style="color:#F0F3F6;"> index </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> string.</span><span style="color:#DBB7FF;">indexOf</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">this</span><span style="color:#F0F3F6;">.value);</span></span>
<span class="line"><span style="color:#FF9492;">    if</span><span style="color:#F0F3F6;"> (index </span><span style="color:#FF9492;">===</span><span style="color:#FF9492;"> -</span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#FF9492;">      return</span><span style="color:#F0F3F6;"> string;</span></span>
<span class="line"><span style="color:#F0F3F6;">    }</span></span>
<span class="line"><span style="color:#FF9492;">    return</span><span style="color:#F0F3F6;"> [</span></span>
<span class="line"><span style="color:#F0F3F6;">      string.</span><span style="color:#DBB7FF;">substr</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">0</span><span style="color:#F0F3F6;">, index),</span></span>
<span class="line"><span style="color:#F0F3F6;">      string.</span><span style="color:#DBB7FF;">substr</span><span style="color:#F0F3F6;">(index </span><span style="color:#FF9492;">+</span><span style="color:#91CBFF;"> this</span><span style="color:#F0F3F6;">.value.</span><span style="color:#91CBFF;">length</span><span style="color:#F0F3F6;">)</span></span>
<span class="line"><span style="color:#F0F3F6;">    ];</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ADDCFF;">&#39;foobar&#39;</span><span style="color:#F0F3F6;">.</span><span style="color:#DBB7FF;">split</span><span style="color:#F0F3F6;">(</span><span style="color:#FF9492;">new</span><span style="color:#DBB7FF;"> MySplitter</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;foo&#39;</span><span style="color:#F0F3F6;">))</span></span>
<span class="line"><span style="color:#BDC4CC;">// [&#39;&#39;, &#39;bar&#39;]</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ADDCFF;">&#39;foobar&#39;</span><span style="color:#F0F3F6;">.</span><span style="color:#DBB7FF;">split</span><span style="color:#F0F3F6;">(</span><span style="color:#FF9492;">new</span><span style="color:#DBB7FF;"> MySplitter</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;bar&#39;</span><span style="color:#F0F3F6;">))</span></span>
<span class="line"><span style="color:#BDC4CC;">// [&#39;foo&#39;, &#39;&#39;]</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ADDCFF;">&#39;foobar&#39;</span><span style="color:#F0F3F6;">.</span><span style="color:#DBB7FF;">split</span><span style="color:#F0F3F6;">(</span><span style="color:#FF9492;">new</span><span style="color:#DBB7FF;"> MySplitter</span><span style="color:#F0F3F6;">(</span><span style="color:#ADDCFF;">&#39;baz&#39;</span><span style="color:#F0F3F6;">))</span></span>
<span class="line"><span style="color:#BDC4CC;">// &#39;foobar&#39;</span></span></code></pre></div><p>上面方法使用<code>Symbol.split</code>方法，重新定义了字符串对象的<code>split</code>方法的行为，</p><h3 id="symbol-iterator" tabindex="-1"><a class="header-anchor" href="#symbol-iterator"><span>Symbol.iterator</span></a></h3><p>对象的<code>Symbol.iterator</code>属性，指向该对象的默认遍历器方法。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">const</span><span style="color:#91CBFF;"> myIterable</span><span style="color:#FF9492;"> =</span><span style="color:#F0F3F6;"> {};</span></span>
<span class="line"><span style="color:#F0F3F6;">myIterable[Symbol.iterator] </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> function*</span><span style="color:#F0F3F6;"> () {</span></span>
<span class="line"><span style="color:#FF9492;">  yield</span><span style="color:#91CBFF;"> 1</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">  yield</span><span style="color:#91CBFF;"> 2</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">  yield</span><span style="color:#91CBFF;"> 3</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">[</span><span style="color:#FF9492;">...</span><span style="color:#F0F3F6;">myIterable] </span><span style="color:#BDC4CC;">// [1, 2, 3]</span></span></code></pre></div><p>对象进行<code>for...of</code>循环时，会调用<code>Symbol.iterator</code>方法，返回该对象的默认遍历器。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Collection</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  *</span><span style="color:#F0F3F6;">[Symbol.iterator]() {</span></span>
<span class="line"><span style="color:#FF9492;">    let</span><span style="color:#F0F3F6;"> i </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 0</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">    while</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">this</span><span style="color:#F0F3F6;">[i] </span><span style="color:#FF9492;">!==</span><span style="color:#91CBFF;"> undefined</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#FF9492;">      yield</span><span style="color:#91CBFF;"> this</span><span style="color:#F0F3F6;">[i];</span></span>
<span class="line"><span style="color:#FF9492;">      ++</span><span style="color:#F0F3F6;">i;</span></span>
<span class="line"><span style="color:#F0F3F6;">    }</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> myCollection </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> Collection</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#F0F3F6;">myCollection[</span><span style="color:#91CBFF;">0</span><span style="color:#F0F3F6;">] </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 1</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">myCollection[</span><span style="color:#91CBFF;">1</span><span style="color:#F0F3F6;">] </span><span style="color:#FF9492;">=</span><span style="color:#91CBFF;"> 2</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">for</span><span style="color:#F0F3F6;">(</span><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> value </span><span style="color:#FF9492;">of</span><span style="color:#F0F3F6;"> myCollection) {</span></span>
<span class="line"><span style="color:#F0F3F6;">  console.</span><span style="color:#DBB7FF;">log</span><span style="color:#F0F3F6;">(value);</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#BDC4CC;">// 1</span></span>
<span class="line"><span style="color:#BDC4CC;">// 2</span></span></code></pre></div><h3 id="symbol-toprimitive" tabindex="-1"><a class="header-anchor" href="#symbol-toprimitive"><span>Symbol.toPrimitive</span></a></h3><p>对象的<code>Symbol.toPrimitive</code>属性，指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。</p><p><code>Symbol.toPrimitive</code>被调用时，会接受一个字符串参数，表示当前运算的模式，一共有三种模式。</p><ul><li><code>Number</code>：该场合需要转成数值</li><li><code>String</code>：该场合需要转成字符串</li><li><code>Default</code>：该场合可以转成数值，也可以转成字符串</li></ul><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> obj </span><span style="color:#FF9492;">=</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#F0F3F6;">  [Symbol.toPrimitive](</span><span style="color:#FFB757;">hint</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#FF9492;">    switch</span><span style="color:#F0F3F6;"> (hint) {</span></span>
<span class="line"><span style="color:#FF9492;">      case</span><span style="color:#ADDCFF;"> &#39;number&#39;</span><span style="color:#F0F3F6;">:</span></span>
<span class="line"><span style="color:#FF9492;">        return</span><span style="color:#91CBFF;"> 123</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">      case</span><span style="color:#ADDCFF;"> &#39;string&#39;</span><span style="color:#F0F3F6;">:</span></span>
<span class="line"><span style="color:#FF9492;">        return</span><span style="color:#ADDCFF;"> &#39;str&#39;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">      case</span><span style="color:#ADDCFF;"> &#39;default&#39;</span><span style="color:#F0F3F6;">:</span></span>
<span class="line"><span style="color:#FF9492;">        return</span><span style="color:#ADDCFF;"> &#39;default&#39;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#FF9492;">      default</span><span style="color:#F0F3F6;">:</span></span>
<span class="line"><span style="color:#FF9492;">        throw</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> Error</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#F0F3F6;">     }</span></span>
<span class="line"><span style="color:#F0F3F6;">   }</span></span>
<span class="line"><span style="color:#F0F3F6;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#91CBFF;">2</span><span style="color:#FF9492;"> *</span><span style="color:#F0F3F6;"> obj </span><span style="color:#BDC4CC;">// 246</span></span>
<span class="line"><span style="color:#91CBFF;">3</span><span style="color:#FF9492;"> +</span><span style="color:#F0F3F6;"> obj </span><span style="color:#BDC4CC;">// &#39;3default&#39;</span></span>
<span class="line"><span style="color:#F0F3F6;">obj </span><span style="color:#FF9492;">==</span><span style="color:#ADDCFF;"> &#39;default&#39;</span><span style="color:#BDC4CC;"> // true</span></span>
<span class="line"><span style="color:#DBB7FF;">String</span><span style="color:#F0F3F6;">(obj) </span><span style="color:#BDC4CC;">// &#39;str&#39;</span></span></code></pre></div><h3 id="symbol-tostringtag" tabindex="-1"><a class="header-anchor" href="#symbol-tostringtag"><span>Symbol.toStringTag</span></a></h3><p>对象的<code>Symbol.toStringTag</code>属性，用来设定一个字符串（设为其他类型的值无效，但不报错）。在目标对象上面调用<code>Object.prototype.toString()</code>方法时，如果<code>Symbol.toStringTag</code>属性存在，该属性设定的字符串会出现在<code>toString()</code>方法返回的字符串之中，表示对象的类型。也就是说，这个属性可以用来定制<code>[object Object]</code>或<code>[object Array]</code>中<code>object</code>后面的那个大写字符串。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">// 例一</span></span>
<span class="line"><span style="color:#F0F3F6;">({[Symbol.toStringTag]: </span><span style="color:#ADDCFF;">&#39;Foo&#39;</span><span style="color:#F0F3F6;">}.</span><span style="color:#DBB7FF;">toString</span><span style="color:#F0F3F6;">())</span></span>
<span class="line"><span style="color:#BDC4CC;">// &quot;[object Foo]&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;">// 例二</span></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> Collection</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#FF9492;">  get</span><span style="color:#F0F3F6;"> [Symbol.toStringTag]() {</span></span>
<span class="line"><span style="color:#FF9492;">    return</span><span style="color:#ADDCFF;"> &#39;xxx&#39;</span><span style="color:#F0F3F6;">;</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"><span style="color:#FF9492;">let</span><span style="color:#F0F3F6;"> x </span><span style="color:#FF9492;">=</span><span style="color:#FF9492;"> new</span><span style="color:#DBB7FF;"> Collection</span><span style="color:#F0F3F6;">();</span></span>
<span class="line"><span style="color:#91CBFF;">Object</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">prototype</span><span style="color:#F0F3F6;">.toString.</span><span style="color:#DBB7FF;">call</span><span style="color:#F0F3F6;">(x) </span><span style="color:#BDC4CC;">// &quot;[object xxx]&quot;</span></span></code></pre></div><p>ES6 新增内置对象的<code>Symbol.toStringTag</code>属性值如下。</p><ul><li><code>JSON[Symbol.toStringTag]：&#39;JSON&#39;</code></li><li><code>Math[Symbol.toStringTag]：&#39;Math&#39;</code></li><li><code>Module 对象M[Symbol.toStringTag]：&#39;Module&#39;</code></li><li><code>ArrayBuffer.prototype[Symbol.toStringTag]：&#39;ArrayBuffer&#39;</code></li><li><code>DataView.prototype[Symbol.toStringTag]：&#39;DataView&#39;</code></li><li><code>Map.prototype[Symbol.toStringTag]：&#39;Map&#39;</code></li><li><code>Promise.prototype[Symbol.toStringTag]：&#39;Promise&#39;</code></li><li><code>Set.prototype[Symbol.toStringTag]：&#39;Set&#39;</code></li><li><code>%TypedArray%.prototype[Symbol.toStringTag]：&#39;Uint8Array&#39;等</code></li><li><code>WeakMap.prototype[Symbol.toStringTag]：&#39;WeakMap&#39;</code></li><li><code>WeakSet.prototype[Symbol.toStringTag]：&#39;WeakSet&#39;</code></li><li><code>%MapIteratorPrototype%[Symbol.toStringTag]：&#39;Map Iterator&#39;</code></li><li><code>%SetIteratorPrototype%[Symbol.toStringTag]：&#39;Set Iterator&#39;</code></li><li><code>%StringIteratorPrototype%[Symbol.toStringTag]：&#39;String Iterator&#39;</code></li><li><code>Symbol.prototype[Symbol.toStringTag]：&#39;Symbol&#39;</code></li><li><code>Generator.prototype[Symbol.toStringTag]：&#39;Generator&#39;</code></li><li><code>GeneratorFunction.prototype[Symbol.toStringTag]：&#39;GeneratorFunction&#39;</code></li></ul><h3 id="symbol-unscopables" tabindex="-1"><a class="header-anchor" href="#symbol-unscopables"><span>Symbol.unscopables</span></a></h3><p>对象的<code>Symbol.unscopables</code>属性，指向一个对象。该对象指定了使用<code>with</code>关键字时，哪些属性会被<code>with</code>环境排除。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#91CBFF;">Array</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">prototype</span><span style="color:#F0F3F6;">[Symbol.unscopables]</span></span>
<span class="line"><span style="color:#BDC4CC;">// {</span></span>
<span class="line"><span style="color:#BDC4CC;">//   copyWithin: true,</span></span>
<span class="line"><span style="color:#BDC4CC;">//   entries: true,</span></span>
<span class="line"><span style="color:#BDC4CC;">//   fill: true,</span></span>
<span class="line"><span style="color:#BDC4CC;">//   find: true,</span></span>
<span class="line"><span style="color:#BDC4CC;">//   findIndex: true,</span></span>
<span class="line"><span style="color:#BDC4CC;">//   includes: true,</span></span>
<span class="line"><span style="color:#BDC4CC;">//   keys: true</span></span>
<span class="line"><span style="color:#BDC4CC;">// }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F0F3F6;">Object.</span><span style="color:#DBB7FF;">keys</span><span style="color:#F0F3F6;">(</span><span style="color:#91CBFF;">Array</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">prototype</span><span style="color:#F0F3F6;">[Symbol.unscopables])</span></span>
<span class="line"><span style="color:#BDC4CC;">// [&#39;copyWithin&#39;, &#39;entries&#39;, &#39;fill&#39;, &#39;find&#39;, &#39;findIndex&#39;, &#39;includes&#39;, &#39;keys&#39;]</span></span></code></pre></div><p>上面代码说明，数组有 7 个属性，会被<code>with</code>命令排除。</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#0a0c10;color:#f0f3f6;"><pre class="shiki github-dark-high-contrast vp-code"><code><span class="line"><span style="color:#BDC4CC;">// 没有 unscopables 时</span></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> MyClass</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#DBB7FF;">  foo</span><span style="color:#F0F3F6;">() { </span><span style="color:#FF9492;">return</span><span style="color:#91CBFF;"> 1</span><span style="color:#F0F3F6;">; }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">var</span><span style="color:#DBB7FF;"> foo</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> function</span><span style="color:#F0F3F6;"> () { </span><span style="color:#FF9492;">return</span><span style="color:#91CBFF;"> 2</span><span style="color:#F0F3F6;">; };</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">with</span><span style="color:#F0F3F6;"> (</span><span style="color:#91CBFF;">MyClass</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">prototype</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#DBB7FF;">  foo</span><span style="color:#F0F3F6;">(); </span><span style="color:#BDC4CC;">// 1</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BDC4CC;">// 有 unscopables 时</span></span>
<span class="line"><span style="color:#FF9492;">class</span><span style="color:#FFB757;"> MyClass</span><span style="color:#F0F3F6;"> {</span></span>
<span class="line"><span style="color:#DBB7FF;">  foo</span><span style="color:#F0F3F6;">() { </span><span style="color:#FF9492;">return</span><span style="color:#91CBFF;"> 1</span><span style="color:#F0F3F6;">; }</span></span>
<span class="line"><span style="color:#FF9492;">  get</span><span style="color:#F0F3F6;"> [Symbol.unscopables]() {</span></span>
<span class="line"><span style="color:#FF9492;">    return</span><span style="color:#F0F3F6;"> { foo: </span><span style="color:#91CBFF;">true</span><span style="color:#F0F3F6;"> };</span></span>
<span class="line"><span style="color:#F0F3F6;">  }</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">var</span><span style="color:#DBB7FF;"> foo</span><span style="color:#FF9492;"> =</span><span style="color:#FF9492;"> function</span><span style="color:#F0F3F6;"> () { </span><span style="color:#FF9492;">return</span><span style="color:#91CBFF;"> 2</span><span style="color:#F0F3F6;">; };</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF9492;">with</span><span style="color:#F0F3F6;"> (</span><span style="color:#91CBFF;">MyClass</span><span style="color:#F0F3F6;">.</span><span style="color:#91CBFF;">prototype</span><span style="color:#F0F3F6;">) {</span></span>
<span class="line"><span style="color:#DBB7FF;">  foo</span><span style="color:#F0F3F6;">(); </span><span style="color:#BDC4CC;">// 2</span></span>
<span class="line"><span style="color:#F0F3F6;">}</span></span></code></pre></div><p>上面代码通过指定<code>Symbol.unscopables</code>属性，使得<code>with</code>语法块不会在当前作用域寻找<code>foo</code>属性，即<code>foo</code>将指向外层作用域的变量。</p>`,176)]))}const r=a(p,[["render",e],["__file","ES6Symbol.html.vue"]]),y=JSON.parse('{"path":"/js/es6/ES6Symbol.html","title":"","lang":"zh-CN","frontmatter":{"description":"概述 ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入Symbol的原因。 ES6 引入了一种新的原始数据类型Sym...","head":[["meta",{"property":"og:url","content":"https://0oWSQo0.github.io/wsq-blog/js/es6/ES6Symbol.html"}],["meta",{"property":"og:description","content":"概述 ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入Symbol的原因。 ES6 引入了一种新的原始数据类型Sym..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-11-01T01:55:29.000Z"}],["meta",{"property":"article:modified_time","content":"2024-11-01T01:55:29.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-11-01T01:55:29.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"WSQ\\",\\"url\\":\\"https://0oWSQo0.github.com\\"}]}"]]},"headers":[{"level":2,"title":"概述","slug":"概述","link":"#概述","children":[]},{"level":2,"title":"Symbol.prototype.description","slug":"symbol-prototype-description","link":"#symbol-prototype-description","children":[{"level":3,"title":"作为属性名的 Symbol","slug":"作为属性名的-symbol","link":"#作为属性名的-symbol","children":[]},{"level":3,"title":"实例：消除魔术字符串","slug":"实例-消除魔术字符串","link":"#实例-消除魔术字符串","children":[]}]},{"level":2,"title":"属性名的遍历","slug":"属性名的遍历","link":"#属性名的遍历","children":[]},{"level":2,"title":"Symbol.for()，Symbol.keyFor()","slug":"symbol-for-symbol-keyfor","link":"#symbol-for-symbol-keyfor","children":[]},{"level":2,"title":"实例：模块的 Singleton 模式","slug":"实例-模块的-singleton-模式","link":"#实例-模块的-singleton-模式","children":[]},{"level":2,"title":"内置的 Symbol 值","slug":"内置的-symbol-值","link":"#内置的-symbol-值","children":[{"level":3,"title":"Symbol.hasInstance","slug":"symbol-hasinstance","link":"#symbol-hasinstance","children":[]},{"level":3,"title":"Symbol.isConcatSpreadable","slug":"symbol-isconcatspreadable","link":"#symbol-isconcatspreadable","children":[]},{"level":3,"title":"Symbol.species","slug":"symbol-species","link":"#symbol-species","children":[]},{"level":3,"title":"Symbol.match","slug":"symbol-match","link":"#symbol-match","children":[]},{"level":3,"title":"Symbol.replace","slug":"symbol-replace","link":"#symbol-replace","children":[]},{"level":3,"title":"Symbol.search","slug":"symbol-search","link":"#symbol-search","children":[]},{"level":3,"title":"Symbol.split","slug":"symbol-split","link":"#symbol-split","children":[]},{"level":3,"title":"Symbol.iterator","slug":"symbol-iterator","link":"#symbol-iterator","children":[]},{"level":3,"title":"Symbol.toPrimitive","slug":"symbol-toprimitive","link":"#symbol-toprimitive","children":[]},{"level":3,"title":"Symbol.toStringTag","slug":"symbol-tostringtag","link":"#symbol-tostringtag","children":[]},{"level":3,"title":"Symbol.unscopables","slug":"symbol-unscopables","link":"#symbol-unscopables","children":[]}]}],"git":{"createdTime":1730426129000,"updatedTime":1730426129000,"contributors":[{"name":"WSQ","email":"592786982@qq.com","commits":1}]},"readingTime":{"minutes":17.65,"words":5295},"filePathRelative":"js/es6/ES6Symbol.md","localizedDate":"2024年11月1日","autoDesc":true}');export{r as comp,y as data};
